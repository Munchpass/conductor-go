/*
Conductor API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 0.0.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package conductor

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// DefaultAPIService DefaultAPI service
type DefaultAPIService service

type ApiAuthSessionsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authSessionsPostRequest *AuthSessionsPostRequest
}

func (r ApiAuthSessionsPostRequest) AuthSessionsPostRequest(authSessionsPostRequest AuthSessionsPostRequest) ApiAuthSessionsPostRequest {
	r.authSessionsPostRequest = &authSessionsPostRequest
	return r
}

func (r ApiAuthSessionsPostRequest) Execute() (*AuthSession, *http.Response, error) {
	return r.ApiService.AuthSessionsPostExecute(r)
}

/*
AuthSessionsPost Create an auth session

To launch the authentication flow, create an auth session and pass the returned session's `authFlowUrl` to the client for your end-user to visit in their browser. Demo: https://connect.conductor.is/qbd/demo

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthSessionsPostRequest
*/
func (a *DefaultAPIService) AuthSessionsPost(ctx context.Context) ApiAuthSessionsPostRequest {
	return ApiAuthSessionsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthSession
func (a *DefaultAPIService) AuthSessionsPostExecute(r ApiAuthSessionsPostRequest) (*AuthSession, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.AuthSessionsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/auth-sessions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authSessionsPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndUsersGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
}

func (r ApiEndUsersGetRequest) Execute() (*EndUsersGet200Response, *http.Response, error) {
	return r.ApiService.EndUsersGetExecute(r)
}

/*
EndUsersGet List all end-users

Returns a list of your end-users.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEndUsersGetRequest
*/
func (a *DefaultAPIService) EndUsersGet(ctx context.Context) ApiEndUsersGetRequest {
	return ApiEndUsersGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EndUsersGet200Response
func (a *DefaultAPIService) EndUsersGetExecute(r ApiEndUsersGetRequest) (*EndUsersGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EndUsersGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.EndUsersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/end-users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndUsersIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
}

func (r ApiEndUsersIdDeleteRequest) Execute() (*EndUsersIdDelete200Response, *http.Response, error) {
	return r.ApiService.EndUsersIdDeleteExecute(r)
}

/*
EndUsersIdDelete Delete an end-user

Permanently deletes an end-user object and all of its connections.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the end-user to delete.
 @return ApiEndUsersIdDeleteRequest
*/
func (a *DefaultAPIService) EndUsersIdDelete(ctx context.Context, id string) ApiEndUsersIdDeleteRequest {
	return ApiEndUsersIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return EndUsersIdDelete200Response
func (a *DefaultAPIService) EndUsersIdDeleteExecute(r ApiEndUsersIdDeleteRequest) (*EndUsersIdDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EndUsersIdDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.EndUsersIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/end-users/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndUsersIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
}

func (r ApiEndUsersIdGetRequest) Execute() (*EndUser, *http.Response, error) {
	return r.ApiService.EndUsersIdGetExecute(r)
}

/*
EndUsersIdGet Retrieve an end-user

Retrieves an end-user object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the end-user to retrieve.
 @return ApiEndUsersIdGetRequest
*/
func (a *DefaultAPIService) EndUsersIdGet(ctx context.Context, id string) ApiEndUsersIdGetRequest {
	return ApiEndUsersIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return EndUser
func (a *DefaultAPIService) EndUsersIdGetExecute(r ApiEndUsersIdGetRequest) (*EndUser, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EndUser
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.EndUsersIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/end-users/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndUsersPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	endUsersPostRequest *EndUsersPostRequest
}

func (r ApiEndUsersPostRequest) EndUsersPostRequest(endUsersPostRequest EndUsersPostRequest) ApiEndUsersPostRequest {
	r.endUsersPostRequest = &endUsersPostRequest
	return r
}

func (r ApiEndUsersPostRequest) Execute() (*EndUser, *http.Response, error) {
	return r.ApiService.EndUsersPostExecute(r)
}

/*
EndUsersPost Create an end-user

Creates an end-user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEndUsersPostRequest
*/
func (a *DefaultAPIService) EndUsersPost(ctx context.Context) ApiEndUsersPostRequest {
	return ApiEndUsersPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EndUser
func (a *DefaultAPIService) EndUsersPostExecute(r ApiEndUsersPostRequest) (*EndUser, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EndUser
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.EndUsersPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/end-users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.endUsersPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopAccountsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	ids *[]string
	fullNames *[]string
	limit *int32
	status *string
	updatedAfter *string
	updatedBefore *string
	nameContains *string
	nameStartsWith *string
	nameEndsWith *string
	nameFrom *string
	nameTo *string
	accountType *string
	currencyIds *[]string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopAccountsGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopAccountsGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

// Filter for specific accounts by their QuickBooks-assigned unique identifier(s).  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopAccountsGetRequest) Ids(ids []string) ApiQuickbooksDesktopAccountsGetRequest {
	r.ids = &ids
	return r
}

// Filter for specific accounts by their full-name(s), case-insensitive. Like &#x60;id&#x60;, &#x60;fullName&#x60; is a unique identifier for an account, formed by by combining the names of its parent objects with its own &#x60;name&#x60;, separated by colons. For example, if an account is under \&quot;Corporate\&quot; and has the &#x60;name&#x60; \&quot;Accounts-Payable\&quot;, its &#x60;fullName&#x60; would be \&quot;Corporate:Accounts-Payable\&quot;.  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopAccountsGetRequest) FullNames(fullNames []string) ApiQuickbooksDesktopAccountsGetRequest {
	r.fullNames = &fullNames
	return r
}

// The maximum number of objects to return.  **IMPORTANT**: QuickBooks Desktop does not support cursor-based pagination for accounts. This parameter will limit the response size, but you cannot fetch subsequent results using a cursor. For pagination, use the name-range parameters instead (e.g., &#x60;nameFrom&#x3D;A&amp;nameTo&#x3D;B&#x60;).  When this parameter is omitted, the endpoint returns all accounts without limit, unlike paginated endpoints which default to 150 records. This is acceptable because accounts typically have low record counts.
func (r ApiQuickbooksDesktopAccountsGetRequest) Limit(limit int32) ApiQuickbooksDesktopAccountsGetRequest {
	r.limit = &limit
	return r
}

// Filter for accounts that are active, inactive, or both.
func (r ApiQuickbooksDesktopAccountsGetRequest) Status(status string) ApiQuickbooksDesktopAccountsGetRequest {
	r.status = &status
	return r
}

// Filter for accounts updated on or after this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 00:00:00 of that day.
func (r ApiQuickbooksDesktopAccountsGetRequest) UpdatedAfter(updatedAfter string) ApiQuickbooksDesktopAccountsGetRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Filter for accounts updated on or before this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 23:59:59 of that day.
func (r ApiQuickbooksDesktopAccountsGetRequest) UpdatedBefore(updatedBefore string) ApiQuickbooksDesktopAccountsGetRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Filter for accounts whose &#x60;name&#x60; contains this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameStartsWith&#x60; or &#x60;nameEndsWith&#x60;.
func (r ApiQuickbooksDesktopAccountsGetRequest) NameContains(nameContains string) ApiQuickbooksDesktopAccountsGetRequest {
	r.nameContains = &nameContains
	return r
}

// Filter for accounts whose &#x60;name&#x60; starts with this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameContains&#x60; or &#x60;nameEndsWith&#x60;.
func (r ApiQuickbooksDesktopAccountsGetRequest) NameStartsWith(nameStartsWith string) ApiQuickbooksDesktopAccountsGetRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Filter for accounts whose &#x60;name&#x60; ends with this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameContains&#x60; or &#x60;nameStartsWith&#x60;.
func (r ApiQuickbooksDesktopAccountsGetRequest) NameEndsWith(nameEndsWith string) ApiQuickbooksDesktopAccountsGetRequest {
	r.nameEndsWith = &nameEndsWith
	return r
}

// Filter for accounts whose &#x60;name&#x60; is alphabetically greater than or equal to this value.
func (r ApiQuickbooksDesktopAccountsGetRequest) NameFrom(nameFrom string) ApiQuickbooksDesktopAccountsGetRequest {
	r.nameFrom = &nameFrom
	return r
}

// Filter for accounts whose &#x60;name&#x60; is alphabetically less than or equal to this value.
func (r ApiQuickbooksDesktopAccountsGetRequest) NameTo(nameTo string) ApiQuickbooksDesktopAccountsGetRequest {
	r.nameTo = &nameTo
	return r
}

// Filter for accounts of this type.
func (r ApiQuickbooksDesktopAccountsGetRequest) AccountType(accountType string) ApiQuickbooksDesktopAccountsGetRequest {
	r.accountType = &accountType
	return r
}

// Filter for accounts in these currencies.
func (r ApiQuickbooksDesktopAccountsGetRequest) CurrencyIds(currencyIds []string) ApiQuickbooksDesktopAccountsGetRequest {
	r.currencyIds = &currencyIds
	return r
}

func (r ApiQuickbooksDesktopAccountsGetRequest) Execute() (*QuickbooksDesktopAccountsGet200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopAccountsGetExecute(r)
}

/*
QuickbooksDesktopAccountsGet List all accounts

Returns a list of accounts. NOTE: QuickBooks Desktop does not support pagination for accounts; hence, there is no `cursor` parameter. Users typically have few accounts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopAccountsGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopAccountsGet(ctx context.Context) ApiQuickbooksDesktopAccountsGetRequest {
	return ApiQuickbooksDesktopAccountsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopAccountsGet200Response
func (a *DefaultAPIService) QuickbooksDesktopAccountsGetExecute(r ApiQuickbooksDesktopAccountsGetRequest) (*QuickbooksDesktopAccountsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopAccountsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopAccountsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.fullNames != nil {
		t := *r.fullNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fullNames", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fullNames", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	} else {
		var defaultValue string = "active"
		r.status = &defaultValue
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.nameContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameContains", r.nameContains, "form", "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameStartsWith", r.nameStartsWith, "form", "")
	}
	if r.nameEndsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameEndsWith", r.nameEndsWith, "form", "")
	}
	if r.nameFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameFrom", r.nameFrom, "form", "")
	}
	if r.nameTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameTo", r.nameTo, "form", "")
	}
	if r.accountType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountType", r.accountType, "form", "")
	}
	if r.currencyIds != nil {
		t := *r.currencyIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopAccountsIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopAccountsIdGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopAccountsIdGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopAccountsIdGetRequest) Execute() (*QbdAccount, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopAccountsIdGetExecute(r)
}

/*
QuickbooksDesktopAccountsIdGet Retrieve an account

Retrieves an account by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the account to retrieve.
 @return ApiQuickbooksDesktopAccountsIdGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopAccountsIdGet(ctx context.Context, id string) ApiQuickbooksDesktopAccountsIdGetRequest {
	return ApiQuickbooksDesktopAccountsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdAccount
func (a *DefaultAPIService) QuickbooksDesktopAccountsIdGetExecute(r ApiQuickbooksDesktopAccountsIdGetRequest) (*QbdAccount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdAccount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopAccountsIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/accounts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopAccountsIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
	quickbooksDesktopAccountsIdPostRequest *QuickbooksDesktopAccountsIdPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopAccountsIdPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopAccountsIdPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopAccountsIdPostRequest) QuickbooksDesktopAccountsIdPostRequest(quickbooksDesktopAccountsIdPostRequest QuickbooksDesktopAccountsIdPostRequest) ApiQuickbooksDesktopAccountsIdPostRequest {
	r.quickbooksDesktopAccountsIdPostRequest = &quickbooksDesktopAccountsIdPostRequest
	return r
}

func (r ApiQuickbooksDesktopAccountsIdPostRequest) Execute() (*QbdAccount, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopAccountsIdPostExecute(r)
}

/*
QuickbooksDesktopAccountsIdPost Update an account

Updates an existing financial account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the account to update.
 @return ApiQuickbooksDesktopAccountsIdPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopAccountsIdPost(ctx context.Context, id string) ApiQuickbooksDesktopAccountsIdPostRequest {
	return ApiQuickbooksDesktopAccountsIdPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdAccount
func (a *DefaultAPIService) QuickbooksDesktopAccountsIdPostExecute(r ApiQuickbooksDesktopAccountsIdPostRequest) (*QbdAccount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdAccount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopAccountsIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/accounts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopAccountsIdPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopAccountsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	quickbooksDesktopAccountsPostRequest *QuickbooksDesktopAccountsPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopAccountsPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopAccountsPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopAccountsPostRequest) QuickbooksDesktopAccountsPostRequest(quickbooksDesktopAccountsPostRequest QuickbooksDesktopAccountsPostRequest) ApiQuickbooksDesktopAccountsPostRequest {
	r.quickbooksDesktopAccountsPostRequest = &quickbooksDesktopAccountsPostRequest
	return r
}

func (r ApiQuickbooksDesktopAccountsPostRequest) Execute() (*QbdAccount, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopAccountsPostExecute(r)
}

/*
QuickbooksDesktopAccountsPost Create an account

Creates a new financial account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopAccountsPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopAccountsPost(ctx context.Context) ApiQuickbooksDesktopAccountsPostRequest {
	return ApiQuickbooksDesktopAccountsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QbdAccount
func (a *DefaultAPIService) QuickbooksDesktopAccountsPostExecute(r ApiQuickbooksDesktopAccountsPostRequest) (*QbdAccount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdAccount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopAccountsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopAccountsPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopBillCheckPaymentsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	ids *[]string
	refNumbers *[]string
	limit *int32
	cursor *string
	updatedAfter *string
	updatedBefore *string
	transactionDateFrom *string
	transactionDateTo *string
	vendorIds *[]string
	accountIds *[]string
	refNumberContains *string
	refNumberStartsWith *string
	refNumberEndsWith *string
	refNumberFrom *string
	refNumberTo *string
	currencyIds *[]string
	includeLineItems *bool
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopBillCheckPaymentsGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopBillCheckPaymentsGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

// Filter for specific bill check payments by their QuickBooks-assigned unique identifier(s).  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopBillCheckPaymentsGetRequest) Ids(ids []string) ApiQuickbooksDesktopBillCheckPaymentsGetRequest {
	r.ids = &ids
	return r
}

// Filter for specific bill check payments by their ref-number(s), case-sensitive. In QuickBooks, ref-numbers are not required to be unique and can be arbitrarily changed by the QuickBooks user.  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopBillCheckPaymentsGetRequest) RefNumbers(refNumbers []string) ApiQuickbooksDesktopBillCheckPaymentsGetRequest {
	r.refNumbers = &refNumbers
	return r
}

// The maximum number of objects to return. Accepts values ranging from 1 to 150, defaults to 150. When used with cursor-based pagination, this parameter controls how many results are returned per page. To paginate through results, combine this with the &#x60;cursor&#x60; parameter. Each response will include a &#x60;nextCursor&#x60; value that can be passed to subsequent requests to retrieve the next page of results.
func (r ApiQuickbooksDesktopBillCheckPaymentsGetRequest) Limit(limit int32) ApiQuickbooksDesktopBillCheckPaymentsGetRequest {
	r.limit = &limit
	return r
}

// The pagination token to fetch the next set of results when paginating with the &#x60;limit&#x60; parameter. Do not include this parameter on the first call. Use the &#x60;nextCursor&#x60; value returned in the previous response to request subsequent results.
func (r ApiQuickbooksDesktopBillCheckPaymentsGetRequest) Cursor(cursor string) ApiQuickbooksDesktopBillCheckPaymentsGetRequest {
	r.cursor = &cursor
	return r
}

// Filter for bill check payments updated on or after this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 00:00:00 of that day.
func (r ApiQuickbooksDesktopBillCheckPaymentsGetRequest) UpdatedAfter(updatedAfter string) ApiQuickbooksDesktopBillCheckPaymentsGetRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Filter for bill check payments updated on or before this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 23:59:59 of that day.
func (r ApiQuickbooksDesktopBillCheckPaymentsGetRequest) UpdatedBefore(updatedBefore string) ApiQuickbooksDesktopBillCheckPaymentsGetRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Filter for bill check payments whose &#x60;date&#x60; field is on or after this date, in ISO 8601 format (YYYY-MM-DD).
func (r ApiQuickbooksDesktopBillCheckPaymentsGetRequest) TransactionDateFrom(transactionDateFrom string) ApiQuickbooksDesktopBillCheckPaymentsGetRequest {
	r.transactionDateFrom = &transactionDateFrom
	return r
}

// Filter for bill check payments whose &#x60;date&#x60; field is on or before this date, in ISO 8601 format (YYYY-MM-DD).
func (r ApiQuickbooksDesktopBillCheckPaymentsGetRequest) TransactionDateTo(transactionDateTo string) ApiQuickbooksDesktopBillCheckPaymentsGetRequest {
	r.transactionDateTo = &transactionDateTo
	return r
}

// Filter for bill check payments sent to these vendors. These are the vendors who sent the bills paid by these checks.
func (r ApiQuickbooksDesktopBillCheckPaymentsGetRequest) VendorIds(vendorIds []string) ApiQuickbooksDesktopBillCheckPaymentsGetRequest {
	r.vendorIds = &vendorIds
	return r
}

// Filter for bill check payments associated with these accounts.
func (r ApiQuickbooksDesktopBillCheckPaymentsGetRequest) AccountIds(accountIds []string) ApiQuickbooksDesktopBillCheckPaymentsGetRequest {
	r.accountIds = &accountIds
	return r
}

// Filter for bill check payments whose &#x60;refNumber&#x60; contains this substring. (For checks, this field is the check number.) NOTE: If you use this parameter, you cannot also use &#x60;refNumberStartsWith&#x60; or &#x60;refNumberEndsWith&#x60;.
func (r ApiQuickbooksDesktopBillCheckPaymentsGetRequest) RefNumberContains(refNumberContains string) ApiQuickbooksDesktopBillCheckPaymentsGetRequest {
	r.refNumberContains = &refNumberContains
	return r
}

// Filter for bill check payments whose &#x60;refNumber&#x60; starts with this substring. (For checks, this field is the check number.) NOTE: If you use this parameter, you cannot also use &#x60;refNumberContains&#x60; or &#x60;refNumberEndsWith&#x60;.
func (r ApiQuickbooksDesktopBillCheckPaymentsGetRequest) RefNumberStartsWith(refNumberStartsWith string) ApiQuickbooksDesktopBillCheckPaymentsGetRequest {
	r.refNumberStartsWith = &refNumberStartsWith
	return r
}

// Filter for bill check payments whose &#x60;refNumber&#x60; ends with this substring. (For checks, this field is the check number.) NOTE: If you use this parameter, you cannot also use &#x60;refNumberContains&#x60; or &#x60;refNumberStartsWith&#x60;.
func (r ApiQuickbooksDesktopBillCheckPaymentsGetRequest) RefNumberEndsWith(refNumberEndsWith string) ApiQuickbooksDesktopBillCheckPaymentsGetRequest {
	r.refNumberEndsWith = &refNumberEndsWith
	return r
}

// Filter for bill check payments whose &#x60;refNumber&#x60; is greater than or equal to this value. (For checks, this field is the check number.) If omitted, the range will begin with the first number of the list. Uses a numerical comparison for values that contain only digits; otherwise, uses a lexicographical comparison.
func (r ApiQuickbooksDesktopBillCheckPaymentsGetRequest) RefNumberFrom(refNumberFrom string) ApiQuickbooksDesktopBillCheckPaymentsGetRequest {
	r.refNumberFrom = &refNumberFrom
	return r
}

// Filter for bill check payments whose &#x60;refNumber&#x60; is less than or equal to this value. (For checks, this field is the check number.) If omitted, the range will end with the last number of the list. Uses a numerical comparison for values that contain only digits; otherwise, uses a lexicographical comparison.
func (r ApiQuickbooksDesktopBillCheckPaymentsGetRequest) RefNumberTo(refNumberTo string) ApiQuickbooksDesktopBillCheckPaymentsGetRequest {
	r.refNumberTo = &refNumberTo
	return r
}

// Filter for bill check payments in these currencies.
func (r ApiQuickbooksDesktopBillCheckPaymentsGetRequest) CurrencyIds(currencyIds []string) ApiQuickbooksDesktopBillCheckPaymentsGetRequest {
	r.currencyIds = &currencyIds
	return r
}

// Whether to include line items in the response. Defaults to &#x60;true&#x60;.
func (r ApiQuickbooksDesktopBillCheckPaymentsGetRequest) IncludeLineItems(includeLineItems bool) ApiQuickbooksDesktopBillCheckPaymentsGetRequest {
	r.includeLineItems = &includeLineItems
	return r
}

func (r ApiQuickbooksDesktopBillCheckPaymentsGetRequest) Execute() (*QuickbooksDesktopBillCheckPaymentsGet200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopBillCheckPaymentsGetExecute(r)
}

/*
QuickbooksDesktopBillCheckPaymentsGet List all bill check payments

Returns a list of bill check payments. Use the `cursor` parameter to paginate through the results.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopBillCheckPaymentsGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopBillCheckPaymentsGet(ctx context.Context) ApiQuickbooksDesktopBillCheckPaymentsGetRequest {
	return ApiQuickbooksDesktopBillCheckPaymentsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopBillCheckPaymentsGet200Response
func (a *DefaultAPIService) QuickbooksDesktopBillCheckPaymentsGetExecute(r ApiQuickbooksDesktopBillCheckPaymentsGetRequest) (*QuickbooksDesktopBillCheckPaymentsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopBillCheckPaymentsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopBillCheckPaymentsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/bill-check-payments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.refNumbers != nil {
		t := *r.refNumbers
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "refNumbers", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "refNumbers", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 150
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.transactionDateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDateFrom", r.transactionDateFrom, "form", "")
	}
	if r.transactionDateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDateTo", r.transactionDateTo, "form", "")
	}
	if r.vendorIds != nil {
		t := *r.vendorIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vendorIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vendorIds", t, "form", "multi")
		}
	}
	if r.accountIds != nil {
		t := *r.accountIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountIds", t, "form", "multi")
		}
	}
	if r.refNumberContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberContains", r.refNumberContains, "form", "")
	}
	if r.refNumberStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberStartsWith", r.refNumberStartsWith, "form", "")
	}
	if r.refNumberEndsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberEndsWith", r.refNumberEndsWith, "form", "")
	}
	if r.refNumberFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberFrom", r.refNumberFrom, "form", "")
	}
	if r.refNumberTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberTo", r.refNumberTo, "form", "")
	}
	if r.currencyIds != nil {
		t := *r.currencyIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", t, "form", "multi")
		}
	}
	if r.includeLineItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLineItems", r.includeLineItems, "form", "")
	} else {
		var defaultValue bool = true
		r.includeLineItems = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopBillCheckPaymentsIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopBillCheckPaymentsIdDeleteRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopBillCheckPaymentsIdDeleteRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopBillCheckPaymentsIdDeleteRequest) Execute() (*QuickbooksDesktopBillCheckPaymentsIdDelete200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopBillCheckPaymentsIdDeleteExecute(r)
}

/*
QuickbooksDesktopBillCheckPaymentsIdDelete Delete a bill check payment

Permanently deletes a a bill check payment. The deletion will fail if the bill check payment is currently in use or has any linked transactions that are in use.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the bill check payment to delete.
 @return ApiQuickbooksDesktopBillCheckPaymentsIdDeleteRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopBillCheckPaymentsIdDelete(ctx context.Context, id string) ApiQuickbooksDesktopBillCheckPaymentsIdDeleteRequest {
	return ApiQuickbooksDesktopBillCheckPaymentsIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopBillCheckPaymentsIdDelete200Response
func (a *DefaultAPIService) QuickbooksDesktopBillCheckPaymentsIdDeleteExecute(r ApiQuickbooksDesktopBillCheckPaymentsIdDeleteRequest) (*QuickbooksDesktopBillCheckPaymentsIdDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopBillCheckPaymentsIdDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopBillCheckPaymentsIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/bill-check-payments/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopBillCheckPaymentsIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopBillCheckPaymentsIdGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopBillCheckPaymentsIdGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopBillCheckPaymentsIdGetRequest) Execute() (*QbdBillCheckPayment, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopBillCheckPaymentsIdGetExecute(r)
}

/*
QuickbooksDesktopBillCheckPaymentsIdGet Retrieve a bill check payment

Retrieves a bill check payment by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the bill check payment to retrieve.
 @return ApiQuickbooksDesktopBillCheckPaymentsIdGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopBillCheckPaymentsIdGet(ctx context.Context, id string) ApiQuickbooksDesktopBillCheckPaymentsIdGetRequest {
	return ApiQuickbooksDesktopBillCheckPaymentsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdBillCheckPayment
func (a *DefaultAPIService) QuickbooksDesktopBillCheckPaymentsIdGetExecute(r ApiQuickbooksDesktopBillCheckPaymentsIdGetRequest) (*QbdBillCheckPayment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdBillCheckPayment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopBillCheckPaymentsIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/bill-check-payments/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopBillCheckPaymentsIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
	quickbooksDesktopBillCheckPaymentsIdPostRequest *QuickbooksDesktopBillCheckPaymentsIdPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopBillCheckPaymentsIdPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopBillCheckPaymentsIdPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopBillCheckPaymentsIdPostRequest) QuickbooksDesktopBillCheckPaymentsIdPostRequest(quickbooksDesktopBillCheckPaymentsIdPostRequest QuickbooksDesktopBillCheckPaymentsIdPostRequest) ApiQuickbooksDesktopBillCheckPaymentsIdPostRequest {
	r.quickbooksDesktopBillCheckPaymentsIdPostRequest = &quickbooksDesktopBillCheckPaymentsIdPostRequest
	return r
}

func (r ApiQuickbooksDesktopBillCheckPaymentsIdPostRequest) Execute() (*QbdBillCheckPayment, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopBillCheckPaymentsIdPostExecute(r)
}

/*
QuickbooksDesktopBillCheckPaymentsIdPost Update a bill check payment

Updates an existing bill check payment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the bill check payment to update.
 @return ApiQuickbooksDesktopBillCheckPaymentsIdPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopBillCheckPaymentsIdPost(ctx context.Context, id string) ApiQuickbooksDesktopBillCheckPaymentsIdPostRequest {
	return ApiQuickbooksDesktopBillCheckPaymentsIdPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdBillCheckPayment
func (a *DefaultAPIService) QuickbooksDesktopBillCheckPaymentsIdPostExecute(r ApiQuickbooksDesktopBillCheckPaymentsIdPostRequest) (*QbdBillCheckPayment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdBillCheckPayment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopBillCheckPaymentsIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/bill-check-payments/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopBillCheckPaymentsIdPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopBillCheckPaymentsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	quickbooksDesktopBillCheckPaymentsPostRequest *QuickbooksDesktopBillCheckPaymentsPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopBillCheckPaymentsPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopBillCheckPaymentsPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopBillCheckPaymentsPostRequest) QuickbooksDesktopBillCheckPaymentsPostRequest(quickbooksDesktopBillCheckPaymentsPostRequest QuickbooksDesktopBillCheckPaymentsPostRequest) ApiQuickbooksDesktopBillCheckPaymentsPostRequest {
	r.quickbooksDesktopBillCheckPaymentsPostRequest = &quickbooksDesktopBillCheckPaymentsPostRequest
	return r
}

func (r ApiQuickbooksDesktopBillCheckPaymentsPostRequest) Execute() (*QbdBillCheckPayment, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopBillCheckPaymentsPostExecute(r)
}

/*
QuickbooksDesktopBillCheckPaymentsPost Create a bill check payment

Creates a new bill check payment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopBillCheckPaymentsPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopBillCheckPaymentsPost(ctx context.Context) ApiQuickbooksDesktopBillCheckPaymentsPostRequest {
	return ApiQuickbooksDesktopBillCheckPaymentsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QbdBillCheckPayment
func (a *DefaultAPIService) QuickbooksDesktopBillCheckPaymentsPostExecute(r ApiQuickbooksDesktopBillCheckPaymentsPostRequest) (*QbdBillCheckPayment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdBillCheckPayment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopBillCheckPaymentsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/bill-check-payments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopBillCheckPaymentsPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	ids *[]string
	refNumbers *[]string
	limit *int32
	cursor *string
	updatedAfter *string
	updatedBefore *string
	transactionDateFrom *string
	transactionDateTo *string
	vendorIds *[]string
	accountIds *[]string
	refNumberContains *string
	refNumberStartsWith *string
	refNumberEndsWith *string
	refNumberFrom *string
	refNumberTo *string
	currencyIds *[]string
	includeLineItems *bool
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

// Filter for specific bill credit card payments by their QuickBooks-assigned unique identifier(s).  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest) Ids(ids []string) ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest {
	r.ids = &ids
	return r
}

// Filter for specific bill credit card payments by their ref-number(s), case-sensitive. In QuickBooks, ref-numbers are not required to be unique and can be arbitrarily changed by the QuickBooks user.  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest) RefNumbers(refNumbers []string) ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest {
	r.refNumbers = &refNumbers
	return r
}

// The maximum number of objects to return. Accepts values ranging from 1 to 150, defaults to 150. When used with cursor-based pagination, this parameter controls how many results are returned per page. To paginate through results, combine this with the &#x60;cursor&#x60; parameter. Each response will include a &#x60;nextCursor&#x60; value that can be passed to subsequent requests to retrieve the next page of results.
func (r ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest) Limit(limit int32) ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest {
	r.limit = &limit
	return r
}

// The pagination token to fetch the next set of results when paginating with the &#x60;limit&#x60; parameter. Do not include this parameter on the first call. Use the &#x60;nextCursor&#x60; value returned in the previous response to request subsequent results.
func (r ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest) Cursor(cursor string) ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest {
	r.cursor = &cursor
	return r
}

// Filter for bill credit card payments updated on or after this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 00:00:00 of that day.
func (r ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest) UpdatedAfter(updatedAfter string) ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Filter for bill credit card payments updated on or before this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 23:59:59 of that day.
func (r ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest) UpdatedBefore(updatedBefore string) ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Filter for bill credit card payments whose &#x60;date&#x60; field is on or after this date, in ISO 8601 format (YYYY-MM-DD).
func (r ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest) TransactionDateFrom(transactionDateFrom string) ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest {
	r.transactionDateFrom = &transactionDateFrom
	return r
}

// Filter for bill credit card payments whose &#x60;date&#x60; field is on or before this date, in ISO 8601 format (YYYY-MM-DD).
func (r ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest) TransactionDateTo(transactionDateTo string) ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest {
	r.transactionDateTo = &transactionDateTo
	return r
}

// Filter for bill credit card payments sent to these vendors. These are the vendors who sent the bills paid by these credit card payments.
func (r ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest) VendorIds(vendorIds []string) ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest {
	r.vendorIds = &vendorIds
	return r
}

// Filter for bill credit card payments associated with these accounts.
func (r ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest) AccountIds(accountIds []string) ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest {
	r.accountIds = &accountIds
	return r
}

// Filter for bill credit card payments whose &#x60;refNumber&#x60; contains this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberStartsWith&#x60; or &#x60;refNumberEndsWith&#x60;.
func (r ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest) RefNumberContains(refNumberContains string) ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest {
	r.refNumberContains = &refNumberContains
	return r
}

// Filter for bill credit card payments whose &#x60;refNumber&#x60; starts with this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberContains&#x60; or &#x60;refNumberEndsWith&#x60;.
func (r ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest) RefNumberStartsWith(refNumberStartsWith string) ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest {
	r.refNumberStartsWith = &refNumberStartsWith
	return r
}

// Filter for bill credit card payments whose &#x60;refNumber&#x60; ends with this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberContains&#x60; or &#x60;refNumberStartsWith&#x60;.
func (r ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest) RefNumberEndsWith(refNumberEndsWith string) ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest {
	r.refNumberEndsWith = &refNumberEndsWith
	return r
}

// Filter for bill credit card payments whose &#x60;refNumber&#x60; is greater than or equal to this value. If omitted, the range will begin with the first number of the list. Uses a numerical comparison for values that contain only digits; otherwise, uses a lexicographical comparison.
func (r ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest) RefNumberFrom(refNumberFrom string) ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest {
	r.refNumberFrom = &refNumberFrom
	return r
}

// Filter for bill credit card payments whose &#x60;refNumber&#x60; is less than or equal to this value. If omitted, the range will end with the last number of the list. Uses a numerical comparison for values that contain only digits; otherwise, uses a lexicographical comparison.
func (r ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest) RefNumberTo(refNumberTo string) ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest {
	r.refNumberTo = &refNumberTo
	return r
}

// Filter for bill credit card payments in these currencies.
func (r ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest) CurrencyIds(currencyIds []string) ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest {
	r.currencyIds = &currencyIds
	return r
}

// Whether to include line items in the response. Defaults to &#x60;true&#x60;.
func (r ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest) IncludeLineItems(includeLineItems bool) ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest {
	r.includeLineItems = &includeLineItems
	return r
}

func (r ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest) Execute() (*QuickbooksDesktopBillCreditCardPaymentsGet200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopBillCreditCardPaymentsGetExecute(r)
}

/*
QuickbooksDesktopBillCreditCardPaymentsGet List all bill credit card payments

Returns a list of bill credit card payments. Use the `cursor` parameter to paginate through the results.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopBillCreditCardPaymentsGet(ctx context.Context) ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest {
	return ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopBillCreditCardPaymentsGet200Response
func (a *DefaultAPIService) QuickbooksDesktopBillCreditCardPaymentsGetExecute(r ApiQuickbooksDesktopBillCreditCardPaymentsGetRequest) (*QuickbooksDesktopBillCreditCardPaymentsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopBillCreditCardPaymentsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopBillCreditCardPaymentsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/bill-credit-card-payments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.refNumbers != nil {
		t := *r.refNumbers
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "refNumbers", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "refNumbers", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 150
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.transactionDateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDateFrom", r.transactionDateFrom, "form", "")
	}
	if r.transactionDateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDateTo", r.transactionDateTo, "form", "")
	}
	if r.vendorIds != nil {
		t := *r.vendorIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vendorIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vendorIds", t, "form", "multi")
		}
	}
	if r.accountIds != nil {
		t := *r.accountIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountIds", t, "form", "multi")
		}
	}
	if r.refNumberContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberContains", r.refNumberContains, "form", "")
	}
	if r.refNumberStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberStartsWith", r.refNumberStartsWith, "form", "")
	}
	if r.refNumberEndsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberEndsWith", r.refNumberEndsWith, "form", "")
	}
	if r.refNumberFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberFrom", r.refNumberFrom, "form", "")
	}
	if r.refNumberTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberTo", r.refNumberTo, "form", "")
	}
	if r.currencyIds != nil {
		t := *r.currencyIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", t, "form", "multi")
		}
	}
	if r.includeLineItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLineItems", r.includeLineItems, "form", "")
	} else {
		var defaultValue bool = true
		r.includeLineItems = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopBillCreditCardPaymentsIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopBillCreditCardPaymentsIdDeleteRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopBillCreditCardPaymentsIdDeleteRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopBillCreditCardPaymentsIdDeleteRequest) Execute() (*QuickbooksDesktopBillCreditCardPaymentsIdDelete200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopBillCreditCardPaymentsIdDeleteExecute(r)
}

/*
QuickbooksDesktopBillCreditCardPaymentsIdDelete Delete a bill credit card payment

Permanently deletes a a bill credit card payment. The deletion will fail if the bill credit card payment is currently in use or has any linked transactions that are in use.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the bill credit card payment to delete.
 @return ApiQuickbooksDesktopBillCreditCardPaymentsIdDeleteRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopBillCreditCardPaymentsIdDelete(ctx context.Context, id string) ApiQuickbooksDesktopBillCreditCardPaymentsIdDeleteRequest {
	return ApiQuickbooksDesktopBillCreditCardPaymentsIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopBillCreditCardPaymentsIdDelete200Response
func (a *DefaultAPIService) QuickbooksDesktopBillCreditCardPaymentsIdDeleteExecute(r ApiQuickbooksDesktopBillCreditCardPaymentsIdDeleteRequest) (*QuickbooksDesktopBillCreditCardPaymentsIdDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopBillCreditCardPaymentsIdDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopBillCreditCardPaymentsIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/bill-credit-card-payments/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopBillCreditCardPaymentsIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopBillCreditCardPaymentsIdGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopBillCreditCardPaymentsIdGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopBillCreditCardPaymentsIdGetRequest) Execute() (*QbdBillCreditCardPayment, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopBillCreditCardPaymentsIdGetExecute(r)
}

/*
QuickbooksDesktopBillCreditCardPaymentsIdGet Retrieve a bill credit card payment

Retrieves a bill credit card payment by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the bill credit card payment to retrieve.
 @return ApiQuickbooksDesktopBillCreditCardPaymentsIdGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopBillCreditCardPaymentsIdGet(ctx context.Context, id string) ApiQuickbooksDesktopBillCreditCardPaymentsIdGetRequest {
	return ApiQuickbooksDesktopBillCreditCardPaymentsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdBillCreditCardPayment
func (a *DefaultAPIService) QuickbooksDesktopBillCreditCardPaymentsIdGetExecute(r ApiQuickbooksDesktopBillCreditCardPaymentsIdGetRequest) (*QbdBillCreditCardPayment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdBillCreditCardPayment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopBillCreditCardPaymentsIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/bill-credit-card-payments/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopBillCreditCardPaymentsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	quickbooksDesktopBillCreditCardPaymentsPostRequest *QuickbooksDesktopBillCreditCardPaymentsPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopBillCreditCardPaymentsPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopBillCreditCardPaymentsPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopBillCreditCardPaymentsPostRequest) QuickbooksDesktopBillCreditCardPaymentsPostRequest(quickbooksDesktopBillCreditCardPaymentsPostRequest QuickbooksDesktopBillCreditCardPaymentsPostRequest) ApiQuickbooksDesktopBillCreditCardPaymentsPostRequest {
	r.quickbooksDesktopBillCreditCardPaymentsPostRequest = &quickbooksDesktopBillCreditCardPaymentsPostRequest
	return r
}

func (r ApiQuickbooksDesktopBillCreditCardPaymentsPostRequest) Execute() (*QbdBillCreditCardPayment, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopBillCreditCardPaymentsPostExecute(r)
}

/*
QuickbooksDesktopBillCreditCardPaymentsPost Create a bill credit card payment

Creates a new bill credit card payment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopBillCreditCardPaymentsPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopBillCreditCardPaymentsPost(ctx context.Context) ApiQuickbooksDesktopBillCreditCardPaymentsPostRequest {
	return ApiQuickbooksDesktopBillCreditCardPaymentsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QbdBillCreditCardPayment
func (a *DefaultAPIService) QuickbooksDesktopBillCreditCardPaymentsPostExecute(r ApiQuickbooksDesktopBillCreditCardPaymentsPostRequest) (*QbdBillCreditCardPayment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdBillCreditCardPayment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopBillCreditCardPaymentsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/bill-credit-card-payments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopBillCreditCardPaymentsPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopBillsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	ids *[]string
	refNumbers *[]string
	limit *int32
	cursor *string
	updatedAfter *string
	updatedBefore *string
	transactionDateFrom *string
	transactionDateTo *string
	vendorIds *[]string
	accountIds *[]string
	refNumberContains *string
	refNumberStartsWith *string
	refNumberEndsWith *string
	refNumberFrom *string
	refNumberTo *string
	currencyIds *[]string
	paymentStatus *string
	includeLineItems *bool
	includeLinkedTransactions *bool
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopBillsGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopBillsGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

// Filter for specific bills by their QuickBooks-assigned unique identifier(s).  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopBillsGetRequest) Ids(ids []string) ApiQuickbooksDesktopBillsGetRequest {
	r.ids = &ids
	return r
}

// Filter for specific bills by their ref-number(s), case-sensitive. In QuickBooks, ref-numbers are not required to be unique and can be arbitrarily changed by the QuickBooks user.  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopBillsGetRequest) RefNumbers(refNumbers []string) ApiQuickbooksDesktopBillsGetRequest {
	r.refNumbers = &refNumbers
	return r
}

// The maximum number of objects to return. Accepts values ranging from 1 to 150, defaults to 150. When used with cursor-based pagination, this parameter controls how many results are returned per page. To paginate through results, combine this with the &#x60;cursor&#x60; parameter. Each response will include a &#x60;nextCursor&#x60; value that can be passed to subsequent requests to retrieve the next page of results.
func (r ApiQuickbooksDesktopBillsGetRequest) Limit(limit int32) ApiQuickbooksDesktopBillsGetRequest {
	r.limit = &limit
	return r
}

// The pagination token to fetch the next set of results when paginating with the &#x60;limit&#x60; parameter. Do not include this parameter on the first call. Use the &#x60;nextCursor&#x60; value returned in the previous response to request subsequent results.
func (r ApiQuickbooksDesktopBillsGetRequest) Cursor(cursor string) ApiQuickbooksDesktopBillsGetRequest {
	r.cursor = &cursor
	return r
}

// Filter for bills updated on or after this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 00:00:00 of that day.
func (r ApiQuickbooksDesktopBillsGetRequest) UpdatedAfter(updatedAfter string) ApiQuickbooksDesktopBillsGetRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Filter for bills updated on or before this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 23:59:59 of that day.
func (r ApiQuickbooksDesktopBillsGetRequest) UpdatedBefore(updatedBefore string) ApiQuickbooksDesktopBillsGetRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Filter for bills whose &#x60;date&#x60; field is on or after this date, in ISO 8601 format (YYYY-MM-DD).
func (r ApiQuickbooksDesktopBillsGetRequest) TransactionDateFrom(transactionDateFrom string) ApiQuickbooksDesktopBillsGetRequest {
	r.transactionDateFrom = &transactionDateFrom
	return r
}

// Filter for bills whose &#x60;date&#x60; field is on or before this date, in ISO 8601 format (YYYY-MM-DD).
func (r ApiQuickbooksDesktopBillsGetRequest) TransactionDateTo(transactionDateTo string) ApiQuickbooksDesktopBillsGetRequest {
	r.transactionDateTo = &transactionDateTo
	return r
}

// Filter for bills received from these vendors.
func (r ApiQuickbooksDesktopBillsGetRequest) VendorIds(vendorIds []string) ApiQuickbooksDesktopBillsGetRequest {
	r.vendorIds = &vendorIds
	return r
}

// Filter for bills associated with these accounts.
func (r ApiQuickbooksDesktopBillsGetRequest) AccountIds(accountIds []string) ApiQuickbooksDesktopBillsGetRequest {
	r.accountIds = &accountIds
	return r
}

// Filter for bills whose &#x60;refNumber&#x60; contains this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberStartsWith&#x60; or &#x60;refNumberEndsWith&#x60;.
func (r ApiQuickbooksDesktopBillsGetRequest) RefNumberContains(refNumberContains string) ApiQuickbooksDesktopBillsGetRequest {
	r.refNumberContains = &refNumberContains
	return r
}

// Filter for bills whose &#x60;refNumber&#x60; starts with this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberContains&#x60; or &#x60;refNumberEndsWith&#x60;.
func (r ApiQuickbooksDesktopBillsGetRequest) RefNumberStartsWith(refNumberStartsWith string) ApiQuickbooksDesktopBillsGetRequest {
	r.refNumberStartsWith = &refNumberStartsWith
	return r
}

// Filter for bills whose &#x60;refNumber&#x60; ends with this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberContains&#x60; or &#x60;refNumberStartsWith&#x60;.
func (r ApiQuickbooksDesktopBillsGetRequest) RefNumberEndsWith(refNumberEndsWith string) ApiQuickbooksDesktopBillsGetRequest {
	r.refNumberEndsWith = &refNumberEndsWith
	return r
}

// Filter for bills whose &#x60;refNumber&#x60; is greater than or equal to this value. If omitted, the range will begin with the first number of the list. Uses a numerical comparison for values that contain only digits; otherwise, uses a lexicographical comparison.
func (r ApiQuickbooksDesktopBillsGetRequest) RefNumberFrom(refNumberFrom string) ApiQuickbooksDesktopBillsGetRequest {
	r.refNumberFrom = &refNumberFrom
	return r
}

// Filter for bills whose &#x60;refNumber&#x60; is less than or equal to this value. If omitted, the range will end with the last number of the list. Uses a numerical comparison for values that contain only digits; otherwise, uses a lexicographical comparison.
func (r ApiQuickbooksDesktopBillsGetRequest) RefNumberTo(refNumberTo string) ApiQuickbooksDesktopBillsGetRequest {
	r.refNumberTo = &refNumberTo
	return r
}

// Filter for bills in these currencies.
func (r ApiQuickbooksDesktopBillsGetRequest) CurrencyIds(currencyIds []string) ApiQuickbooksDesktopBillsGetRequest {
	r.currencyIds = &currencyIds
	return r
}

// Filter for bills that are paid, not paid, or both.
func (r ApiQuickbooksDesktopBillsGetRequest) PaymentStatus(paymentStatus string) ApiQuickbooksDesktopBillsGetRequest {
	r.paymentStatus = &paymentStatus
	return r
}

// Whether to include line items in the response. Defaults to &#x60;true&#x60;.
func (r ApiQuickbooksDesktopBillsGetRequest) IncludeLineItems(includeLineItems bool) ApiQuickbooksDesktopBillsGetRequest {
	r.includeLineItems = &includeLineItems
	return r
}

// Whether to include linked transactions in the response. Defaults to &#x60;false&#x60;. For example, a payment linked to the corresponding bill.
func (r ApiQuickbooksDesktopBillsGetRequest) IncludeLinkedTransactions(includeLinkedTransactions bool) ApiQuickbooksDesktopBillsGetRequest {
	r.includeLinkedTransactions = &includeLinkedTransactions
	return r
}

func (r ApiQuickbooksDesktopBillsGetRequest) Execute() (*QuickbooksDesktopBillsGet200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopBillsGetExecute(r)
}

/*
QuickbooksDesktopBillsGet List all bills

Returns a list of bills. Use the `cursor` parameter to paginate through the results.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopBillsGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopBillsGet(ctx context.Context) ApiQuickbooksDesktopBillsGetRequest {
	return ApiQuickbooksDesktopBillsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopBillsGet200Response
func (a *DefaultAPIService) QuickbooksDesktopBillsGetExecute(r ApiQuickbooksDesktopBillsGetRequest) (*QuickbooksDesktopBillsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopBillsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopBillsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/bills"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.refNumbers != nil {
		t := *r.refNumbers
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "refNumbers", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "refNumbers", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 150
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.transactionDateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDateFrom", r.transactionDateFrom, "form", "")
	}
	if r.transactionDateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDateTo", r.transactionDateTo, "form", "")
	}
	if r.vendorIds != nil {
		t := *r.vendorIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vendorIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vendorIds", t, "form", "multi")
		}
	}
	if r.accountIds != nil {
		t := *r.accountIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountIds", t, "form", "multi")
		}
	}
	if r.refNumberContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberContains", r.refNumberContains, "form", "")
	}
	if r.refNumberStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberStartsWith", r.refNumberStartsWith, "form", "")
	}
	if r.refNumberEndsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberEndsWith", r.refNumberEndsWith, "form", "")
	}
	if r.refNumberFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberFrom", r.refNumberFrom, "form", "")
	}
	if r.refNumberTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberTo", r.refNumberTo, "form", "")
	}
	if r.currencyIds != nil {
		t := *r.currencyIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", t, "form", "multi")
		}
	}
	if r.paymentStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentStatus", r.paymentStatus, "form", "")
	} else {
		var defaultValue string = "all"
		r.paymentStatus = &defaultValue
	}
	if r.includeLineItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLineItems", r.includeLineItems, "form", "")
	} else {
		var defaultValue bool = true
		r.includeLineItems = &defaultValue
	}
	if r.includeLinkedTransactions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLinkedTransactions", r.includeLinkedTransactions, "form", "")
	} else {
		var defaultValue bool = false
		r.includeLinkedTransactions = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopBillsIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopBillsIdDeleteRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopBillsIdDeleteRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopBillsIdDeleteRequest) Execute() (*QuickbooksDesktopBillsIdDelete200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopBillsIdDeleteExecute(r)
}

/*
QuickbooksDesktopBillsIdDelete Delete a bill

Permanently deletes a a bill. The deletion will fail if the bill is currently in use or has any linked transactions that are in use.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the bill to delete.
 @return ApiQuickbooksDesktopBillsIdDeleteRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopBillsIdDelete(ctx context.Context, id string) ApiQuickbooksDesktopBillsIdDeleteRequest {
	return ApiQuickbooksDesktopBillsIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopBillsIdDelete200Response
func (a *DefaultAPIService) QuickbooksDesktopBillsIdDeleteExecute(r ApiQuickbooksDesktopBillsIdDeleteRequest) (*QuickbooksDesktopBillsIdDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopBillsIdDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopBillsIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/bills/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopBillsIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopBillsIdGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopBillsIdGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopBillsIdGetRequest) Execute() (*QbdBill, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopBillsIdGetExecute(r)
}

/*
QuickbooksDesktopBillsIdGet Retrieve a bill

Retrieves a bill by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the bill to retrieve.
 @return ApiQuickbooksDesktopBillsIdGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopBillsIdGet(ctx context.Context, id string) ApiQuickbooksDesktopBillsIdGetRequest {
	return ApiQuickbooksDesktopBillsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdBill
func (a *DefaultAPIService) QuickbooksDesktopBillsIdGetExecute(r ApiQuickbooksDesktopBillsIdGetRequest) (*QbdBill, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdBill
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopBillsIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/bills/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopBillsIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
	quickbooksDesktopBillsIdPostRequest *QuickbooksDesktopBillsIdPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopBillsIdPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopBillsIdPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopBillsIdPostRequest) QuickbooksDesktopBillsIdPostRequest(quickbooksDesktopBillsIdPostRequest QuickbooksDesktopBillsIdPostRequest) ApiQuickbooksDesktopBillsIdPostRequest {
	r.quickbooksDesktopBillsIdPostRequest = &quickbooksDesktopBillsIdPostRequest
	return r
}

func (r ApiQuickbooksDesktopBillsIdPostRequest) Execute() (*QbdBill, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopBillsIdPostExecute(r)
}

/*
QuickbooksDesktopBillsIdPost Update a bill

Updates an existing bill.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the bill to update.
 @return ApiQuickbooksDesktopBillsIdPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopBillsIdPost(ctx context.Context, id string) ApiQuickbooksDesktopBillsIdPostRequest {
	return ApiQuickbooksDesktopBillsIdPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdBill
func (a *DefaultAPIService) QuickbooksDesktopBillsIdPostExecute(r ApiQuickbooksDesktopBillsIdPostRequest) (*QbdBill, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdBill
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopBillsIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/bills/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopBillsIdPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopBillsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	quickbooksDesktopBillsPostRequest *QuickbooksDesktopBillsPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopBillsPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopBillsPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopBillsPostRequest) QuickbooksDesktopBillsPostRequest(quickbooksDesktopBillsPostRequest QuickbooksDesktopBillsPostRequest) ApiQuickbooksDesktopBillsPostRequest {
	r.quickbooksDesktopBillsPostRequest = &quickbooksDesktopBillsPostRequest
	return r
}

func (r ApiQuickbooksDesktopBillsPostRequest) Execute() (*QbdBill, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopBillsPostExecute(r)
}

/*
QuickbooksDesktopBillsPost Create a bill

Creates a new bill.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopBillsPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopBillsPost(ctx context.Context) ApiQuickbooksDesktopBillsPostRequest {
	return ApiQuickbooksDesktopBillsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QbdBill
func (a *DefaultAPIService) QuickbooksDesktopBillsPostExecute(r ApiQuickbooksDesktopBillsPostRequest) (*QbdBill, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdBill
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopBillsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/bills"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopBillsPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopChecksGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	ids *[]string
	refNumbers *[]string
	limit *int32
	cursor *string
	updatedAfter *string
	updatedBefore *string
	transactionDateFrom *string
	transactionDateTo *string
	payeeIds *[]string
	accountIds *[]string
	refNumberContains *string
	refNumberStartsWith *string
	refNumberEndsWith *string
	refNumberFrom *string
	refNumberTo *string
	currencyIds *[]string
	includeLineItems *bool
	includeLinkedTransactions *bool
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopChecksGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopChecksGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

// Filter for specific checks by their QuickBooks-assigned unique identifier(s).  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopChecksGetRequest) Ids(ids []string) ApiQuickbooksDesktopChecksGetRequest {
	r.ids = &ids
	return r
}

// Filter for specific checks by their ref-number(s), case-sensitive. In QuickBooks, ref-numbers are not required to be unique and can be arbitrarily changed by the QuickBooks user.  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopChecksGetRequest) RefNumbers(refNumbers []string) ApiQuickbooksDesktopChecksGetRequest {
	r.refNumbers = &refNumbers
	return r
}

// The maximum number of objects to return. Accepts values ranging from 1 to 150, defaults to 150. When used with cursor-based pagination, this parameter controls how many results are returned per page. To paginate through results, combine this with the &#x60;cursor&#x60; parameter. Each response will include a &#x60;nextCursor&#x60; value that can be passed to subsequent requests to retrieve the next page of results.
func (r ApiQuickbooksDesktopChecksGetRequest) Limit(limit int32) ApiQuickbooksDesktopChecksGetRequest {
	r.limit = &limit
	return r
}

// The pagination token to fetch the next set of results when paginating with the &#x60;limit&#x60; parameter. Do not include this parameter on the first call. Use the &#x60;nextCursor&#x60; value returned in the previous response to request subsequent results.
func (r ApiQuickbooksDesktopChecksGetRequest) Cursor(cursor string) ApiQuickbooksDesktopChecksGetRequest {
	r.cursor = &cursor
	return r
}

// Filter for checks updated on or after this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 00:00:00 of that day.
func (r ApiQuickbooksDesktopChecksGetRequest) UpdatedAfter(updatedAfter string) ApiQuickbooksDesktopChecksGetRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Filter for checks updated on or before this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 23:59:59 of that day.
func (r ApiQuickbooksDesktopChecksGetRequest) UpdatedBefore(updatedBefore string) ApiQuickbooksDesktopChecksGetRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Filter for checks whose &#x60;date&#x60; field is on or after this date, in ISO 8601 format (YYYY-MM-DD).
func (r ApiQuickbooksDesktopChecksGetRequest) TransactionDateFrom(transactionDateFrom string) ApiQuickbooksDesktopChecksGetRequest {
	r.transactionDateFrom = &transactionDateFrom
	return r
}

// Filter for checks whose &#x60;date&#x60; field is on or before this date, in ISO 8601 format (YYYY-MM-DD).
func (r ApiQuickbooksDesktopChecksGetRequest) TransactionDateTo(transactionDateTo string) ApiQuickbooksDesktopChecksGetRequest {
	r.transactionDateTo = &transactionDateTo
	return r
}

// Filter for checks addressed to these payees. These are the people or companies who will receive these checks.
func (r ApiQuickbooksDesktopChecksGetRequest) PayeeIds(payeeIds []string) ApiQuickbooksDesktopChecksGetRequest {
	r.payeeIds = &payeeIds
	return r
}

// Filter for checks associated with these accounts.
func (r ApiQuickbooksDesktopChecksGetRequest) AccountIds(accountIds []string) ApiQuickbooksDesktopChecksGetRequest {
	r.accountIds = &accountIds
	return r
}

// Filter for checks whose &#x60;refNumber&#x60; contains this substring. (For checks, this field is the check number.) NOTE: If you use this parameter, you cannot also use &#x60;refNumberStartsWith&#x60; or &#x60;refNumberEndsWith&#x60;.
func (r ApiQuickbooksDesktopChecksGetRequest) RefNumberContains(refNumberContains string) ApiQuickbooksDesktopChecksGetRequest {
	r.refNumberContains = &refNumberContains
	return r
}

// Filter for checks whose &#x60;refNumber&#x60; starts with this substring. (For checks, this field is the check number.) NOTE: If you use this parameter, you cannot also use &#x60;refNumberContains&#x60; or &#x60;refNumberEndsWith&#x60;.
func (r ApiQuickbooksDesktopChecksGetRequest) RefNumberStartsWith(refNumberStartsWith string) ApiQuickbooksDesktopChecksGetRequest {
	r.refNumberStartsWith = &refNumberStartsWith
	return r
}

// Filter for checks whose &#x60;refNumber&#x60; ends with this substring. (For checks, this field is the check number.) NOTE: If you use this parameter, you cannot also use &#x60;refNumberContains&#x60; or &#x60;refNumberStartsWith&#x60;.
func (r ApiQuickbooksDesktopChecksGetRequest) RefNumberEndsWith(refNumberEndsWith string) ApiQuickbooksDesktopChecksGetRequest {
	r.refNumberEndsWith = &refNumberEndsWith
	return r
}

// Filter for checks whose &#x60;refNumber&#x60; is greater than or equal to this value. (For checks, this field is the check number.) If omitted, the range will begin with the first number of the list. Uses a numerical comparison for values that contain only digits; otherwise, uses a lexicographical comparison.
func (r ApiQuickbooksDesktopChecksGetRequest) RefNumberFrom(refNumberFrom string) ApiQuickbooksDesktopChecksGetRequest {
	r.refNumberFrom = &refNumberFrom
	return r
}

// Filter for checks whose &#x60;refNumber&#x60; is less than or equal to this value. (For checks, this field is the check number.) If omitted, the range will end with the last number of the list. Uses a numerical comparison for values that contain only digits; otherwise, uses a lexicographical comparison.
func (r ApiQuickbooksDesktopChecksGetRequest) RefNumberTo(refNumberTo string) ApiQuickbooksDesktopChecksGetRequest {
	r.refNumberTo = &refNumberTo
	return r
}

// Filter for checks in these currencies.
func (r ApiQuickbooksDesktopChecksGetRequest) CurrencyIds(currencyIds []string) ApiQuickbooksDesktopChecksGetRequest {
	r.currencyIds = &currencyIds
	return r
}

// Whether to include line items in the response. Defaults to &#x60;true&#x60;.
func (r ApiQuickbooksDesktopChecksGetRequest) IncludeLineItems(includeLineItems bool) ApiQuickbooksDesktopChecksGetRequest {
	r.includeLineItems = &includeLineItems
	return r
}

// Whether to include linked transactions in the response. Defaults to &#x60;false&#x60;. For example, a payment linked to the corresponding check.
func (r ApiQuickbooksDesktopChecksGetRequest) IncludeLinkedTransactions(includeLinkedTransactions bool) ApiQuickbooksDesktopChecksGetRequest {
	r.includeLinkedTransactions = &includeLinkedTransactions
	return r
}

func (r ApiQuickbooksDesktopChecksGetRequest) Execute() (*QuickbooksDesktopChecksGet200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopChecksGetExecute(r)
}

/*
QuickbooksDesktopChecksGet List all checks

Returns a list of checks. Use the `cursor` parameter to paginate through the results.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopChecksGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopChecksGet(ctx context.Context) ApiQuickbooksDesktopChecksGetRequest {
	return ApiQuickbooksDesktopChecksGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopChecksGet200Response
func (a *DefaultAPIService) QuickbooksDesktopChecksGetExecute(r ApiQuickbooksDesktopChecksGetRequest) (*QuickbooksDesktopChecksGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopChecksGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopChecksGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/checks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.refNumbers != nil {
		t := *r.refNumbers
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "refNumbers", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "refNumbers", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 150
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.transactionDateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDateFrom", r.transactionDateFrom, "form", "")
	}
	if r.transactionDateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDateTo", r.transactionDateTo, "form", "")
	}
	if r.payeeIds != nil {
		t := *r.payeeIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "payeeIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "payeeIds", t, "form", "multi")
		}
	}
	if r.accountIds != nil {
		t := *r.accountIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountIds", t, "form", "multi")
		}
	}
	if r.refNumberContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberContains", r.refNumberContains, "form", "")
	}
	if r.refNumberStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberStartsWith", r.refNumberStartsWith, "form", "")
	}
	if r.refNumberEndsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberEndsWith", r.refNumberEndsWith, "form", "")
	}
	if r.refNumberFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberFrom", r.refNumberFrom, "form", "")
	}
	if r.refNumberTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberTo", r.refNumberTo, "form", "")
	}
	if r.currencyIds != nil {
		t := *r.currencyIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", t, "form", "multi")
		}
	}
	if r.includeLineItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLineItems", r.includeLineItems, "form", "")
	} else {
		var defaultValue bool = true
		r.includeLineItems = &defaultValue
	}
	if r.includeLinkedTransactions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLinkedTransactions", r.includeLinkedTransactions, "form", "")
	} else {
		var defaultValue bool = false
		r.includeLinkedTransactions = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopChecksIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopChecksIdDeleteRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopChecksIdDeleteRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopChecksIdDeleteRequest) Execute() (*QuickbooksDesktopChecksIdDelete200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopChecksIdDeleteExecute(r)
}

/*
QuickbooksDesktopChecksIdDelete Delete a check

Permanently deletes a a check. The deletion will fail if the check is currently in use or has any linked transactions that are in use.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the check to delete.
 @return ApiQuickbooksDesktopChecksIdDeleteRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopChecksIdDelete(ctx context.Context, id string) ApiQuickbooksDesktopChecksIdDeleteRequest {
	return ApiQuickbooksDesktopChecksIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopChecksIdDelete200Response
func (a *DefaultAPIService) QuickbooksDesktopChecksIdDeleteExecute(r ApiQuickbooksDesktopChecksIdDeleteRequest) (*QuickbooksDesktopChecksIdDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopChecksIdDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopChecksIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/checks/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopChecksIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopChecksIdGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopChecksIdGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopChecksIdGetRequest) Execute() (*QbdCheck, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopChecksIdGetExecute(r)
}

/*
QuickbooksDesktopChecksIdGet Retrieve a check

Retrieves a check by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the check to retrieve.
 @return ApiQuickbooksDesktopChecksIdGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopChecksIdGet(ctx context.Context, id string) ApiQuickbooksDesktopChecksIdGetRequest {
	return ApiQuickbooksDesktopChecksIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdCheck
func (a *DefaultAPIService) QuickbooksDesktopChecksIdGetExecute(r ApiQuickbooksDesktopChecksIdGetRequest) (*QbdCheck, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdCheck
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopChecksIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/checks/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopChecksIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
	quickbooksDesktopChecksIdPostRequest *QuickbooksDesktopChecksIdPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopChecksIdPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopChecksIdPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopChecksIdPostRequest) QuickbooksDesktopChecksIdPostRequest(quickbooksDesktopChecksIdPostRequest QuickbooksDesktopChecksIdPostRequest) ApiQuickbooksDesktopChecksIdPostRequest {
	r.quickbooksDesktopChecksIdPostRequest = &quickbooksDesktopChecksIdPostRequest
	return r
}

func (r ApiQuickbooksDesktopChecksIdPostRequest) Execute() (*QbdCheck, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopChecksIdPostExecute(r)
}

/*
QuickbooksDesktopChecksIdPost Update a check

Updates an existing check.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the check to update.
 @return ApiQuickbooksDesktopChecksIdPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopChecksIdPost(ctx context.Context, id string) ApiQuickbooksDesktopChecksIdPostRequest {
	return ApiQuickbooksDesktopChecksIdPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdCheck
func (a *DefaultAPIService) QuickbooksDesktopChecksIdPostExecute(r ApiQuickbooksDesktopChecksIdPostRequest) (*QbdCheck, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdCheck
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopChecksIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/checks/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopChecksIdPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopChecksPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	quickbooksDesktopChecksPostRequest *QuickbooksDesktopChecksPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopChecksPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopChecksPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopChecksPostRequest) QuickbooksDesktopChecksPostRequest(quickbooksDesktopChecksPostRequest QuickbooksDesktopChecksPostRequest) ApiQuickbooksDesktopChecksPostRequest {
	r.quickbooksDesktopChecksPostRequest = &quickbooksDesktopChecksPostRequest
	return r
}

func (r ApiQuickbooksDesktopChecksPostRequest) Execute() (*QbdCheck, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopChecksPostExecute(r)
}

/*
QuickbooksDesktopChecksPost Create a check

Creates a new check.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopChecksPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopChecksPost(ctx context.Context) ApiQuickbooksDesktopChecksPostRequest {
	return ApiQuickbooksDesktopChecksPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QbdCheck
func (a *DefaultAPIService) QuickbooksDesktopChecksPostExecute(r ApiQuickbooksDesktopChecksPostRequest) (*QbdCheck, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdCheck
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopChecksPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/checks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopChecksPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopClassesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	ids *[]string
	fullNames *[]string
	limit *int32
	status *string
	updatedAfter *string
	updatedBefore *string
	nameContains *string
	nameStartsWith *string
	nameEndsWith *string
	nameFrom *string
	nameTo *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopClassesGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopClassesGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

// Filter for specific classes by their QuickBooks-assigned unique identifier(s).  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopClassesGetRequest) Ids(ids []string) ApiQuickbooksDesktopClassesGetRequest {
	r.ids = &ids
	return r
}

// Filter for specific classes by their full-name(s), case-insensitive. Like &#x60;id&#x60;, &#x60;fullName&#x60; is a unique identifier for a class, formed by by combining the names of its parent objects with its own &#x60;name&#x60;, separated by colons. For example, if a class is under \&quot;Department\&quot; and has the &#x60;name&#x60; \&quot;Marketing\&quot;, its &#x60;fullName&#x60; would be \&quot;Department:Marketing\&quot;.  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopClassesGetRequest) FullNames(fullNames []string) ApiQuickbooksDesktopClassesGetRequest {
	r.fullNames = &fullNames
	return r
}

// The maximum number of objects to return.  **IMPORTANT**: QuickBooks Desktop does not support cursor-based pagination for classes. This parameter will limit the response size, but you cannot fetch subsequent results using a cursor. For pagination, use the name-range parameters instead (e.g., &#x60;nameFrom&#x3D;A&amp;nameTo&#x3D;B&#x60;).  When this parameter is omitted, the endpoint returns all classes without limit, unlike paginated endpoints which default to 150 records. This is acceptable because classes typically have low record counts.
func (r ApiQuickbooksDesktopClassesGetRequest) Limit(limit int32) ApiQuickbooksDesktopClassesGetRequest {
	r.limit = &limit
	return r
}

// Filter for classes that are active, inactive, or both.
func (r ApiQuickbooksDesktopClassesGetRequest) Status(status string) ApiQuickbooksDesktopClassesGetRequest {
	r.status = &status
	return r
}

// Filter for classes updated on or after this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 00:00:00 of that day.
func (r ApiQuickbooksDesktopClassesGetRequest) UpdatedAfter(updatedAfter string) ApiQuickbooksDesktopClassesGetRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Filter for classes updated on or before this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 23:59:59 of that day.
func (r ApiQuickbooksDesktopClassesGetRequest) UpdatedBefore(updatedBefore string) ApiQuickbooksDesktopClassesGetRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Filter for classes whose &#x60;name&#x60; contains this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameStartsWith&#x60; or &#x60;nameEndsWith&#x60;.
func (r ApiQuickbooksDesktopClassesGetRequest) NameContains(nameContains string) ApiQuickbooksDesktopClassesGetRequest {
	r.nameContains = &nameContains
	return r
}

// Filter for classes whose &#x60;name&#x60; starts with this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameContains&#x60; or &#x60;nameEndsWith&#x60;.
func (r ApiQuickbooksDesktopClassesGetRequest) NameStartsWith(nameStartsWith string) ApiQuickbooksDesktopClassesGetRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Filter for classes whose &#x60;name&#x60; ends with this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameContains&#x60; or &#x60;nameStartsWith&#x60;.
func (r ApiQuickbooksDesktopClassesGetRequest) NameEndsWith(nameEndsWith string) ApiQuickbooksDesktopClassesGetRequest {
	r.nameEndsWith = &nameEndsWith
	return r
}

// Filter for classes whose &#x60;name&#x60; is alphabetically greater than or equal to this value.
func (r ApiQuickbooksDesktopClassesGetRequest) NameFrom(nameFrom string) ApiQuickbooksDesktopClassesGetRequest {
	r.nameFrom = &nameFrom
	return r
}

// Filter for classes whose &#x60;name&#x60; is alphabetically less than or equal to this value.
func (r ApiQuickbooksDesktopClassesGetRequest) NameTo(nameTo string) ApiQuickbooksDesktopClassesGetRequest {
	r.nameTo = &nameTo
	return r
}

func (r ApiQuickbooksDesktopClassesGetRequest) Execute() (*QuickbooksDesktopClassesGet200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopClassesGetExecute(r)
}

/*
QuickbooksDesktopClassesGet List all classes

Returns a list of classes. NOTE: QuickBooks Desktop does not support pagination for classes; hence, there is no `cursor` parameter. Users typically have few classes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopClassesGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopClassesGet(ctx context.Context) ApiQuickbooksDesktopClassesGetRequest {
	return ApiQuickbooksDesktopClassesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopClassesGet200Response
func (a *DefaultAPIService) QuickbooksDesktopClassesGetExecute(r ApiQuickbooksDesktopClassesGetRequest) (*QuickbooksDesktopClassesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopClassesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopClassesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/classes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.fullNames != nil {
		t := *r.fullNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fullNames", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fullNames", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	} else {
		var defaultValue string = "active"
		r.status = &defaultValue
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.nameContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameContains", r.nameContains, "form", "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameStartsWith", r.nameStartsWith, "form", "")
	}
	if r.nameEndsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameEndsWith", r.nameEndsWith, "form", "")
	}
	if r.nameFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameFrom", r.nameFrom, "form", "")
	}
	if r.nameTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameTo", r.nameTo, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopClassesIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopClassesIdGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopClassesIdGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopClassesIdGetRequest) Execute() (*QbdClass, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopClassesIdGetExecute(r)
}

/*
QuickbooksDesktopClassesIdGet Retrieve a class

Retrieves a class by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the class to retrieve.
 @return ApiQuickbooksDesktopClassesIdGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopClassesIdGet(ctx context.Context, id string) ApiQuickbooksDesktopClassesIdGetRequest {
	return ApiQuickbooksDesktopClassesIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdClass
func (a *DefaultAPIService) QuickbooksDesktopClassesIdGetExecute(r ApiQuickbooksDesktopClassesIdGetRequest) (*QbdClass, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdClass
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopClassesIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/classes/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopClassesIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
	quickbooksDesktopClassesIdPostRequest *QuickbooksDesktopClassesIdPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopClassesIdPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopClassesIdPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopClassesIdPostRequest) QuickbooksDesktopClassesIdPostRequest(quickbooksDesktopClassesIdPostRequest QuickbooksDesktopClassesIdPostRequest) ApiQuickbooksDesktopClassesIdPostRequest {
	r.quickbooksDesktopClassesIdPostRequest = &quickbooksDesktopClassesIdPostRequest
	return r
}

func (r ApiQuickbooksDesktopClassesIdPostRequest) Execute() (*QbdClass, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopClassesIdPostExecute(r)
}

/*
QuickbooksDesktopClassesIdPost Update a class

Updates an existing class.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the class to update.
 @return ApiQuickbooksDesktopClassesIdPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopClassesIdPost(ctx context.Context, id string) ApiQuickbooksDesktopClassesIdPostRequest {
	return ApiQuickbooksDesktopClassesIdPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdClass
func (a *DefaultAPIService) QuickbooksDesktopClassesIdPostExecute(r ApiQuickbooksDesktopClassesIdPostRequest) (*QbdClass, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdClass
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopClassesIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/classes/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopClassesIdPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopClassesPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	quickbooksDesktopClassesPostRequest *QuickbooksDesktopClassesPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopClassesPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopClassesPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopClassesPostRequest) QuickbooksDesktopClassesPostRequest(quickbooksDesktopClassesPostRequest QuickbooksDesktopClassesPostRequest) ApiQuickbooksDesktopClassesPostRequest {
	r.quickbooksDesktopClassesPostRequest = &quickbooksDesktopClassesPostRequest
	return r
}

func (r ApiQuickbooksDesktopClassesPostRequest) Execute() (*QbdClass, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopClassesPostExecute(r)
}

/*
QuickbooksDesktopClassesPost Create a class

Creates a new class.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopClassesPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopClassesPost(ctx context.Context) ApiQuickbooksDesktopClassesPostRequest {
	return ApiQuickbooksDesktopClassesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QbdClass
func (a *DefaultAPIService) QuickbooksDesktopClassesPostExecute(r ApiQuickbooksDesktopClassesPostRequest) (*QbdClass, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdClass
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopClassesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/classes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopClassesPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopCompanyGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopCompanyGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopCompanyGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopCompanyGetRequest) Execute() (*QbdCompany, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopCompanyGetExecute(r)
}

/*
QuickbooksDesktopCompanyGet Retrieve company file info

Returns detailed information about the connected QuickBooks company file, including company address, legal name, preferences, and subscribed services. Note that company information cannot be modified through the API, only through the QuickBooks Desktop user interface.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopCompanyGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopCompanyGet(ctx context.Context) ApiQuickbooksDesktopCompanyGetRequest {
	return ApiQuickbooksDesktopCompanyGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QbdCompany
func (a *DefaultAPIService) QuickbooksDesktopCompanyGetExecute(r ApiQuickbooksDesktopCompanyGetRequest) (*QbdCompany, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdCompany
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopCompanyGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/company"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopCreditCardChargesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	ids *[]string
	refNumbers *[]string
	limit *int32
	cursor *string
	updatedAfter *string
	updatedBefore *string
	transactionDateFrom *string
	transactionDateTo *string
	payeeIds *[]string
	accountIds *[]string
	refNumberContains *string
	refNumberStartsWith *string
	refNumberEndsWith *string
	refNumberFrom *string
	refNumberTo *string
	currencyIds *[]string
	includeLineItems *bool
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopCreditCardChargesGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopCreditCardChargesGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

// Filter for specific credit card charges by their QuickBooks-assigned unique identifier(s).  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopCreditCardChargesGetRequest) Ids(ids []string) ApiQuickbooksDesktopCreditCardChargesGetRequest {
	r.ids = &ids
	return r
}

// Filter for specific credit card charges by their ref-number(s), case-sensitive. In QuickBooks, ref-numbers are not required to be unique and can be arbitrarily changed by the QuickBooks user.  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopCreditCardChargesGetRequest) RefNumbers(refNumbers []string) ApiQuickbooksDesktopCreditCardChargesGetRequest {
	r.refNumbers = &refNumbers
	return r
}

// The maximum number of objects to return. Accepts values ranging from 1 to 150, defaults to 150. When used with cursor-based pagination, this parameter controls how many results are returned per page. To paginate through results, combine this with the &#x60;cursor&#x60; parameter. Each response will include a &#x60;nextCursor&#x60; value that can be passed to subsequent requests to retrieve the next page of results.
func (r ApiQuickbooksDesktopCreditCardChargesGetRequest) Limit(limit int32) ApiQuickbooksDesktopCreditCardChargesGetRequest {
	r.limit = &limit
	return r
}

// The pagination token to fetch the next set of results when paginating with the &#x60;limit&#x60; parameter. Do not include this parameter on the first call. Use the &#x60;nextCursor&#x60; value returned in the previous response to request subsequent results.
func (r ApiQuickbooksDesktopCreditCardChargesGetRequest) Cursor(cursor string) ApiQuickbooksDesktopCreditCardChargesGetRequest {
	r.cursor = &cursor
	return r
}

// Filter for credit card charges updated on or after this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 00:00:00 of that day.
func (r ApiQuickbooksDesktopCreditCardChargesGetRequest) UpdatedAfter(updatedAfter string) ApiQuickbooksDesktopCreditCardChargesGetRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Filter for credit card charges updated on or before this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 23:59:59 of that day.
func (r ApiQuickbooksDesktopCreditCardChargesGetRequest) UpdatedBefore(updatedBefore string) ApiQuickbooksDesktopCreditCardChargesGetRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Filter for credit card charges whose &#x60;date&#x60; field is on or after this date, in ISO 8601 format (YYYY-MM-DD).
func (r ApiQuickbooksDesktopCreditCardChargesGetRequest) TransactionDateFrom(transactionDateFrom string) ApiQuickbooksDesktopCreditCardChargesGetRequest {
	r.transactionDateFrom = &transactionDateFrom
	return r
}

// Filter for credit card charges whose &#x60;date&#x60; field is on or before this date, in ISO 8601 format (YYYY-MM-DD).
func (r ApiQuickbooksDesktopCreditCardChargesGetRequest) TransactionDateTo(transactionDateTo string) ApiQuickbooksDesktopCreditCardChargesGetRequest {
	r.transactionDateTo = &transactionDateTo
	return r
}

// Filter for credit card charges paid to these payees. These are the vendors or companies from whom merchandise or services were purchased for these credit card charges.
func (r ApiQuickbooksDesktopCreditCardChargesGetRequest) PayeeIds(payeeIds []string) ApiQuickbooksDesktopCreditCardChargesGetRequest {
	r.payeeIds = &payeeIds
	return r
}

// Filter for credit card charges associated with these accounts.
func (r ApiQuickbooksDesktopCreditCardChargesGetRequest) AccountIds(accountIds []string) ApiQuickbooksDesktopCreditCardChargesGetRequest {
	r.accountIds = &accountIds
	return r
}

// Filter for credit card charges whose &#x60;refNumber&#x60; contains this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberStartsWith&#x60; or &#x60;refNumberEndsWith&#x60;.
func (r ApiQuickbooksDesktopCreditCardChargesGetRequest) RefNumberContains(refNumberContains string) ApiQuickbooksDesktopCreditCardChargesGetRequest {
	r.refNumberContains = &refNumberContains
	return r
}

// Filter for credit card charges whose &#x60;refNumber&#x60; starts with this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberContains&#x60; or &#x60;refNumberEndsWith&#x60;.
func (r ApiQuickbooksDesktopCreditCardChargesGetRequest) RefNumberStartsWith(refNumberStartsWith string) ApiQuickbooksDesktopCreditCardChargesGetRequest {
	r.refNumberStartsWith = &refNumberStartsWith
	return r
}

// Filter for credit card charges whose &#x60;refNumber&#x60; ends with this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberContains&#x60; or &#x60;refNumberStartsWith&#x60;.
func (r ApiQuickbooksDesktopCreditCardChargesGetRequest) RefNumberEndsWith(refNumberEndsWith string) ApiQuickbooksDesktopCreditCardChargesGetRequest {
	r.refNumberEndsWith = &refNumberEndsWith
	return r
}

// Filter for credit card charges whose &#x60;refNumber&#x60; is greater than or equal to this value. If omitted, the range will begin with the first number of the list. Uses a numerical comparison for values that contain only digits; otherwise, uses a lexicographical comparison.
func (r ApiQuickbooksDesktopCreditCardChargesGetRequest) RefNumberFrom(refNumberFrom string) ApiQuickbooksDesktopCreditCardChargesGetRequest {
	r.refNumberFrom = &refNumberFrom
	return r
}

// Filter for credit card charges whose &#x60;refNumber&#x60; is less than or equal to this value. If omitted, the range will end with the last number of the list. Uses a numerical comparison for values that contain only digits; otherwise, uses a lexicographical comparison.
func (r ApiQuickbooksDesktopCreditCardChargesGetRequest) RefNumberTo(refNumberTo string) ApiQuickbooksDesktopCreditCardChargesGetRequest {
	r.refNumberTo = &refNumberTo
	return r
}

// Filter for credit card charges in these currencies.
func (r ApiQuickbooksDesktopCreditCardChargesGetRequest) CurrencyIds(currencyIds []string) ApiQuickbooksDesktopCreditCardChargesGetRequest {
	r.currencyIds = &currencyIds
	return r
}

// Whether to include line items in the response. Defaults to &#x60;true&#x60;.
func (r ApiQuickbooksDesktopCreditCardChargesGetRequest) IncludeLineItems(includeLineItems bool) ApiQuickbooksDesktopCreditCardChargesGetRequest {
	r.includeLineItems = &includeLineItems
	return r
}

func (r ApiQuickbooksDesktopCreditCardChargesGetRequest) Execute() (*QuickbooksDesktopCreditCardChargesGet200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopCreditCardChargesGetExecute(r)
}

/*
QuickbooksDesktopCreditCardChargesGet List all credit card charges

Returns a list of credit card charges. Use the `cursor` parameter to paginate through the results.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopCreditCardChargesGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopCreditCardChargesGet(ctx context.Context) ApiQuickbooksDesktopCreditCardChargesGetRequest {
	return ApiQuickbooksDesktopCreditCardChargesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopCreditCardChargesGet200Response
func (a *DefaultAPIService) QuickbooksDesktopCreditCardChargesGetExecute(r ApiQuickbooksDesktopCreditCardChargesGetRequest) (*QuickbooksDesktopCreditCardChargesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopCreditCardChargesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopCreditCardChargesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/credit-card-charges"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.refNumbers != nil {
		t := *r.refNumbers
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "refNumbers", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "refNumbers", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 150
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.transactionDateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDateFrom", r.transactionDateFrom, "form", "")
	}
	if r.transactionDateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDateTo", r.transactionDateTo, "form", "")
	}
	if r.payeeIds != nil {
		t := *r.payeeIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "payeeIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "payeeIds", t, "form", "multi")
		}
	}
	if r.accountIds != nil {
		t := *r.accountIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountIds", t, "form", "multi")
		}
	}
	if r.refNumberContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberContains", r.refNumberContains, "form", "")
	}
	if r.refNumberStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberStartsWith", r.refNumberStartsWith, "form", "")
	}
	if r.refNumberEndsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberEndsWith", r.refNumberEndsWith, "form", "")
	}
	if r.refNumberFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberFrom", r.refNumberFrom, "form", "")
	}
	if r.refNumberTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberTo", r.refNumberTo, "form", "")
	}
	if r.currencyIds != nil {
		t := *r.currencyIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", t, "form", "multi")
		}
	}
	if r.includeLineItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLineItems", r.includeLineItems, "form", "")
	} else {
		var defaultValue bool = true
		r.includeLineItems = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopCreditCardChargesIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopCreditCardChargesIdDeleteRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopCreditCardChargesIdDeleteRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopCreditCardChargesIdDeleteRequest) Execute() (*QuickbooksDesktopCreditCardChargesIdDelete200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopCreditCardChargesIdDeleteExecute(r)
}

/*
QuickbooksDesktopCreditCardChargesIdDelete Delete a credit card charge

Permanently deletes a a credit card charge. The deletion will fail if the credit card charge is currently in use or has any linked transactions that are in use.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the credit card charge to delete.
 @return ApiQuickbooksDesktopCreditCardChargesIdDeleteRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopCreditCardChargesIdDelete(ctx context.Context, id string) ApiQuickbooksDesktopCreditCardChargesIdDeleteRequest {
	return ApiQuickbooksDesktopCreditCardChargesIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopCreditCardChargesIdDelete200Response
func (a *DefaultAPIService) QuickbooksDesktopCreditCardChargesIdDeleteExecute(r ApiQuickbooksDesktopCreditCardChargesIdDeleteRequest) (*QuickbooksDesktopCreditCardChargesIdDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopCreditCardChargesIdDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopCreditCardChargesIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/credit-card-charges/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopCreditCardChargesIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopCreditCardChargesIdGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopCreditCardChargesIdGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopCreditCardChargesIdGetRequest) Execute() (*QbdCreditCardCharge, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopCreditCardChargesIdGetExecute(r)
}

/*
QuickbooksDesktopCreditCardChargesIdGet Retrieve a credit card charge

Retrieves a credit card charge by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the credit card charge to retrieve.
 @return ApiQuickbooksDesktopCreditCardChargesIdGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopCreditCardChargesIdGet(ctx context.Context, id string) ApiQuickbooksDesktopCreditCardChargesIdGetRequest {
	return ApiQuickbooksDesktopCreditCardChargesIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdCreditCardCharge
func (a *DefaultAPIService) QuickbooksDesktopCreditCardChargesIdGetExecute(r ApiQuickbooksDesktopCreditCardChargesIdGetRequest) (*QbdCreditCardCharge, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdCreditCardCharge
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopCreditCardChargesIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/credit-card-charges/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopCreditCardChargesIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
	quickbooksDesktopCreditCardChargesIdPostRequest *QuickbooksDesktopCreditCardChargesIdPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopCreditCardChargesIdPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopCreditCardChargesIdPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopCreditCardChargesIdPostRequest) QuickbooksDesktopCreditCardChargesIdPostRequest(quickbooksDesktopCreditCardChargesIdPostRequest QuickbooksDesktopCreditCardChargesIdPostRequest) ApiQuickbooksDesktopCreditCardChargesIdPostRequest {
	r.quickbooksDesktopCreditCardChargesIdPostRequest = &quickbooksDesktopCreditCardChargesIdPostRequest
	return r
}

func (r ApiQuickbooksDesktopCreditCardChargesIdPostRequest) Execute() (*QbdCreditCardCharge, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopCreditCardChargesIdPostExecute(r)
}

/*
QuickbooksDesktopCreditCardChargesIdPost Update a credit card charge

Updates an existing credit card charge.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the credit card charge to update.
 @return ApiQuickbooksDesktopCreditCardChargesIdPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopCreditCardChargesIdPost(ctx context.Context, id string) ApiQuickbooksDesktopCreditCardChargesIdPostRequest {
	return ApiQuickbooksDesktopCreditCardChargesIdPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdCreditCardCharge
func (a *DefaultAPIService) QuickbooksDesktopCreditCardChargesIdPostExecute(r ApiQuickbooksDesktopCreditCardChargesIdPostRequest) (*QbdCreditCardCharge, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdCreditCardCharge
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopCreditCardChargesIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/credit-card-charges/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopCreditCardChargesIdPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopCreditCardChargesPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	quickbooksDesktopCreditCardChargesPostRequest *QuickbooksDesktopCreditCardChargesPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopCreditCardChargesPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopCreditCardChargesPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopCreditCardChargesPostRequest) QuickbooksDesktopCreditCardChargesPostRequest(quickbooksDesktopCreditCardChargesPostRequest QuickbooksDesktopCreditCardChargesPostRequest) ApiQuickbooksDesktopCreditCardChargesPostRequest {
	r.quickbooksDesktopCreditCardChargesPostRequest = &quickbooksDesktopCreditCardChargesPostRequest
	return r
}

func (r ApiQuickbooksDesktopCreditCardChargesPostRequest) Execute() (*QbdCreditCardCharge, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopCreditCardChargesPostExecute(r)
}

/*
QuickbooksDesktopCreditCardChargesPost Create a credit card charge

Creates a new credit card charge for the specified account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopCreditCardChargesPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopCreditCardChargesPost(ctx context.Context) ApiQuickbooksDesktopCreditCardChargesPostRequest {
	return ApiQuickbooksDesktopCreditCardChargesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QbdCreditCardCharge
func (a *DefaultAPIService) QuickbooksDesktopCreditCardChargesPostExecute(r ApiQuickbooksDesktopCreditCardChargesPostRequest) (*QbdCreditCardCharge, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdCreditCardCharge
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopCreditCardChargesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/credit-card-charges"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopCreditCardChargesPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopCreditCardCreditsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	ids *[]string
	refNumbers *[]string
	limit *int32
	cursor *string
	updatedAfter *string
	updatedBefore *string
	transactionDateFrom *string
	transactionDateTo *string
	payeeIds *[]string
	accountIds *[]string
	refNumberContains *string
	refNumberStartsWith *string
	refNumberEndsWith *string
	refNumberFrom *string
	refNumberTo *string
	currencyIds *[]string
	includeLineItems *bool
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopCreditCardCreditsGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopCreditCardCreditsGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

// Filter for specific credit card credits by their QuickBooks-assigned unique identifier(s).  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopCreditCardCreditsGetRequest) Ids(ids []string) ApiQuickbooksDesktopCreditCardCreditsGetRequest {
	r.ids = &ids
	return r
}

// Filter for specific credit card credits by their ref-number(s), case-sensitive. In QuickBooks, ref-numbers are not required to be unique and can be arbitrarily changed by the QuickBooks user.  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopCreditCardCreditsGetRequest) RefNumbers(refNumbers []string) ApiQuickbooksDesktopCreditCardCreditsGetRequest {
	r.refNumbers = &refNumbers
	return r
}

// The maximum number of objects to return. Accepts values ranging from 1 to 150, defaults to 150. When used with cursor-based pagination, this parameter controls how many results are returned per page. To paginate through results, combine this with the &#x60;cursor&#x60; parameter. Each response will include a &#x60;nextCursor&#x60; value that can be passed to subsequent requests to retrieve the next page of results.
func (r ApiQuickbooksDesktopCreditCardCreditsGetRequest) Limit(limit int32) ApiQuickbooksDesktopCreditCardCreditsGetRequest {
	r.limit = &limit
	return r
}

// The pagination token to fetch the next set of results when paginating with the &#x60;limit&#x60; parameter. Do not include this parameter on the first call. Use the &#x60;nextCursor&#x60; value returned in the previous response to request subsequent results.
func (r ApiQuickbooksDesktopCreditCardCreditsGetRequest) Cursor(cursor string) ApiQuickbooksDesktopCreditCardCreditsGetRequest {
	r.cursor = &cursor
	return r
}

// Filter for credit card credits updated on or after this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 00:00:00 of that day.
func (r ApiQuickbooksDesktopCreditCardCreditsGetRequest) UpdatedAfter(updatedAfter string) ApiQuickbooksDesktopCreditCardCreditsGetRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Filter for credit card credits updated on or before this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 23:59:59 of that day.
func (r ApiQuickbooksDesktopCreditCardCreditsGetRequest) UpdatedBefore(updatedBefore string) ApiQuickbooksDesktopCreditCardCreditsGetRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Filter for credit card credits whose &#x60;date&#x60; field is on or after this date, in ISO 8601 format (YYYY-MM-DD).
func (r ApiQuickbooksDesktopCreditCardCreditsGetRequest) TransactionDateFrom(transactionDateFrom string) ApiQuickbooksDesktopCreditCardCreditsGetRequest {
	r.transactionDateFrom = &transactionDateFrom
	return r
}

// Filter for credit card credits whose &#x60;date&#x60; field is on or before this date, in ISO 8601 format (YYYY-MM-DD).
func (r ApiQuickbooksDesktopCreditCardCreditsGetRequest) TransactionDateTo(transactionDateTo string) ApiQuickbooksDesktopCreditCardCreditsGetRequest {
	r.transactionDateTo = &transactionDateTo
	return r
}

// Filter for credit card credits received from these payees. These are the vendors or companies from whom these credit card credits were received.
func (r ApiQuickbooksDesktopCreditCardCreditsGetRequest) PayeeIds(payeeIds []string) ApiQuickbooksDesktopCreditCardCreditsGetRequest {
	r.payeeIds = &payeeIds
	return r
}

// Filter for credit card credits associated with these accounts.
func (r ApiQuickbooksDesktopCreditCardCreditsGetRequest) AccountIds(accountIds []string) ApiQuickbooksDesktopCreditCardCreditsGetRequest {
	r.accountIds = &accountIds
	return r
}

// Filter for credit card credits whose &#x60;refNumber&#x60; contains this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberStartsWith&#x60; or &#x60;refNumberEndsWith&#x60;.
func (r ApiQuickbooksDesktopCreditCardCreditsGetRequest) RefNumberContains(refNumberContains string) ApiQuickbooksDesktopCreditCardCreditsGetRequest {
	r.refNumberContains = &refNumberContains
	return r
}

// Filter for credit card credits whose &#x60;refNumber&#x60; starts with this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberContains&#x60; or &#x60;refNumberEndsWith&#x60;.
func (r ApiQuickbooksDesktopCreditCardCreditsGetRequest) RefNumberStartsWith(refNumberStartsWith string) ApiQuickbooksDesktopCreditCardCreditsGetRequest {
	r.refNumberStartsWith = &refNumberStartsWith
	return r
}

// Filter for credit card credits whose &#x60;refNumber&#x60; ends with this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberContains&#x60; or &#x60;refNumberStartsWith&#x60;.
func (r ApiQuickbooksDesktopCreditCardCreditsGetRequest) RefNumberEndsWith(refNumberEndsWith string) ApiQuickbooksDesktopCreditCardCreditsGetRequest {
	r.refNumberEndsWith = &refNumberEndsWith
	return r
}

// Filter for credit card credits whose &#x60;refNumber&#x60; is greater than or equal to this value. If omitted, the range will begin with the first number of the list. Uses a numerical comparison for values that contain only digits; otherwise, uses a lexicographical comparison.
func (r ApiQuickbooksDesktopCreditCardCreditsGetRequest) RefNumberFrom(refNumberFrom string) ApiQuickbooksDesktopCreditCardCreditsGetRequest {
	r.refNumberFrom = &refNumberFrom
	return r
}

// Filter for credit card credits whose &#x60;refNumber&#x60; is less than or equal to this value. If omitted, the range will end with the last number of the list. Uses a numerical comparison for values that contain only digits; otherwise, uses a lexicographical comparison.
func (r ApiQuickbooksDesktopCreditCardCreditsGetRequest) RefNumberTo(refNumberTo string) ApiQuickbooksDesktopCreditCardCreditsGetRequest {
	r.refNumberTo = &refNumberTo
	return r
}

// Filter for credit card credits in these currencies.
func (r ApiQuickbooksDesktopCreditCardCreditsGetRequest) CurrencyIds(currencyIds []string) ApiQuickbooksDesktopCreditCardCreditsGetRequest {
	r.currencyIds = &currencyIds
	return r
}

// Whether to include line items in the response. Defaults to &#x60;true&#x60;.
func (r ApiQuickbooksDesktopCreditCardCreditsGetRequest) IncludeLineItems(includeLineItems bool) ApiQuickbooksDesktopCreditCardCreditsGetRequest {
	r.includeLineItems = &includeLineItems
	return r
}

func (r ApiQuickbooksDesktopCreditCardCreditsGetRequest) Execute() (*QuickbooksDesktopCreditCardCreditsGet200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopCreditCardCreditsGetExecute(r)
}

/*
QuickbooksDesktopCreditCardCreditsGet List all credit card credits

Returns a list of credit card credits. Use the `cursor` parameter to paginate through the results.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopCreditCardCreditsGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopCreditCardCreditsGet(ctx context.Context) ApiQuickbooksDesktopCreditCardCreditsGetRequest {
	return ApiQuickbooksDesktopCreditCardCreditsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopCreditCardCreditsGet200Response
func (a *DefaultAPIService) QuickbooksDesktopCreditCardCreditsGetExecute(r ApiQuickbooksDesktopCreditCardCreditsGetRequest) (*QuickbooksDesktopCreditCardCreditsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopCreditCardCreditsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopCreditCardCreditsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/credit-card-credits"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.refNumbers != nil {
		t := *r.refNumbers
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "refNumbers", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "refNumbers", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 150
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.transactionDateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDateFrom", r.transactionDateFrom, "form", "")
	}
	if r.transactionDateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDateTo", r.transactionDateTo, "form", "")
	}
	if r.payeeIds != nil {
		t := *r.payeeIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "payeeIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "payeeIds", t, "form", "multi")
		}
	}
	if r.accountIds != nil {
		t := *r.accountIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountIds", t, "form", "multi")
		}
	}
	if r.refNumberContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberContains", r.refNumberContains, "form", "")
	}
	if r.refNumberStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberStartsWith", r.refNumberStartsWith, "form", "")
	}
	if r.refNumberEndsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberEndsWith", r.refNumberEndsWith, "form", "")
	}
	if r.refNumberFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberFrom", r.refNumberFrom, "form", "")
	}
	if r.refNumberTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberTo", r.refNumberTo, "form", "")
	}
	if r.currencyIds != nil {
		t := *r.currencyIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", t, "form", "multi")
		}
	}
	if r.includeLineItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLineItems", r.includeLineItems, "form", "")
	} else {
		var defaultValue bool = true
		r.includeLineItems = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopCreditCardCreditsIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopCreditCardCreditsIdDeleteRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopCreditCardCreditsIdDeleteRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopCreditCardCreditsIdDeleteRequest) Execute() (*QuickbooksDesktopCreditCardCreditsIdDelete200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopCreditCardCreditsIdDeleteExecute(r)
}

/*
QuickbooksDesktopCreditCardCreditsIdDelete Delete a credit card credit

Permanently deletes a a credit card credit. The deletion will fail if the credit card credit is currently in use or has any linked transactions that are in use.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the credit card credit to delete.
 @return ApiQuickbooksDesktopCreditCardCreditsIdDeleteRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopCreditCardCreditsIdDelete(ctx context.Context, id string) ApiQuickbooksDesktopCreditCardCreditsIdDeleteRequest {
	return ApiQuickbooksDesktopCreditCardCreditsIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopCreditCardCreditsIdDelete200Response
func (a *DefaultAPIService) QuickbooksDesktopCreditCardCreditsIdDeleteExecute(r ApiQuickbooksDesktopCreditCardCreditsIdDeleteRequest) (*QuickbooksDesktopCreditCardCreditsIdDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopCreditCardCreditsIdDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopCreditCardCreditsIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/credit-card-credits/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopCreditCardCreditsIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopCreditCardCreditsIdGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopCreditCardCreditsIdGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopCreditCardCreditsIdGetRequest) Execute() (*QbdCreditCardCredit, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopCreditCardCreditsIdGetExecute(r)
}

/*
QuickbooksDesktopCreditCardCreditsIdGet Retrieve a credit card credit

Retrieves a credit card credit by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the credit card credit to retrieve.
 @return ApiQuickbooksDesktopCreditCardCreditsIdGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopCreditCardCreditsIdGet(ctx context.Context, id string) ApiQuickbooksDesktopCreditCardCreditsIdGetRequest {
	return ApiQuickbooksDesktopCreditCardCreditsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdCreditCardCredit
func (a *DefaultAPIService) QuickbooksDesktopCreditCardCreditsIdGetExecute(r ApiQuickbooksDesktopCreditCardCreditsIdGetRequest) (*QbdCreditCardCredit, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdCreditCardCredit
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopCreditCardCreditsIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/credit-card-credits/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopCreditCardCreditsIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
	quickbooksDesktopCreditCardCreditsIdPostRequest *QuickbooksDesktopCreditCardCreditsIdPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopCreditCardCreditsIdPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopCreditCardCreditsIdPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopCreditCardCreditsIdPostRequest) QuickbooksDesktopCreditCardCreditsIdPostRequest(quickbooksDesktopCreditCardCreditsIdPostRequest QuickbooksDesktopCreditCardCreditsIdPostRequest) ApiQuickbooksDesktopCreditCardCreditsIdPostRequest {
	r.quickbooksDesktopCreditCardCreditsIdPostRequest = &quickbooksDesktopCreditCardCreditsIdPostRequest
	return r
}

func (r ApiQuickbooksDesktopCreditCardCreditsIdPostRequest) Execute() (*QbdCreditCardCredit, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopCreditCardCreditsIdPostExecute(r)
}

/*
QuickbooksDesktopCreditCardCreditsIdPost Update a credit card credit

Updates an existing credit card credit.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the credit card credit to update.
 @return ApiQuickbooksDesktopCreditCardCreditsIdPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopCreditCardCreditsIdPost(ctx context.Context, id string) ApiQuickbooksDesktopCreditCardCreditsIdPostRequest {
	return ApiQuickbooksDesktopCreditCardCreditsIdPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdCreditCardCredit
func (a *DefaultAPIService) QuickbooksDesktopCreditCardCreditsIdPostExecute(r ApiQuickbooksDesktopCreditCardCreditsIdPostRequest) (*QbdCreditCardCredit, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdCreditCardCredit
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopCreditCardCreditsIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/credit-card-credits/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopCreditCardCreditsIdPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopCreditCardCreditsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	quickbooksDesktopCreditCardCreditsPostRequest *QuickbooksDesktopCreditCardCreditsPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopCreditCardCreditsPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopCreditCardCreditsPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopCreditCardCreditsPostRequest) QuickbooksDesktopCreditCardCreditsPostRequest(quickbooksDesktopCreditCardCreditsPostRequest QuickbooksDesktopCreditCardCreditsPostRequest) ApiQuickbooksDesktopCreditCardCreditsPostRequest {
	r.quickbooksDesktopCreditCardCreditsPostRequest = &quickbooksDesktopCreditCardCreditsPostRequest
	return r
}

func (r ApiQuickbooksDesktopCreditCardCreditsPostRequest) Execute() (*QbdCreditCardCredit, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopCreditCardCreditsPostExecute(r)
}

/*
QuickbooksDesktopCreditCardCreditsPost Create a credit card credit

Creates a new credit card credit for the specified account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopCreditCardCreditsPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopCreditCardCreditsPost(ctx context.Context) ApiQuickbooksDesktopCreditCardCreditsPostRequest {
	return ApiQuickbooksDesktopCreditCardCreditsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QbdCreditCardCredit
func (a *DefaultAPIService) QuickbooksDesktopCreditCardCreditsPostExecute(r ApiQuickbooksDesktopCreditCardCreditsPostRequest) (*QbdCreditCardCredit, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdCreditCardCredit
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopCreditCardCreditsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/credit-card-credits"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopCreditCardCreditsPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopCreditMemosGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	ids *[]string
	refNumbers *[]string
	limit *int32
	cursor *string
	updatedAfter *string
	updatedBefore *string
	transactionDateFrom *string
	transactionDateTo *string
	customerIds *[]string
	accountIds *[]string
	refNumberContains *string
	refNumberStartsWith *string
	refNumberEndsWith *string
	refNumberFrom *string
	refNumberTo *string
	currencyIds *[]string
	includeLineItems *bool
	includeLinkedTransactions *bool
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopCreditMemosGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopCreditMemosGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

// Filter for specific credit memos by their QuickBooks-assigned unique identifier(s).  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopCreditMemosGetRequest) Ids(ids []string) ApiQuickbooksDesktopCreditMemosGetRequest {
	r.ids = &ids
	return r
}

// Filter for specific credit memos by their ref-number(s), case-sensitive. In QuickBooks, ref-numbers are not required to be unique and can be arbitrarily changed by the QuickBooks user.  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopCreditMemosGetRequest) RefNumbers(refNumbers []string) ApiQuickbooksDesktopCreditMemosGetRequest {
	r.refNumbers = &refNumbers
	return r
}

// The maximum number of objects to return. Accepts values ranging from 1 to 150, defaults to 150. When used with cursor-based pagination, this parameter controls how many results are returned per page. To paginate through results, combine this with the &#x60;cursor&#x60; parameter. Each response will include a &#x60;nextCursor&#x60; value that can be passed to subsequent requests to retrieve the next page of results.
func (r ApiQuickbooksDesktopCreditMemosGetRequest) Limit(limit int32) ApiQuickbooksDesktopCreditMemosGetRequest {
	r.limit = &limit
	return r
}

// The pagination token to fetch the next set of results when paginating with the &#x60;limit&#x60; parameter. Do not include this parameter on the first call. Use the &#x60;nextCursor&#x60; value returned in the previous response to request subsequent results.
func (r ApiQuickbooksDesktopCreditMemosGetRequest) Cursor(cursor string) ApiQuickbooksDesktopCreditMemosGetRequest {
	r.cursor = &cursor
	return r
}

// Filter for credit memos updated on or after this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 00:00:00 of that day.
func (r ApiQuickbooksDesktopCreditMemosGetRequest) UpdatedAfter(updatedAfter string) ApiQuickbooksDesktopCreditMemosGetRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Filter for credit memos updated on or before this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 23:59:59 of that day.
func (r ApiQuickbooksDesktopCreditMemosGetRequest) UpdatedBefore(updatedBefore string) ApiQuickbooksDesktopCreditMemosGetRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Filter for credit memos whose &#x60;date&#x60; field is on or after this date, in ISO 8601 format (YYYY-MM-DD).
func (r ApiQuickbooksDesktopCreditMemosGetRequest) TransactionDateFrom(transactionDateFrom string) ApiQuickbooksDesktopCreditMemosGetRequest {
	r.transactionDateFrom = &transactionDateFrom
	return r
}

// Filter for credit memos whose &#x60;date&#x60; field is on or before this date, in ISO 8601 format (YYYY-MM-DD).
func (r ApiQuickbooksDesktopCreditMemosGetRequest) TransactionDateTo(transactionDateTo string) ApiQuickbooksDesktopCreditMemosGetRequest {
	r.transactionDateTo = &transactionDateTo
	return r
}

// Filter for credit memos created for these customers. These are the customers who are owed money.
func (r ApiQuickbooksDesktopCreditMemosGetRequest) CustomerIds(customerIds []string) ApiQuickbooksDesktopCreditMemosGetRequest {
	r.customerIds = &customerIds
	return r
}

// Filter for credit memos associated with these accounts.
func (r ApiQuickbooksDesktopCreditMemosGetRequest) AccountIds(accountIds []string) ApiQuickbooksDesktopCreditMemosGetRequest {
	r.accountIds = &accountIds
	return r
}

// Filter for credit memos whose &#x60;refNumber&#x60; contains this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberStartsWith&#x60; or &#x60;refNumberEndsWith&#x60;.
func (r ApiQuickbooksDesktopCreditMemosGetRequest) RefNumberContains(refNumberContains string) ApiQuickbooksDesktopCreditMemosGetRequest {
	r.refNumberContains = &refNumberContains
	return r
}

// Filter for credit memos whose &#x60;refNumber&#x60; starts with this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberContains&#x60; or &#x60;refNumberEndsWith&#x60;.
func (r ApiQuickbooksDesktopCreditMemosGetRequest) RefNumberStartsWith(refNumberStartsWith string) ApiQuickbooksDesktopCreditMemosGetRequest {
	r.refNumberStartsWith = &refNumberStartsWith
	return r
}

// Filter for credit memos whose &#x60;refNumber&#x60; ends with this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberContains&#x60; or &#x60;refNumberStartsWith&#x60;.
func (r ApiQuickbooksDesktopCreditMemosGetRequest) RefNumberEndsWith(refNumberEndsWith string) ApiQuickbooksDesktopCreditMemosGetRequest {
	r.refNumberEndsWith = &refNumberEndsWith
	return r
}

// Filter for credit memos whose &#x60;refNumber&#x60; is greater than or equal to this value. If omitted, the range will begin with the first number of the list. Uses a numerical comparison for values that contain only digits; otherwise, uses a lexicographical comparison.
func (r ApiQuickbooksDesktopCreditMemosGetRequest) RefNumberFrom(refNumberFrom string) ApiQuickbooksDesktopCreditMemosGetRequest {
	r.refNumberFrom = &refNumberFrom
	return r
}

// Filter for credit memos whose &#x60;refNumber&#x60; is less than or equal to this value. If omitted, the range will end with the last number of the list. Uses a numerical comparison for values that contain only digits; otherwise, uses a lexicographical comparison.
func (r ApiQuickbooksDesktopCreditMemosGetRequest) RefNumberTo(refNumberTo string) ApiQuickbooksDesktopCreditMemosGetRequest {
	r.refNumberTo = &refNumberTo
	return r
}

// Filter for credit memos in these currencies.
func (r ApiQuickbooksDesktopCreditMemosGetRequest) CurrencyIds(currencyIds []string) ApiQuickbooksDesktopCreditMemosGetRequest {
	r.currencyIds = &currencyIds
	return r
}

// Whether to include line items in the response. Defaults to &#x60;true&#x60;.
func (r ApiQuickbooksDesktopCreditMemosGetRequest) IncludeLineItems(includeLineItems bool) ApiQuickbooksDesktopCreditMemosGetRequest {
	r.includeLineItems = &includeLineItems
	return r
}

// Whether to include linked transactions in the response. Defaults to &#x60;false&#x60;. For example, a payment linked to the corresponding credit memo.
func (r ApiQuickbooksDesktopCreditMemosGetRequest) IncludeLinkedTransactions(includeLinkedTransactions bool) ApiQuickbooksDesktopCreditMemosGetRequest {
	r.includeLinkedTransactions = &includeLinkedTransactions
	return r
}

func (r ApiQuickbooksDesktopCreditMemosGetRequest) Execute() (*QuickbooksDesktopCreditMemosGet200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopCreditMemosGetExecute(r)
}

/*
QuickbooksDesktopCreditMemosGet List all credit memos

Returns a list of credit memos. Use the `cursor` parameter to paginate through the results.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopCreditMemosGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopCreditMemosGet(ctx context.Context) ApiQuickbooksDesktopCreditMemosGetRequest {
	return ApiQuickbooksDesktopCreditMemosGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopCreditMemosGet200Response
func (a *DefaultAPIService) QuickbooksDesktopCreditMemosGetExecute(r ApiQuickbooksDesktopCreditMemosGetRequest) (*QuickbooksDesktopCreditMemosGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopCreditMemosGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopCreditMemosGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/credit-memos"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.refNumbers != nil {
		t := *r.refNumbers
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "refNumbers", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "refNumbers", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 150
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.transactionDateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDateFrom", r.transactionDateFrom, "form", "")
	}
	if r.transactionDateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDateTo", r.transactionDateTo, "form", "")
	}
	if r.customerIds != nil {
		t := *r.customerIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "customerIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "customerIds", t, "form", "multi")
		}
	}
	if r.accountIds != nil {
		t := *r.accountIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountIds", t, "form", "multi")
		}
	}
	if r.refNumberContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberContains", r.refNumberContains, "form", "")
	}
	if r.refNumberStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberStartsWith", r.refNumberStartsWith, "form", "")
	}
	if r.refNumberEndsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberEndsWith", r.refNumberEndsWith, "form", "")
	}
	if r.refNumberFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberFrom", r.refNumberFrom, "form", "")
	}
	if r.refNumberTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberTo", r.refNumberTo, "form", "")
	}
	if r.currencyIds != nil {
		t := *r.currencyIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", t, "form", "multi")
		}
	}
	if r.includeLineItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLineItems", r.includeLineItems, "form", "")
	} else {
		var defaultValue bool = true
		r.includeLineItems = &defaultValue
	}
	if r.includeLinkedTransactions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLinkedTransactions", r.includeLinkedTransactions, "form", "")
	} else {
		var defaultValue bool = false
		r.includeLinkedTransactions = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopCreditMemosIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopCreditMemosIdDeleteRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopCreditMemosIdDeleteRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopCreditMemosIdDeleteRequest) Execute() (*QuickbooksDesktopCreditMemosIdDelete200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopCreditMemosIdDeleteExecute(r)
}

/*
QuickbooksDesktopCreditMemosIdDelete Delete a credit memo

Permanently deletes a a credit memo. The deletion will fail if the credit memo is currently in use or has any linked transactions that are in use.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the credit memo to delete.
 @return ApiQuickbooksDesktopCreditMemosIdDeleteRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopCreditMemosIdDelete(ctx context.Context, id string) ApiQuickbooksDesktopCreditMemosIdDeleteRequest {
	return ApiQuickbooksDesktopCreditMemosIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopCreditMemosIdDelete200Response
func (a *DefaultAPIService) QuickbooksDesktopCreditMemosIdDeleteExecute(r ApiQuickbooksDesktopCreditMemosIdDeleteRequest) (*QuickbooksDesktopCreditMemosIdDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopCreditMemosIdDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopCreditMemosIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/credit-memos/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopCreditMemosIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopCreditMemosIdGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopCreditMemosIdGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopCreditMemosIdGetRequest) Execute() (*QbdCreditMemo, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopCreditMemosIdGetExecute(r)
}

/*
QuickbooksDesktopCreditMemosIdGet Retrieve a credit memo

Retrieves a credit memo by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the credit memo to retrieve.
 @return ApiQuickbooksDesktopCreditMemosIdGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopCreditMemosIdGet(ctx context.Context, id string) ApiQuickbooksDesktopCreditMemosIdGetRequest {
	return ApiQuickbooksDesktopCreditMemosIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdCreditMemo
func (a *DefaultAPIService) QuickbooksDesktopCreditMemosIdGetExecute(r ApiQuickbooksDesktopCreditMemosIdGetRequest) (*QbdCreditMemo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdCreditMemo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopCreditMemosIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/credit-memos/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopCreditMemosIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
	quickbooksDesktopCreditMemosIdPostRequest *QuickbooksDesktopCreditMemosIdPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopCreditMemosIdPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopCreditMemosIdPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopCreditMemosIdPostRequest) QuickbooksDesktopCreditMemosIdPostRequest(quickbooksDesktopCreditMemosIdPostRequest QuickbooksDesktopCreditMemosIdPostRequest) ApiQuickbooksDesktopCreditMemosIdPostRequest {
	r.quickbooksDesktopCreditMemosIdPostRequest = &quickbooksDesktopCreditMemosIdPostRequest
	return r
}

func (r ApiQuickbooksDesktopCreditMemosIdPostRequest) Execute() (*QbdCreditMemo, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopCreditMemosIdPostExecute(r)
}

/*
QuickbooksDesktopCreditMemosIdPost Update a credit memo

Updates an existing credit memo.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the credit memo to update.
 @return ApiQuickbooksDesktopCreditMemosIdPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopCreditMemosIdPost(ctx context.Context, id string) ApiQuickbooksDesktopCreditMemosIdPostRequest {
	return ApiQuickbooksDesktopCreditMemosIdPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdCreditMemo
func (a *DefaultAPIService) QuickbooksDesktopCreditMemosIdPostExecute(r ApiQuickbooksDesktopCreditMemosIdPostRequest) (*QbdCreditMemo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdCreditMemo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopCreditMemosIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/credit-memos/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopCreditMemosIdPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopCreditMemosPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	quickbooksDesktopCreditMemosPostRequest *QuickbooksDesktopCreditMemosPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopCreditMemosPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopCreditMemosPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopCreditMemosPostRequest) QuickbooksDesktopCreditMemosPostRequest(quickbooksDesktopCreditMemosPostRequest QuickbooksDesktopCreditMemosPostRequest) ApiQuickbooksDesktopCreditMemosPostRequest {
	r.quickbooksDesktopCreditMemosPostRequest = &quickbooksDesktopCreditMemosPostRequest
	return r
}

func (r ApiQuickbooksDesktopCreditMemosPostRequest) Execute() (*QbdCreditMemo, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopCreditMemosPostExecute(r)
}

/*
QuickbooksDesktopCreditMemosPost Create a credit memo

Creates a new credit memo.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopCreditMemosPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopCreditMemosPost(ctx context.Context) ApiQuickbooksDesktopCreditMemosPostRequest {
	return ApiQuickbooksDesktopCreditMemosPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QbdCreditMemo
func (a *DefaultAPIService) QuickbooksDesktopCreditMemosPostExecute(r ApiQuickbooksDesktopCreditMemosPostRequest) (*QbdCreditMemo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdCreditMemo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopCreditMemosPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/credit-memos"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopCreditMemosPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopCustomersGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	ids *[]string
	fullNames *[]string
	limit *int32
	cursor *string
	status *string
	updatedAfter *string
	updatedBefore *string
	nameContains *string
	nameStartsWith *string
	nameEndsWith *string
	nameFrom *string
	nameTo *string
	totalBalance *string
	totalBalanceGreaterThan *string
	totalBalanceGreaterThanOrEqualTo *string
	totalBalanceLessThan *string
	totalBalanceLessThanOrEqualTo *string
	currencyIds *[]string
	classIds *[]string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopCustomersGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopCustomersGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

// Filter for specific customers by their QuickBooks-assigned unique identifier(s).  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopCustomersGetRequest) Ids(ids []string) ApiQuickbooksDesktopCustomersGetRequest {
	r.ids = &ids
	return r
}

// Filter for specific customers by their full-name(s), case-insensitive. Like &#x60;id&#x60;, &#x60;fullName&#x60; is a unique identifier for a customer, formed by by combining the names of its parent objects with its own &#x60;name&#x60;, separated by colons. For example, if a customer is under \&quot;ABC Corporation\&quot; and has the &#x60;name&#x60; \&quot;Website Redesign Project\&quot;, its &#x60;fullName&#x60; would be \&quot;ABC Corporation:Website Redesign Project\&quot;.  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopCustomersGetRequest) FullNames(fullNames []string) ApiQuickbooksDesktopCustomersGetRequest {
	r.fullNames = &fullNames
	return r
}

// The maximum number of objects to return. Accepts values ranging from 1 to 150, defaults to 150. When used with cursor-based pagination, this parameter controls how many results are returned per page. To paginate through results, combine this with the &#x60;cursor&#x60; parameter. Each response will include a &#x60;nextCursor&#x60; value that can be passed to subsequent requests to retrieve the next page of results.
func (r ApiQuickbooksDesktopCustomersGetRequest) Limit(limit int32) ApiQuickbooksDesktopCustomersGetRequest {
	r.limit = &limit
	return r
}

// The pagination token to fetch the next set of results when paginating with the &#x60;limit&#x60; parameter. Do not include this parameter on the first call. Use the &#x60;nextCursor&#x60; value returned in the previous response to request subsequent results.
func (r ApiQuickbooksDesktopCustomersGetRequest) Cursor(cursor string) ApiQuickbooksDesktopCustomersGetRequest {
	r.cursor = &cursor
	return r
}

// Filter for customers that are active, inactive, or both.
func (r ApiQuickbooksDesktopCustomersGetRequest) Status(status string) ApiQuickbooksDesktopCustomersGetRequest {
	r.status = &status
	return r
}

// Filter for customers updated on or after this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 00:00:00 of that day.
func (r ApiQuickbooksDesktopCustomersGetRequest) UpdatedAfter(updatedAfter string) ApiQuickbooksDesktopCustomersGetRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Filter for customers updated on or before this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 23:59:59 of that day.
func (r ApiQuickbooksDesktopCustomersGetRequest) UpdatedBefore(updatedBefore string) ApiQuickbooksDesktopCustomersGetRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Filter for customers whose &#x60;name&#x60; contains this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameStartsWith&#x60; or &#x60;nameEndsWith&#x60;.
func (r ApiQuickbooksDesktopCustomersGetRequest) NameContains(nameContains string) ApiQuickbooksDesktopCustomersGetRequest {
	r.nameContains = &nameContains
	return r
}

// Filter for customers whose &#x60;name&#x60; starts with this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameContains&#x60; or &#x60;nameEndsWith&#x60;.
func (r ApiQuickbooksDesktopCustomersGetRequest) NameStartsWith(nameStartsWith string) ApiQuickbooksDesktopCustomersGetRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Filter for customers whose &#x60;name&#x60; ends with this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameContains&#x60; or &#x60;nameStartsWith&#x60;.
func (r ApiQuickbooksDesktopCustomersGetRequest) NameEndsWith(nameEndsWith string) ApiQuickbooksDesktopCustomersGetRequest {
	r.nameEndsWith = &nameEndsWith
	return r
}

// Filter for customers whose &#x60;name&#x60; is alphabetically greater than or equal to this value.
func (r ApiQuickbooksDesktopCustomersGetRequest) NameFrom(nameFrom string) ApiQuickbooksDesktopCustomersGetRequest {
	r.nameFrom = &nameFrom
	return r
}

// Filter for customers whose &#x60;name&#x60; is alphabetically less than or equal to this value.
func (r ApiQuickbooksDesktopCustomersGetRequest) NameTo(nameTo string) ApiQuickbooksDesktopCustomersGetRequest {
	r.nameTo = &nameTo
	return r
}

// Filter for customers whose &#x60;totalBalance&#x60; equals this amount, represented as a decimal string. You can only use one total-balance filter at a time.
func (r ApiQuickbooksDesktopCustomersGetRequest) TotalBalance(totalBalance string) ApiQuickbooksDesktopCustomersGetRequest {
	r.totalBalance = &totalBalance
	return r
}

// Filter for customers whose &#x60;totalBalance&#x60; is greater than this amount, represented as a decimal string. You can only use one total-balance filter at a time.
func (r ApiQuickbooksDesktopCustomersGetRequest) TotalBalanceGreaterThan(totalBalanceGreaterThan string) ApiQuickbooksDesktopCustomersGetRequest {
	r.totalBalanceGreaterThan = &totalBalanceGreaterThan
	return r
}

// Filter for customers whose &#x60;totalBalance&#x60; is greater than or equal to this amount, represented as a decimal string. You can only use one total-balance filter at a time.
func (r ApiQuickbooksDesktopCustomersGetRequest) TotalBalanceGreaterThanOrEqualTo(totalBalanceGreaterThanOrEqualTo string) ApiQuickbooksDesktopCustomersGetRequest {
	r.totalBalanceGreaterThanOrEqualTo = &totalBalanceGreaterThanOrEqualTo
	return r
}

// Filter for customers whose &#x60;totalBalance&#x60; is less than this amount, represented as a decimal string. You can only use one total-balance filter at a time.
func (r ApiQuickbooksDesktopCustomersGetRequest) TotalBalanceLessThan(totalBalanceLessThan string) ApiQuickbooksDesktopCustomersGetRequest {
	r.totalBalanceLessThan = &totalBalanceLessThan
	return r
}

// Filter for customers whose &#x60;totalBalance&#x60; is less than or equal to this amount, represented as a decimal string. You can only use one total-balance filter at a time.
func (r ApiQuickbooksDesktopCustomersGetRequest) TotalBalanceLessThanOrEqualTo(totalBalanceLessThanOrEqualTo string) ApiQuickbooksDesktopCustomersGetRequest {
	r.totalBalanceLessThanOrEqualTo = &totalBalanceLessThanOrEqualTo
	return r
}

// Filter for customers in these currencies.
func (r ApiQuickbooksDesktopCustomersGetRequest) CurrencyIds(currencyIds []string) ApiQuickbooksDesktopCustomersGetRequest {
	r.currencyIds = &currencyIds
	return r
}

// Filter for customers of these classes. A class is a way end-users can categorize customers in QuickBooks.
func (r ApiQuickbooksDesktopCustomersGetRequest) ClassIds(classIds []string) ApiQuickbooksDesktopCustomersGetRequest {
	r.classIds = &classIds
	return r
}

func (r ApiQuickbooksDesktopCustomersGetRequest) Execute() (*QuickbooksDesktopCustomersGet200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopCustomersGetExecute(r)
}

/*
QuickbooksDesktopCustomersGet List all customers

Returns a list of customers. Use the `cursor` parameter to paginate through the results.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopCustomersGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopCustomersGet(ctx context.Context) ApiQuickbooksDesktopCustomersGetRequest {
	return ApiQuickbooksDesktopCustomersGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopCustomersGet200Response
func (a *DefaultAPIService) QuickbooksDesktopCustomersGetExecute(r ApiQuickbooksDesktopCustomersGetRequest) (*QuickbooksDesktopCustomersGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopCustomersGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopCustomersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/customers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.fullNames != nil {
		t := *r.fullNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fullNames", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fullNames", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 150
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	} else {
		var defaultValue string = "active"
		r.status = &defaultValue
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.nameContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameContains", r.nameContains, "form", "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameStartsWith", r.nameStartsWith, "form", "")
	}
	if r.nameEndsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameEndsWith", r.nameEndsWith, "form", "")
	}
	if r.nameFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameFrom", r.nameFrom, "form", "")
	}
	if r.nameTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameTo", r.nameTo, "form", "")
	}
	if r.totalBalance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "totalBalance", r.totalBalance, "form", "")
	}
	if r.totalBalanceGreaterThan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "totalBalanceGreaterThan", r.totalBalanceGreaterThan, "form", "")
	}
	if r.totalBalanceGreaterThanOrEqualTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "totalBalanceGreaterThanOrEqualTo", r.totalBalanceGreaterThanOrEqualTo, "form", "")
	}
	if r.totalBalanceLessThan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "totalBalanceLessThan", r.totalBalanceLessThan, "form", "")
	}
	if r.totalBalanceLessThanOrEqualTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "totalBalanceLessThanOrEqualTo", r.totalBalanceLessThanOrEqualTo, "form", "")
	}
	if r.currencyIds != nil {
		t := *r.currencyIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", t, "form", "multi")
		}
	}
	if r.classIds != nil {
		t := *r.classIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "classIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "classIds", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopCustomersIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopCustomersIdGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopCustomersIdGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopCustomersIdGetRequest) Execute() (*QbdCustomer, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopCustomersIdGetExecute(r)
}

/*
QuickbooksDesktopCustomersIdGet Retrieve a customer

Retrieves a customer by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the customer to retrieve.
 @return ApiQuickbooksDesktopCustomersIdGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopCustomersIdGet(ctx context.Context, id string) ApiQuickbooksDesktopCustomersIdGetRequest {
	return ApiQuickbooksDesktopCustomersIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdCustomer
func (a *DefaultAPIService) QuickbooksDesktopCustomersIdGetExecute(r ApiQuickbooksDesktopCustomersIdGetRequest) (*QbdCustomer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdCustomer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopCustomersIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/customers/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopCustomersIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
	quickbooksDesktopCustomersIdPostRequest *QuickbooksDesktopCustomersIdPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopCustomersIdPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopCustomersIdPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopCustomersIdPostRequest) QuickbooksDesktopCustomersIdPostRequest(quickbooksDesktopCustomersIdPostRequest QuickbooksDesktopCustomersIdPostRequest) ApiQuickbooksDesktopCustomersIdPostRequest {
	r.quickbooksDesktopCustomersIdPostRequest = &quickbooksDesktopCustomersIdPostRequest
	return r
}

func (r ApiQuickbooksDesktopCustomersIdPostRequest) Execute() (*QbdCustomer, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopCustomersIdPostExecute(r)
}

/*
QuickbooksDesktopCustomersIdPost Update a customer

Updates an existing customer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the customer to update.
 @return ApiQuickbooksDesktopCustomersIdPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopCustomersIdPost(ctx context.Context, id string) ApiQuickbooksDesktopCustomersIdPostRequest {
	return ApiQuickbooksDesktopCustomersIdPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdCustomer
func (a *DefaultAPIService) QuickbooksDesktopCustomersIdPostExecute(r ApiQuickbooksDesktopCustomersIdPostRequest) (*QbdCustomer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdCustomer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopCustomersIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/customers/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopCustomersIdPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopCustomersPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	quickbooksDesktopCustomersPostRequest *QuickbooksDesktopCustomersPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopCustomersPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopCustomersPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopCustomersPostRequest) QuickbooksDesktopCustomersPostRequest(quickbooksDesktopCustomersPostRequest QuickbooksDesktopCustomersPostRequest) ApiQuickbooksDesktopCustomersPostRequest {
	r.quickbooksDesktopCustomersPostRequest = &quickbooksDesktopCustomersPostRequest
	return r
}

func (r ApiQuickbooksDesktopCustomersPostRequest) Execute() (*QbdCustomer, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopCustomersPostExecute(r)
}

/*
QuickbooksDesktopCustomersPost Create a customer

Creates a new customer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopCustomersPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopCustomersPost(ctx context.Context) ApiQuickbooksDesktopCustomersPostRequest {
	return ApiQuickbooksDesktopCustomersPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QbdCustomer
func (a *DefaultAPIService) QuickbooksDesktopCustomersPostExecute(r ApiQuickbooksDesktopCustomersPostRequest) (*QbdCustomer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdCustomer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopCustomersPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/customers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopCustomersPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopDateDrivenTermsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	ids *[]string
	names *[]string
	limit *int32
	status *string
	updatedAfter *string
	updatedBefore *string
	nameContains *string
	nameStartsWith *string
	nameEndsWith *string
	nameFrom *string
	nameTo *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopDateDrivenTermsGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopDateDrivenTermsGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

// Filter for specific date-driven terms by their QuickBooks-assigned unique identifier(s).  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopDateDrivenTermsGetRequest) Ids(ids []string) ApiQuickbooksDesktopDateDrivenTermsGetRequest {
	r.ids = &ids
	return r
}

// Filter for specific date-driven terms by their name(s), case-insensitive. Like &#x60;id&#x60;, &#x60;name&#x60; is a unique identifier for a date-driven term.  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopDateDrivenTermsGetRequest) Names(names []string) ApiQuickbooksDesktopDateDrivenTermsGetRequest {
	r.names = &names
	return r
}

// The maximum number of objects to return.  **IMPORTANT**: QuickBooks Desktop does not support cursor-based pagination for date-driven terms. This parameter will limit the response size, but you cannot fetch subsequent results using a cursor. For pagination, use the name-range parameters instead (e.g., &#x60;nameFrom&#x3D;A&amp;nameTo&#x3D;B&#x60;).  When this parameter is omitted, the endpoint returns all date-driven terms without limit, unlike paginated endpoints which default to 150 records. This is acceptable because date-driven terms typically have low record counts.
func (r ApiQuickbooksDesktopDateDrivenTermsGetRequest) Limit(limit int32) ApiQuickbooksDesktopDateDrivenTermsGetRequest {
	r.limit = &limit
	return r
}

// Filter for date-driven terms that are active, inactive, or both.
func (r ApiQuickbooksDesktopDateDrivenTermsGetRequest) Status(status string) ApiQuickbooksDesktopDateDrivenTermsGetRequest {
	r.status = &status
	return r
}

// Filter for date-driven terms updated on or after this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 00:00:00 of that day.
func (r ApiQuickbooksDesktopDateDrivenTermsGetRequest) UpdatedAfter(updatedAfter string) ApiQuickbooksDesktopDateDrivenTermsGetRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Filter for date-driven terms updated on or before this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 23:59:59 of that day.
func (r ApiQuickbooksDesktopDateDrivenTermsGetRequest) UpdatedBefore(updatedBefore string) ApiQuickbooksDesktopDateDrivenTermsGetRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Filter for date-driven terms whose &#x60;name&#x60; contains this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameStartsWith&#x60; or &#x60;nameEndsWith&#x60;.
func (r ApiQuickbooksDesktopDateDrivenTermsGetRequest) NameContains(nameContains string) ApiQuickbooksDesktopDateDrivenTermsGetRequest {
	r.nameContains = &nameContains
	return r
}

// Filter for date-driven terms whose &#x60;name&#x60; starts with this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameContains&#x60; or &#x60;nameEndsWith&#x60;.
func (r ApiQuickbooksDesktopDateDrivenTermsGetRequest) NameStartsWith(nameStartsWith string) ApiQuickbooksDesktopDateDrivenTermsGetRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Filter for date-driven terms whose &#x60;name&#x60; ends with this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameContains&#x60; or &#x60;nameStartsWith&#x60;.
func (r ApiQuickbooksDesktopDateDrivenTermsGetRequest) NameEndsWith(nameEndsWith string) ApiQuickbooksDesktopDateDrivenTermsGetRequest {
	r.nameEndsWith = &nameEndsWith
	return r
}

// Filter for date-driven terms whose &#x60;name&#x60; is alphabetically greater than or equal to this value.
func (r ApiQuickbooksDesktopDateDrivenTermsGetRequest) NameFrom(nameFrom string) ApiQuickbooksDesktopDateDrivenTermsGetRequest {
	r.nameFrom = &nameFrom
	return r
}

// Filter for date-driven terms whose &#x60;name&#x60; is alphabetically less than or equal to this value.
func (r ApiQuickbooksDesktopDateDrivenTermsGetRequest) NameTo(nameTo string) ApiQuickbooksDesktopDateDrivenTermsGetRequest {
	r.nameTo = &nameTo
	return r
}

func (r ApiQuickbooksDesktopDateDrivenTermsGetRequest) Execute() (*QuickbooksDesktopDateDrivenTermsGet200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopDateDrivenTermsGetExecute(r)
}

/*
QuickbooksDesktopDateDrivenTermsGet List all date-driven terms

Returns a list of date-driven terms. NOTE: QuickBooks Desktop does not support pagination for date-driven terms; hence, there is no `cursor` parameter. Users typically have few date-driven terms.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopDateDrivenTermsGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopDateDrivenTermsGet(ctx context.Context) ApiQuickbooksDesktopDateDrivenTermsGetRequest {
	return ApiQuickbooksDesktopDateDrivenTermsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopDateDrivenTermsGet200Response
func (a *DefaultAPIService) QuickbooksDesktopDateDrivenTermsGetExecute(r ApiQuickbooksDesktopDateDrivenTermsGetRequest) (*QuickbooksDesktopDateDrivenTermsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopDateDrivenTermsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopDateDrivenTermsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/date-driven-terms"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.names != nil {
		t := *r.names
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "names", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "names", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	} else {
		var defaultValue string = "active"
		r.status = &defaultValue
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.nameContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameContains", r.nameContains, "form", "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameStartsWith", r.nameStartsWith, "form", "")
	}
	if r.nameEndsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameEndsWith", r.nameEndsWith, "form", "")
	}
	if r.nameFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameFrom", r.nameFrom, "form", "")
	}
	if r.nameTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameTo", r.nameTo, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopDateDrivenTermsIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopDateDrivenTermsIdGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopDateDrivenTermsIdGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopDateDrivenTermsIdGetRequest) Execute() (*QbdDateDrivenTerm, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopDateDrivenTermsIdGetExecute(r)
}

/*
QuickbooksDesktopDateDrivenTermsIdGet Retrieve a date-driven term

Retrieves a date-driven term by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the date-driven term to retrieve.
 @return ApiQuickbooksDesktopDateDrivenTermsIdGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopDateDrivenTermsIdGet(ctx context.Context, id string) ApiQuickbooksDesktopDateDrivenTermsIdGetRequest {
	return ApiQuickbooksDesktopDateDrivenTermsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdDateDrivenTerm
func (a *DefaultAPIService) QuickbooksDesktopDateDrivenTermsIdGetExecute(r ApiQuickbooksDesktopDateDrivenTermsIdGetRequest) (*QbdDateDrivenTerm, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdDateDrivenTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopDateDrivenTermsIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/date-driven-terms/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopDateDrivenTermsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	quickbooksDesktopDateDrivenTermsPostRequest *QuickbooksDesktopDateDrivenTermsPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopDateDrivenTermsPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopDateDrivenTermsPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopDateDrivenTermsPostRequest) QuickbooksDesktopDateDrivenTermsPostRequest(quickbooksDesktopDateDrivenTermsPostRequest QuickbooksDesktopDateDrivenTermsPostRequest) ApiQuickbooksDesktopDateDrivenTermsPostRequest {
	r.quickbooksDesktopDateDrivenTermsPostRequest = &quickbooksDesktopDateDrivenTermsPostRequest
	return r
}

func (r ApiQuickbooksDesktopDateDrivenTermsPostRequest) Execute() (*QbdDateDrivenTerm, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopDateDrivenTermsPostExecute(r)
}

/*
QuickbooksDesktopDateDrivenTermsPost Create a date-driven term

Creates a new date-driven term.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopDateDrivenTermsPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopDateDrivenTermsPost(ctx context.Context) ApiQuickbooksDesktopDateDrivenTermsPostRequest {
	return ApiQuickbooksDesktopDateDrivenTermsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QbdDateDrivenTerm
func (a *DefaultAPIService) QuickbooksDesktopDateDrivenTermsPostExecute(r ApiQuickbooksDesktopDateDrivenTermsPostRequest) (*QbdDateDrivenTerm, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdDateDrivenTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopDateDrivenTermsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/date-driven-terms"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopDateDrivenTermsPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopDiscountItemsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	ids *[]string
	fullNames *[]string
	limit *int32
	cursor *string
	status *string
	updatedAfter *string
	updatedBefore *string
	nameContains *string
	nameStartsWith *string
	nameEndsWith *string
	nameFrom *string
	nameTo *string
	classIds *[]string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopDiscountItemsGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopDiscountItemsGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

// Filter for specific discount items by their QuickBooks-assigned unique identifier(s).  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopDiscountItemsGetRequest) Ids(ids []string) ApiQuickbooksDesktopDiscountItemsGetRequest {
	r.ids = &ids
	return r
}

// Filter for specific discount items by their full-name(s), case-insensitive. Like &#x60;id&#x60;, &#x60;fullName&#x60; is a unique identifier for a discount item, formed by by combining the names of its parent objects with its own &#x60;name&#x60;, separated by colons. For example, if a discount item is under \&quot;Discounts\&quot; and has the &#x60;name&#x60; \&quot;10% labor discount\&quot;, its &#x60;fullName&#x60; would be \&quot;Discounts:10% labor discount\&quot;.  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopDiscountItemsGetRequest) FullNames(fullNames []string) ApiQuickbooksDesktopDiscountItemsGetRequest {
	r.fullNames = &fullNames
	return r
}

// The maximum number of objects to return. Accepts values ranging from 1 to 150, defaults to 150. When used with cursor-based pagination, this parameter controls how many results are returned per page. To paginate through results, combine this with the &#x60;cursor&#x60; parameter. Each response will include a &#x60;nextCursor&#x60; value that can be passed to subsequent requests to retrieve the next page of results.
func (r ApiQuickbooksDesktopDiscountItemsGetRequest) Limit(limit int32) ApiQuickbooksDesktopDiscountItemsGetRequest {
	r.limit = &limit
	return r
}

// The pagination token to fetch the next set of results when paginating with the &#x60;limit&#x60; parameter. Do not include this parameter on the first call. Use the &#x60;nextCursor&#x60; value returned in the previous response to request subsequent results.
func (r ApiQuickbooksDesktopDiscountItemsGetRequest) Cursor(cursor string) ApiQuickbooksDesktopDiscountItemsGetRequest {
	r.cursor = &cursor
	return r
}

// Filter for discount items that are active, inactive, or both.
func (r ApiQuickbooksDesktopDiscountItemsGetRequest) Status(status string) ApiQuickbooksDesktopDiscountItemsGetRequest {
	r.status = &status
	return r
}

// Filter for discount items updated on or after this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 00:00:00 of that day.
func (r ApiQuickbooksDesktopDiscountItemsGetRequest) UpdatedAfter(updatedAfter string) ApiQuickbooksDesktopDiscountItemsGetRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Filter for discount items updated on or before this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 23:59:59 of that day.
func (r ApiQuickbooksDesktopDiscountItemsGetRequest) UpdatedBefore(updatedBefore string) ApiQuickbooksDesktopDiscountItemsGetRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Filter for discount items whose &#x60;name&#x60; contains this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameStartsWith&#x60; or &#x60;nameEndsWith&#x60;.
func (r ApiQuickbooksDesktopDiscountItemsGetRequest) NameContains(nameContains string) ApiQuickbooksDesktopDiscountItemsGetRequest {
	r.nameContains = &nameContains
	return r
}

// Filter for discount items whose &#x60;name&#x60; starts with this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameContains&#x60; or &#x60;nameEndsWith&#x60;.
func (r ApiQuickbooksDesktopDiscountItemsGetRequest) NameStartsWith(nameStartsWith string) ApiQuickbooksDesktopDiscountItemsGetRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Filter for discount items whose &#x60;name&#x60; ends with this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameContains&#x60; or &#x60;nameStartsWith&#x60;.
func (r ApiQuickbooksDesktopDiscountItemsGetRequest) NameEndsWith(nameEndsWith string) ApiQuickbooksDesktopDiscountItemsGetRequest {
	r.nameEndsWith = &nameEndsWith
	return r
}

// Filter for discount items whose &#x60;name&#x60; is alphabetically greater than or equal to this value.
func (r ApiQuickbooksDesktopDiscountItemsGetRequest) NameFrom(nameFrom string) ApiQuickbooksDesktopDiscountItemsGetRequest {
	r.nameFrom = &nameFrom
	return r
}

// Filter for discount items whose &#x60;name&#x60; is alphabetically less than or equal to this value.
func (r ApiQuickbooksDesktopDiscountItemsGetRequest) NameTo(nameTo string) ApiQuickbooksDesktopDiscountItemsGetRequest {
	r.nameTo = &nameTo
	return r
}

// Filter for discount items of these classes. A class is a way end-users can categorize discount items in QuickBooks.
func (r ApiQuickbooksDesktopDiscountItemsGetRequest) ClassIds(classIds []string) ApiQuickbooksDesktopDiscountItemsGetRequest {
	r.classIds = &classIds
	return r
}

func (r ApiQuickbooksDesktopDiscountItemsGetRequest) Execute() (*QuickbooksDesktopDiscountItemsGet200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopDiscountItemsGetExecute(r)
}

/*
QuickbooksDesktopDiscountItemsGet List all discount items

Returns a list of discount items. Use the `cursor` parameter to paginate through the results.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopDiscountItemsGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopDiscountItemsGet(ctx context.Context) ApiQuickbooksDesktopDiscountItemsGetRequest {
	return ApiQuickbooksDesktopDiscountItemsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopDiscountItemsGet200Response
func (a *DefaultAPIService) QuickbooksDesktopDiscountItemsGetExecute(r ApiQuickbooksDesktopDiscountItemsGetRequest) (*QuickbooksDesktopDiscountItemsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopDiscountItemsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopDiscountItemsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/discount-items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.fullNames != nil {
		t := *r.fullNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fullNames", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fullNames", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 150
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	} else {
		var defaultValue string = "active"
		r.status = &defaultValue
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.nameContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameContains", r.nameContains, "form", "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameStartsWith", r.nameStartsWith, "form", "")
	}
	if r.nameEndsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameEndsWith", r.nameEndsWith, "form", "")
	}
	if r.nameFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameFrom", r.nameFrom, "form", "")
	}
	if r.nameTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameTo", r.nameTo, "form", "")
	}
	if r.classIds != nil {
		t := *r.classIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "classIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "classIds", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopDiscountItemsIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopDiscountItemsIdGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopDiscountItemsIdGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopDiscountItemsIdGetRequest) Execute() (*QbdDiscountItem, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopDiscountItemsIdGetExecute(r)
}

/*
QuickbooksDesktopDiscountItemsIdGet Retrieve a discount item

Retrieves a discount item by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the discount item to retrieve.
 @return ApiQuickbooksDesktopDiscountItemsIdGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopDiscountItemsIdGet(ctx context.Context, id string) ApiQuickbooksDesktopDiscountItemsIdGetRequest {
	return ApiQuickbooksDesktopDiscountItemsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdDiscountItem
func (a *DefaultAPIService) QuickbooksDesktopDiscountItemsIdGetExecute(r ApiQuickbooksDesktopDiscountItemsIdGetRequest) (*QbdDiscountItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdDiscountItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopDiscountItemsIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/discount-items/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopDiscountItemsIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
	quickbooksDesktopDiscountItemsIdPostRequest *QuickbooksDesktopDiscountItemsIdPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopDiscountItemsIdPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopDiscountItemsIdPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopDiscountItemsIdPostRequest) QuickbooksDesktopDiscountItemsIdPostRequest(quickbooksDesktopDiscountItemsIdPostRequest QuickbooksDesktopDiscountItemsIdPostRequest) ApiQuickbooksDesktopDiscountItemsIdPostRequest {
	r.quickbooksDesktopDiscountItemsIdPostRequest = &quickbooksDesktopDiscountItemsIdPostRequest
	return r
}

func (r ApiQuickbooksDesktopDiscountItemsIdPostRequest) Execute() (*QbdDiscountItem, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopDiscountItemsIdPostExecute(r)
}

/*
QuickbooksDesktopDiscountItemsIdPost Update a discount item

Updates an existing discount item.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the discount item to update.
 @return ApiQuickbooksDesktopDiscountItemsIdPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopDiscountItemsIdPost(ctx context.Context, id string) ApiQuickbooksDesktopDiscountItemsIdPostRequest {
	return ApiQuickbooksDesktopDiscountItemsIdPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdDiscountItem
func (a *DefaultAPIService) QuickbooksDesktopDiscountItemsIdPostExecute(r ApiQuickbooksDesktopDiscountItemsIdPostRequest) (*QbdDiscountItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdDiscountItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopDiscountItemsIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/discount-items/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopDiscountItemsIdPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopDiscountItemsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	quickbooksDesktopDiscountItemsPostRequest *QuickbooksDesktopDiscountItemsPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopDiscountItemsPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopDiscountItemsPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopDiscountItemsPostRequest) QuickbooksDesktopDiscountItemsPostRequest(quickbooksDesktopDiscountItemsPostRequest QuickbooksDesktopDiscountItemsPostRequest) ApiQuickbooksDesktopDiscountItemsPostRequest {
	r.quickbooksDesktopDiscountItemsPostRequest = &quickbooksDesktopDiscountItemsPostRequest
	return r
}

func (r ApiQuickbooksDesktopDiscountItemsPostRequest) Execute() (*QbdDiscountItem, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopDiscountItemsPostExecute(r)
}

/*
QuickbooksDesktopDiscountItemsPost Create a discount item

Creates a new discount item.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopDiscountItemsPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopDiscountItemsPost(ctx context.Context) ApiQuickbooksDesktopDiscountItemsPostRequest {
	return ApiQuickbooksDesktopDiscountItemsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QbdDiscountItem
func (a *DefaultAPIService) QuickbooksDesktopDiscountItemsPostExecute(r ApiQuickbooksDesktopDiscountItemsPostRequest) (*QbdDiscountItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdDiscountItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopDiscountItemsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/discount-items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopDiscountItemsPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopEmployeesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	ids *[]string
	names *[]string
	limit *int32
	cursor *string
	status *string
	updatedAfter *string
	updatedBefore *string
	nameContains *string
	nameStartsWith *string
	nameEndsWith *string
	nameFrom *string
	nameTo *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopEmployeesGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopEmployeesGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

// Filter for specific employees by their QuickBooks-assigned unique identifier(s).  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopEmployeesGetRequest) Ids(ids []string) ApiQuickbooksDesktopEmployeesGetRequest {
	r.ids = &ids
	return r
}

// Filter for specific employees by their name(s), case-insensitive. Like &#x60;id&#x60;, &#x60;name&#x60; is a unique identifier for an employee.  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopEmployeesGetRequest) Names(names []string) ApiQuickbooksDesktopEmployeesGetRequest {
	r.names = &names
	return r
}

// The maximum number of objects to return. Accepts values ranging from 1 to 150, defaults to 150. When used with cursor-based pagination, this parameter controls how many results are returned per page. To paginate through results, combine this with the &#x60;cursor&#x60; parameter. Each response will include a &#x60;nextCursor&#x60; value that can be passed to subsequent requests to retrieve the next page of results.
func (r ApiQuickbooksDesktopEmployeesGetRequest) Limit(limit int32) ApiQuickbooksDesktopEmployeesGetRequest {
	r.limit = &limit
	return r
}

// The pagination token to fetch the next set of results when paginating with the &#x60;limit&#x60; parameter. Do not include this parameter on the first call. Use the &#x60;nextCursor&#x60; value returned in the previous response to request subsequent results.
func (r ApiQuickbooksDesktopEmployeesGetRequest) Cursor(cursor string) ApiQuickbooksDesktopEmployeesGetRequest {
	r.cursor = &cursor
	return r
}

// Filter for employees that are active, inactive, or both.
func (r ApiQuickbooksDesktopEmployeesGetRequest) Status(status string) ApiQuickbooksDesktopEmployeesGetRequest {
	r.status = &status
	return r
}

// Filter for employees updated on or after this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 00:00:00 of that day.
func (r ApiQuickbooksDesktopEmployeesGetRequest) UpdatedAfter(updatedAfter string) ApiQuickbooksDesktopEmployeesGetRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Filter for employees updated on or before this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 23:59:59 of that day.
func (r ApiQuickbooksDesktopEmployeesGetRequest) UpdatedBefore(updatedBefore string) ApiQuickbooksDesktopEmployeesGetRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Filter for employees whose &#x60;name&#x60; contains this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameStartsWith&#x60; or &#x60;nameEndsWith&#x60;.
func (r ApiQuickbooksDesktopEmployeesGetRequest) NameContains(nameContains string) ApiQuickbooksDesktopEmployeesGetRequest {
	r.nameContains = &nameContains
	return r
}

// Filter for employees whose &#x60;name&#x60; starts with this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameContains&#x60; or &#x60;nameEndsWith&#x60;.
func (r ApiQuickbooksDesktopEmployeesGetRequest) NameStartsWith(nameStartsWith string) ApiQuickbooksDesktopEmployeesGetRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Filter for employees whose &#x60;name&#x60; ends with this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameContains&#x60; or &#x60;nameStartsWith&#x60;.
func (r ApiQuickbooksDesktopEmployeesGetRequest) NameEndsWith(nameEndsWith string) ApiQuickbooksDesktopEmployeesGetRequest {
	r.nameEndsWith = &nameEndsWith
	return r
}

// Filter for employees whose &#x60;name&#x60; is alphabetically greater than or equal to this value.
func (r ApiQuickbooksDesktopEmployeesGetRequest) NameFrom(nameFrom string) ApiQuickbooksDesktopEmployeesGetRequest {
	r.nameFrom = &nameFrom
	return r
}

// Filter for employees whose &#x60;name&#x60; is alphabetically less than or equal to this value.
func (r ApiQuickbooksDesktopEmployeesGetRequest) NameTo(nameTo string) ApiQuickbooksDesktopEmployeesGetRequest {
	r.nameTo = &nameTo
	return r
}

func (r ApiQuickbooksDesktopEmployeesGetRequest) Execute() (*QuickbooksDesktopEmployeesGet200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopEmployeesGetExecute(r)
}

/*
QuickbooksDesktopEmployeesGet List all employees

Returns a list of employees. Use the `cursor` parameter to paginate through the results.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopEmployeesGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopEmployeesGet(ctx context.Context) ApiQuickbooksDesktopEmployeesGetRequest {
	return ApiQuickbooksDesktopEmployeesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopEmployeesGet200Response
func (a *DefaultAPIService) QuickbooksDesktopEmployeesGetExecute(r ApiQuickbooksDesktopEmployeesGetRequest) (*QuickbooksDesktopEmployeesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopEmployeesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopEmployeesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/employees"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.names != nil {
		t := *r.names
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "names", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "names", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 150
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	} else {
		var defaultValue string = "active"
		r.status = &defaultValue
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.nameContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameContains", r.nameContains, "form", "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameStartsWith", r.nameStartsWith, "form", "")
	}
	if r.nameEndsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameEndsWith", r.nameEndsWith, "form", "")
	}
	if r.nameFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameFrom", r.nameFrom, "form", "")
	}
	if r.nameTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameTo", r.nameTo, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopEmployeesIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopEmployeesIdGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopEmployeesIdGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopEmployeesIdGetRequest) Execute() (*QbdEmployee, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopEmployeesIdGetExecute(r)
}

/*
QuickbooksDesktopEmployeesIdGet Retrieve an employee

Retrieves an employee by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the employee to retrieve.
 @return ApiQuickbooksDesktopEmployeesIdGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopEmployeesIdGet(ctx context.Context, id string) ApiQuickbooksDesktopEmployeesIdGetRequest {
	return ApiQuickbooksDesktopEmployeesIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdEmployee
func (a *DefaultAPIService) QuickbooksDesktopEmployeesIdGetExecute(r ApiQuickbooksDesktopEmployeesIdGetRequest) (*QbdEmployee, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdEmployee
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopEmployeesIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/employees/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopEmployeesIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
	quickbooksDesktopEmployeesIdPostRequest *QuickbooksDesktopEmployeesIdPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopEmployeesIdPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopEmployeesIdPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopEmployeesIdPostRequest) QuickbooksDesktopEmployeesIdPostRequest(quickbooksDesktopEmployeesIdPostRequest QuickbooksDesktopEmployeesIdPostRequest) ApiQuickbooksDesktopEmployeesIdPostRequest {
	r.quickbooksDesktopEmployeesIdPostRequest = &quickbooksDesktopEmployeesIdPostRequest
	return r
}

func (r ApiQuickbooksDesktopEmployeesIdPostRequest) Execute() (*QbdEmployee, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopEmployeesIdPostExecute(r)
}

/*
QuickbooksDesktopEmployeesIdPost Update an employee

Updates an existing employee.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the employee to update.
 @return ApiQuickbooksDesktopEmployeesIdPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopEmployeesIdPost(ctx context.Context, id string) ApiQuickbooksDesktopEmployeesIdPostRequest {
	return ApiQuickbooksDesktopEmployeesIdPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdEmployee
func (a *DefaultAPIService) QuickbooksDesktopEmployeesIdPostExecute(r ApiQuickbooksDesktopEmployeesIdPostRequest) (*QbdEmployee, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdEmployee
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopEmployeesIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/employees/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopEmployeesIdPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopEmployeesPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	quickbooksDesktopEmployeesPostRequest *QuickbooksDesktopEmployeesPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopEmployeesPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopEmployeesPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopEmployeesPostRequest) QuickbooksDesktopEmployeesPostRequest(quickbooksDesktopEmployeesPostRequest QuickbooksDesktopEmployeesPostRequest) ApiQuickbooksDesktopEmployeesPostRequest {
	r.quickbooksDesktopEmployeesPostRequest = &quickbooksDesktopEmployeesPostRequest
	return r
}

func (r ApiQuickbooksDesktopEmployeesPostRequest) Execute() (*QbdEmployee, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopEmployeesPostExecute(r)
}

/*
QuickbooksDesktopEmployeesPost Create an employee

Creates a new employee.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopEmployeesPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopEmployeesPost(ctx context.Context) ApiQuickbooksDesktopEmployeesPostRequest {
	return ApiQuickbooksDesktopEmployeesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QbdEmployee
func (a *DefaultAPIService) QuickbooksDesktopEmployeesPostExecute(r ApiQuickbooksDesktopEmployeesPostRequest) (*QbdEmployee, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdEmployee
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopEmployeesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/employees"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopEmployeesPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopEstimatesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	ids *[]string
	refNumbers *[]string
	limit *int32
	cursor *string
	updatedAfter *string
	updatedBefore *string
	transactionDateFrom *string
	transactionDateTo *string
	customerIds *[]string
	accountIds *[]string
	refNumberContains *string
	refNumberStartsWith *string
	refNumberEndsWith *string
	refNumberFrom *string
	refNumberTo *string
	currencyIds *[]string
	includeLineItems *bool
	includeLinkedTransactions *bool
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopEstimatesGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopEstimatesGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

// Filter for specific estimates by their QuickBooks-assigned unique identifier(s).  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopEstimatesGetRequest) Ids(ids []string) ApiQuickbooksDesktopEstimatesGetRequest {
	r.ids = &ids
	return r
}

// Filter for specific estimates by their ref-number(s), case-sensitive. In QuickBooks, ref-numbers are not required to be unique and can be arbitrarily changed by the QuickBooks user.  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopEstimatesGetRequest) RefNumbers(refNumbers []string) ApiQuickbooksDesktopEstimatesGetRequest {
	r.refNumbers = &refNumbers
	return r
}

// The maximum number of objects to return. Accepts values ranging from 1 to 150, defaults to 150. When used with cursor-based pagination, this parameter controls how many results are returned per page. To paginate through results, combine this with the &#x60;cursor&#x60; parameter. Each response will include a &#x60;nextCursor&#x60; value that can be passed to subsequent requests to retrieve the next page of results.
func (r ApiQuickbooksDesktopEstimatesGetRequest) Limit(limit int32) ApiQuickbooksDesktopEstimatesGetRequest {
	r.limit = &limit
	return r
}

// The pagination token to fetch the next set of results when paginating with the &#x60;limit&#x60; parameter. Do not include this parameter on the first call. Use the &#x60;nextCursor&#x60; value returned in the previous response to request subsequent results.
func (r ApiQuickbooksDesktopEstimatesGetRequest) Cursor(cursor string) ApiQuickbooksDesktopEstimatesGetRequest {
	r.cursor = &cursor
	return r
}

// Filter for estimates updated on or after this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 00:00:00 of that day.
func (r ApiQuickbooksDesktopEstimatesGetRequest) UpdatedAfter(updatedAfter string) ApiQuickbooksDesktopEstimatesGetRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Filter for estimates updated on or before this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 23:59:59 of that day.
func (r ApiQuickbooksDesktopEstimatesGetRequest) UpdatedBefore(updatedBefore string) ApiQuickbooksDesktopEstimatesGetRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Filter for estimates whose &#x60;date&#x60; field is on or after this date, in ISO 8601 format (YYYY-MM-DD).
func (r ApiQuickbooksDesktopEstimatesGetRequest) TransactionDateFrom(transactionDateFrom string) ApiQuickbooksDesktopEstimatesGetRequest {
	r.transactionDateFrom = &transactionDateFrom
	return r
}

// Filter for estimates whose &#x60;date&#x60; field is on or before this date, in ISO 8601 format (YYYY-MM-DD).
func (r ApiQuickbooksDesktopEstimatesGetRequest) TransactionDateTo(transactionDateTo string) ApiQuickbooksDesktopEstimatesGetRequest {
	r.transactionDateTo = &transactionDateTo
	return r
}

// Filter for estimates created for these customers.
func (r ApiQuickbooksDesktopEstimatesGetRequest) CustomerIds(customerIds []string) ApiQuickbooksDesktopEstimatesGetRequest {
	r.customerIds = &customerIds
	return r
}

// Filter for estimates associated with these accounts.
func (r ApiQuickbooksDesktopEstimatesGetRequest) AccountIds(accountIds []string) ApiQuickbooksDesktopEstimatesGetRequest {
	r.accountIds = &accountIds
	return r
}

// Filter for estimates whose &#x60;refNumber&#x60; contains this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberStartsWith&#x60; or &#x60;refNumberEndsWith&#x60;.
func (r ApiQuickbooksDesktopEstimatesGetRequest) RefNumberContains(refNumberContains string) ApiQuickbooksDesktopEstimatesGetRequest {
	r.refNumberContains = &refNumberContains
	return r
}

// Filter for estimates whose &#x60;refNumber&#x60; starts with this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberContains&#x60; or &#x60;refNumberEndsWith&#x60;.
func (r ApiQuickbooksDesktopEstimatesGetRequest) RefNumberStartsWith(refNumberStartsWith string) ApiQuickbooksDesktopEstimatesGetRequest {
	r.refNumberStartsWith = &refNumberStartsWith
	return r
}

// Filter for estimates whose &#x60;refNumber&#x60; ends with this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberContains&#x60; or &#x60;refNumberStartsWith&#x60;.
func (r ApiQuickbooksDesktopEstimatesGetRequest) RefNumberEndsWith(refNumberEndsWith string) ApiQuickbooksDesktopEstimatesGetRequest {
	r.refNumberEndsWith = &refNumberEndsWith
	return r
}

// Filter for estimates whose &#x60;refNumber&#x60; is greater than or equal to this value. If omitted, the range will begin with the first number of the list. Uses a numerical comparison for values that contain only digits; otherwise, uses a lexicographical comparison.
func (r ApiQuickbooksDesktopEstimatesGetRequest) RefNumberFrom(refNumberFrom string) ApiQuickbooksDesktopEstimatesGetRequest {
	r.refNumberFrom = &refNumberFrom
	return r
}

// Filter for estimates whose &#x60;refNumber&#x60; is less than or equal to this value. If omitted, the range will end with the last number of the list. Uses a numerical comparison for values that contain only digits; otherwise, uses a lexicographical comparison.
func (r ApiQuickbooksDesktopEstimatesGetRequest) RefNumberTo(refNumberTo string) ApiQuickbooksDesktopEstimatesGetRequest {
	r.refNumberTo = &refNumberTo
	return r
}

// Filter for estimates in these currencies.
func (r ApiQuickbooksDesktopEstimatesGetRequest) CurrencyIds(currencyIds []string) ApiQuickbooksDesktopEstimatesGetRequest {
	r.currencyIds = &currencyIds
	return r
}

// Whether to include line items in the response. Defaults to &#x60;true&#x60;.
func (r ApiQuickbooksDesktopEstimatesGetRequest) IncludeLineItems(includeLineItems bool) ApiQuickbooksDesktopEstimatesGetRequest {
	r.includeLineItems = &includeLineItems
	return r
}

// Whether to include linked transactions in the response. Defaults to &#x60;false&#x60;. For example, a payment linked to the corresponding estimate.
func (r ApiQuickbooksDesktopEstimatesGetRequest) IncludeLinkedTransactions(includeLinkedTransactions bool) ApiQuickbooksDesktopEstimatesGetRequest {
	r.includeLinkedTransactions = &includeLinkedTransactions
	return r
}

func (r ApiQuickbooksDesktopEstimatesGetRequest) Execute() (*QuickbooksDesktopEstimatesGet200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopEstimatesGetExecute(r)
}

/*
QuickbooksDesktopEstimatesGet List all estimates

Returns a list of estimates. Use the `cursor` parameter to paginate through the results.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopEstimatesGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopEstimatesGet(ctx context.Context) ApiQuickbooksDesktopEstimatesGetRequest {
	return ApiQuickbooksDesktopEstimatesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopEstimatesGet200Response
func (a *DefaultAPIService) QuickbooksDesktopEstimatesGetExecute(r ApiQuickbooksDesktopEstimatesGetRequest) (*QuickbooksDesktopEstimatesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopEstimatesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopEstimatesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/estimates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.refNumbers != nil {
		t := *r.refNumbers
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "refNumbers", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "refNumbers", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 150
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.transactionDateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDateFrom", r.transactionDateFrom, "form", "")
	}
	if r.transactionDateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDateTo", r.transactionDateTo, "form", "")
	}
	if r.customerIds != nil {
		t := *r.customerIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "customerIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "customerIds", t, "form", "multi")
		}
	}
	if r.accountIds != nil {
		t := *r.accountIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountIds", t, "form", "multi")
		}
	}
	if r.refNumberContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberContains", r.refNumberContains, "form", "")
	}
	if r.refNumberStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberStartsWith", r.refNumberStartsWith, "form", "")
	}
	if r.refNumberEndsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberEndsWith", r.refNumberEndsWith, "form", "")
	}
	if r.refNumberFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberFrom", r.refNumberFrom, "form", "")
	}
	if r.refNumberTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberTo", r.refNumberTo, "form", "")
	}
	if r.currencyIds != nil {
		t := *r.currencyIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", t, "form", "multi")
		}
	}
	if r.includeLineItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLineItems", r.includeLineItems, "form", "")
	} else {
		var defaultValue bool = true
		r.includeLineItems = &defaultValue
	}
	if r.includeLinkedTransactions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLinkedTransactions", r.includeLinkedTransactions, "form", "")
	} else {
		var defaultValue bool = false
		r.includeLinkedTransactions = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopEstimatesIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopEstimatesIdDeleteRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopEstimatesIdDeleteRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopEstimatesIdDeleteRequest) Execute() (*QuickbooksDesktopEstimatesIdDelete200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopEstimatesIdDeleteExecute(r)
}

/*
QuickbooksDesktopEstimatesIdDelete Delete an estimate

Permanently deletes a an estimate. The deletion will fail if the estimate is currently in use or has any linked transactions that are in use.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the estimate to delete.
 @return ApiQuickbooksDesktopEstimatesIdDeleteRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopEstimatesIdDelete(ctx context.Context, id string) ApiQuickbooksDesktopEstimatesIdDeleteRequest {
	return ApiQuickbooksDesktopEstimatesIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopEstimatesIdDelete200Response
func (a *DefaultAPIService) QuickbooksDesktopEstimatesIdDeleteExecute(r ApiQuickbooksDesktopEstimatesIdDeleteRequest) (*QuickbooksDesktopEstimatesIdDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopEstimatesIdDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopEstimatesIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/estimates/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopEstimatesIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopEstimatesIdGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopEstimatesIdGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopEstimatesIdGetRequest) Execute() (*QbdEstimate, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopEstimatesIdGetExecute(r)
}

/*
QuickbooksDesktopEstimatesIdGet Retrieve an estimate

Retrieves an estimate by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the estimate to retrieve.
 @return ApiQuickbooksDesktopEstimatesIdGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopEstimatesIdGet(ctx context.Context, id string) ApiQuickbooksDesktopEstimatesIdGetRequest {
	return ApiQuickbooksDesktopEstimatesIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdEstimate
func (a *DefaultAPIService) QuickbooksDesktopEstimatesIdGetExecute(r ApiQuickbooksDesktopEstimatesIdGetRequest) (*QbdEstimate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdEstimate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopEstimatesIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/estimates/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopEstimatesIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
	quickbooksDesktopEstimatesIdPostRequest *QuickbooksDesktopEstimatesIdPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopEstimatesIdPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopEstimatesIdPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopEstimatesIdPostRequest) QuickbooksDesktopEstimatesIdPostRequest(quickbooksDesktopEstimatesIdPostRequest QuickbooksDesktopEstimatesIdPostRequest) ApiQuickbooksDesktopEstimatesIdPostRequest {
	r.quickbooksDesktopEstimatesIdPostRequest = &quickbooksDesktopEstimatesIdPostRequest
	return r
}

func (r ApiQuickbooksDesktopEstimatesIdPostRequest) Execute() (*QbdEstimate, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopEstimatesIdPostExecute(r)
}

/*
QuickbooksDesktopEstimatesIdPost Update an estimate

Updates an existing estimate.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the estimate to update.
 @return ApiQuickbooksDesktopEstimatesIdPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopEstimatesIdPost(ctx context.Context, id string) ApiQuickbooksDesktopEstimatesIdPostRequest {
	return ApiQuickbooksDesktopEstimatesIdPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdEstimate
func (a *DefaultAPIService) QuickbooksDesktopEstimatesIdPostExecute(r ApiQuickbooksDesktopEstimatesIdPostRequest) (*QbdEstimate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdEstimate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopEstimatesIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/estimates/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopEstimatesIdPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopEstimatesPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	quickbooksDesktopEstimatesPostRequest *QuickbooksDesktopEstimatesPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopEstimatesPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopEstimatesPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopEstimatesPostRequest) QuickbooksDesktopEstimatesPostRequest(quickbooksDesktopEstimatesPostRequest QuickbooksDesktopEstimatesPostRequest) ApiQuickbooksDesktopEstimatesPostRequest {
	r.quickbooksDesktopEstimatesPostRequest = &quickbooksDesktopEstimatesPostRequest
	return r
}

func (r ApiQuickbooksDesktopEstimatesPostRequest) Execute() (*QbdEstimate, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopEstimatesPostExecute(r)
}

/*
QuickbooksDesktopEstimatesPost Create an estimate

Creates a new estimate.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopEstimatesPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopEstimatesPost(ctx context.Context) ApiQuickbooksDesktopEstimatesPostRequest {
	return ApiQuickbooksDesktopEstimatesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QbdEstimate
func (a *DefaultAPIService) QuickbooksDesktopEstimatesPostExecute(r ApiQuickbooksDesktopEstimatesPostRequest) (*QbdEstimate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdEstimate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopEstimatesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/estimates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopEstimatesPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopHealthCheckGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopHealthCheckGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopHealthCheckGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopHealthCheckGetRequest) Execute() (*QuickbooksDesktopHealthCheckGet200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopHealthCheckGetExecute(r)
}

/*
QuickbooksDesktopHealthCheckGet Health check

Checks whether the specified QuickBooks Desktop connection is active and can process requests end-to-end. This is useful for showing a "connection status" indicator in your app. If an error occurs, the typical Conductor error response will be returned. As with any request to QuickBooks Desktop, the health check may fail if the application is not running, the wrong company file is open, or if a modal dialog is open. Timeout is 60 seconds.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopHealthCheckGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopHealthCheckGet(ctx context.Context) ApiQuickbooksDesktopHealthCheckGetRequest {
	return ApiQuickbooksDesktopHealthCheckGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopHealthCheckGet200Response
func (a *DefaultAPIService) QuickbooksDesktopHealthCheckGetExecute(r ApiQuickbooksDesktopHealthCheckGetRequest) (*QuickbooksDesktopHealthCheckGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopHealthCheckGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopHealthCheckGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/health-check"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopInventoryAdjustmentsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	ids *[]string
	refNumbers *[]string
	limit *int32
	updatedAfter *string
	updatedBefore *string
	transactionDateFrom *string
	transactionDateTo *string
	customerIds *[]string
	accountIds *[]string
	itemIds *[]string
	refNumberContains *string
	refNumberStartsWith *string
	refNumberEndsWith *string
	refNumberFrom *string
	refNumberTo *string
	includeLineItems *bool
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopInventoryAdjustmentsGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopInventoryAdjustmentsGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

// Filter for specific inventory adjustments by their QuickBooks-assigned unique identifier(s).  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopInventoryAdjustmentsGetRequest) Ids(ids []string) ApiQuickbooksDesktopInventoryAdjustmentsGetRequest {
	r.ids = &ids
	return r
}

// Filter for specific inventory adjustments by their ref-number(s), case-sensitive. In QuickBooks, ref-numbers are not required to be unique and can be arbitrarily changed by the QuickBooks user.  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopInventoryAdjustmentsGetRequest) RefNumbers(refNumbers []string) ApiQuickbooksDesktopInventoryAdjustmentsGetRequest {
	r.refNumbers = &refNumbers
	return r
}

// The maximum number of objects to return.  **IMPORTANT**: QuickBooks Desktop does not support cursor-based pagination for inventory adjustments. This parameter will limit the response size, but you cannot fetch subsequent results using a cursor. For pagination, use the name-range parameters instead (e.g., &#x60;nameFrom&#x3D;A&amp;nameTo&#x3D;B&#x60;).  When this parameter is omitted, the endpoint returns all inventory adjustments without limit, unlike paginated endpoints which default to 150 records. This is acceptable because inventory adjustments typically have low record counts.
func (r ApiQuickbooksDesktopInventoryAdjustmentsGetRequest) Limit(limit int32) ApiQuickbooksDesktopInventoryAdjustmentsGetRequest {
	r.limit = &limit
	return r
}

// Filter for inventory adjustments updated on or after this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 00:00:00 of that day.
func (r ApiQuickbooksDesktopInventoryAdjustmentsGetRequest) UpdatedAfter(updatedAfter string) ApiQuickbooksDesktopInventoryAdjustmentsGetRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Filter for inventory adjustments updated on or before this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 23:59:59 of that day.
func (r ApiQuickbooksDesktopInventoryAdjustmentsGetRequest) UpdatedBefore(updatedBefore string) ApiQuickbooksDesktopInventoryAdjustmentsGetRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Filter for inventory adjustments whose &#x60;date&#x60; field is on or after this date, in ISO 8601 format (YYYY-MM-DD).
func (r ApiQuickbooksDesktopInventoryAdjustmentsGetRequest) TransactionDateFrom(transactionDateFrom string) ApiQuickbooksDesktopInventoryAdjustmentsGetRequest {
	r.transactionDateFrom = &transactionDateFrom
	return r
}

// Filter for inventory adjustments whose &#x60;date&#x60; field is on or before this date, in ISO 8601 format (YYYY-MM-DD).
func (r ApiQuickbooksDesktopInventoryAdjustmentsGetRequest) TransactionDateTo(transactionDateTo string) ApiQuickbooksDesktopInventoryAdjustmentsGetRequest {
	r.transactionDateTo = &transactionDateTo
	return r
}

// Filter for inventory adjustments associated with these customers.
func (r ApiQuickbooksDesktopInventoryAdjustmentsGetRequest) CustomerIds(customerIds []string) ApiQuickbooksDesktopInventoryAdjustmentsGetRequest {
	r.customerIds = &customerIds
	return r
}

// Filter for inventory adjustments associated with these accounts.
func (r ApiQuickbooksDesktopInventoryAdjustmentsGetRequest) AccountIds(accountIds []string) ApiQuickbooksDesktopInventoryAdjustmentsGetRequest {
	r.accountIds = &accountIds
	return r
}

// Filter for inventory adjustments containing these inventory items.
func (r ApiQuickbooksDesktopInventoryAdjustmentsGetRequest) ItemIds(itemIds []string) ApiQuickbooksDesktopInventoryAdjustmentsGetRequest {
	r.itemIds = &itemIds
	return r
}

// Filter for inventory adjustments whose &#x60;refNumber&#x60; contains this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberStartsWith&#x60; or &#x60;refNumberEndsWith&#x60;.
func (r ApiQuickbooksDesktopInventoryAdjustmentsGetRequest) RefNumberContains(refNumberContains string) ApiQuickbooksDesktopInventoryAdjustmentsGetRequest {
	r.refNumberContains = &refNumberContains
	return r
}

// Filter for inventory adjustments whose &#x60;refNumber&#x60; starts with this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberContains&#x60; or &#x60;refNumberEndsWith&#x60;.
func (r ApiQuickbooksDesktopInventoryAdjustmentsGetRequest) RefNumberStartsWith(refNumberStartsWith string) ApiQuickbooksDesktopInventoryAdjustmentsGetRequest {
	r.refNumberStartsWith = &refNumberStartsWith
	return r
}

// Filter for inventory adjustments whose &#x60;refNumber&#x60; ends with this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberContains&#x60; or &#x60;refNumberStartsWith&#x60;.
func (r ApiQuickbooksDesktopInventoryAdjustmentsGetRequest) RefNumberEndsWith(refNumberEndsWith string) ApiQuickbooksDesktopInventoryAdjustmentsGetRequest {
	r.refNumberEndsWith = &refNumberEndsWith
	return r
}

// Filter for inventory adjustments whose &#x60;refNumber&#x60; is greater than or equal to this value. If omitted, the range will begin with the first number of the list. Uses a numerical comparison for values that contain only digits; otherwise, uses a lexicographical comparison.
func (r ApiQuickbooksDesktopInventoryAdjustmentsGetRequest) RefNumberFrom(refNumberFrom string) ApiQuickbooksDesktopInventoryAdjustmentsGetRequest {
	r.refNumberFrom = &refNumberFrom
	return r
}

// Filter for inventory adjustments whose &#x60;refNumber&#x60; is less than or equal to this value. If omitted, the range will end with the last number of the list. Uses a numerical comparison for values that contain only digits; otherwise, uses a lexicographical comparison.
func (r ApiQuickbooksDesktopInventoryAdjustmentsGetRequest) RefNumberTo(refNumberTo string) ApiQuickbooksDesktopInventoryAdjustmentsGetRequest {
	r.refNumberTo = &refNumberTo
	return r
}

// Whether to include line items in the response. Defaults to &#x60;true&#x60;.
func (r ApiQuickbooksDesktopInventoryAdjustmentsGetRequest) IncludeLineItems(includeLineItems bool) ApiQuickbooksDesktopInventoryAdjustmentsGetRequest {
	r.includeLineItems = &includeLineItems
	return r
}

func (r ApiQuickbooksDesktopInventoryAdjustmentsGetRequest) Execute() (*QuickbooksDesktopInventoryAdjustmentsGet200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopInventoryAdjustmentsGetExecute(r)
}

/*
QuickbooksDesktopInventoryAdjustmentsGet List all inventory adjustments

Returns a list of inventory adjustments. NOTE: QuickBooks Desktop does not support pagination for inventory adjustments; hence, there is no `cursor` parameter. Users typically have few inventory adjustments.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopInventoryAdjustmentsGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopInventoryAdjustmentsGet(ctx context.Context) ApiQuickbooksDesktopInventoryAdjustmentsGetRequest {
	return ApiQuickbooksDesktopInventoryAdjustmentsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopInventoryAdjustmentsGet200Response
func (a *DefaultAPIService) QuickbooksDesktopInventoryAdjustmentsGetExecute(r ApiQuickbooksDesktopInventoryAdjustmentsGetRequest) (*QuickbooksDesktopInventoryAdjustmentsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopInventoryAdjustmentsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopInventoryAdjustmentsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/inventory-adjustments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.refNumbers != nil {
		t := *r.refNumbers
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "refNumbers", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "refNumbers", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.transactionDateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDateFrom", r.transactionDateFrom, "form", "")
	}
	if r.transactionDateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDateTo", r.transactionDateTo, "form", "")
	}
	if r.customerIds != nil {
		t := *r.customerIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "customerIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "customerIds", t, "form", "multi")
		}
	}
	if r.accountIds != nil {
		t := *r.accountIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountIds", t, "form", "multi")
		}
	}
	if r.itemIds != nil {
		t := *r.itemIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "itemIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "itemIds", t, "form", "multi")
		}
	}
	if r.refNumberContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberContains", r.refNumberContains, "form", "")
	}
	if r.refNumberStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberStartsWith", r.refNumberStartsWith, "form", "")
	}
	if r.refNumberEndsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberEndsWith", r.refNumberEndsWith, "form", "")
	}
	if r.refNumberFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberFrom", r.refNumberFrom, "form", "")
	}
	if r.refNumberTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberTo", r.refNumberTo, "form", "")
	}
	if r.includeLineItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLineItems", r.includeLineItems, "form", "")
	} else {
		var defaultValue bool = true
		r.includeLineItems = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopInventoryAdjustmentsIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopInventoryAdjustmentsIdDeleteRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopInventoryAdjustmentsIdDeleteRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopInventoryAdjustmentsIdDeleteRequest) Execute() (*QuickbooksDesktopInventoryAdjustmentsIdDelete200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopInventoryAdjustmentsIdDeleteExecute(r)
}

/*
QuickbooksDesktopInventoryAdjustmentsIdDelete Delete an inventory adjustment

Permanently deletes a an inventory adjustment. The deletion will fail if the inventory adjustment is currently in use or has any linked transactions that are in use.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the inventory adjustment to delete.
 @return ApiQuickbooksDesktopInventoryAdjustmentsIdDeleteRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopInventoryAdjustmentsIdDelete(ctx context.Context, id string) ApiQuickbooksDesktopInventoryAdjustmentsIdDeleteRequest {
	return ApiQuickbooksDesktopInventoryAdjustmentsIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopInventoryAdjustmentsIdDelete200Response
func (a *DefaultAPIService) QuickbooksDesktopInventoryAdjustmentsIdDeleteExecute(r ApiQuickbooksDesktopInventoryAdjustmentsIdDeleteRequest) (*QuickbooksDesktopInventoryAdjustmentsIdDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopInventoryAdjustmentsIdDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopInventoryAdjustmentsIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/inventory-adjustments/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopInventoryAdjustmentsIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopInventoryAdjustmentsIdGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopInventoryAdjustmentsIdGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopInventoryAdjustmentsIdGetRequest) Execute() (*QbdInventoryAdjustment, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopInventoryAdjustmentsIdGetExecute(r)
}

/*
QuickbooksDesktopInventoryAdjustmentsIdGet Retrieve an inventory adjustment

Retrieves an inventory adjustment by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the inventory adjustment to retrieve.
 @return ApiQuickbooksDesktopInventoryAdjustmentsIdGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopInventoryAdjustmentsIdGet(ctx context.Context, id string) ApiQuickbooksDesktopInventoryAdjustmentsIdGetRequest {
	return ApiQuickbooksDesktopInventoryAdjustmentsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdInventoryAdjustment
func (a *DefaultAPIService) QuickbooksDesktopInventoryAdjustmentsIdGetExecute(r ApiQuickbooksDesktopInventoryAdjustmentsIdGetRequest) (*QbdInventoryAdjustment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdInventoryAdjustment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopInventoryAdjustmentsIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/inventory-adjustments/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopInventoryAdjustmentsIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
	quickbooksDesktopInventoryAdjustmentsIdPostRequest *QuickbooksDesktopInventoryAdjustmentsIdPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopInventoryAdjustmentsIdPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopInventoryAdjustmentsIdPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopInventoryAdjustmentsIdPostRequest) QuickbooksDesktopInventoryAdjustmentsIdPostRequest(quickbooksDesktopInventoryAdjustmentsIdPostRequest QuickbooksDesktopInventoryAdjustmentsIdPostRequest) ApiQuickbooksDesktopInventoryAdjustmentsIdPostRequest {
	r.quickbooksDesktopInventoryAdjustmentsIdPostRequest = &quickbooksDesktopInventoryAdjustmentsIdPostRequest
	return r
}

func (r ApiQuickbooksDesktopInventoryAdjustmentsIdPostRequest) Execute() (*QbdInventoryAdjustment, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopInventoryAdjustmentsIdPostExecute(r)
}

/*
QuickbooksDesktopInventoryAdjustmentsIdPost Update an inventory adjustment

Updates an existing inventory adjustment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the inventory adjustment to update.
 @return ApiQuickbooksDesktopInventoryAdjustmentsIdPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopInventoryAdjustmentsIdPost(ctx context.Context, id string) ApiQuickbooksDesktopInventoryAdjustmentsIdPostRequest {
	return ApiQuickbooksDesktopInventoryAdjustmentsIdPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdInventoryAdjustment
func (a *DefaultAPIService) QuickbooksDesktopInventoryAdjustmentsIdPostExecute(r ApiQuickbooksDesktopInventoryAdjustmentsIdPostRequest) (*QbdInventoryAdjustment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdInventoryAdjustment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopInventoryAdjustmentsIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/inventory-adjustments/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopInventoryAdjustmentsIdPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopInventoryAdjustmentsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	quickbooksDesktopInventoryAdjustmentsPostRequest *QuickbooksDesktopInventoryAdjustmentsPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopInventoryAdjustmentsPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopInventoryAdjustmentsPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopInventoryAdjustmentsPostRequest) QuickbooksDesktopInventoryAdjustmentsPostRequest(quickbooksDesktopInventoryAdjustmentsPostRequest QuickbooksDesktopInventoryAdjustmentsPostRequest) ApiQuickbooksDesktopInventoryAdjustmentsPostRequest {
	r.quickbooksDesktopInventoryAdjustmentsPostRequest = &quickbooksDesktopInventoryAdjustmentsPostRequest
	return r
}

func (r ApiQuickbooksDesktopInventoryAdjustmentsPostRequest) Execute() (*QbdInventoryAdjustment, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopInventoryAdjustmentsPostExecute(r)
}

/*
QuickbooksDesktopInventoryAdjustmentsPost Create an inventory adjustment

Creates a new inventory adjustment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopInventoryAdjustmentsPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopInventoryAdjustmentsPost(ctx context.Context) ApiQuickbooksDesktopInventoryAdjustmentsPostRequest {
	return ApiQuickbooksDesktopInventoryAdjustmentsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QbdInventoryAdjustment
func (a *DefaultAPIService) QuickbooksDesktopInventoryAdjustmentsPostExecute(r ApiQuickbooksDesktopInventoryAdjustmentsPostRequest) (*QbdInventoryAdjustment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdInventoryAdjustment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopInventoryAdjustmentsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/inventory-adjustments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopInventoryAdjustmentsPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopInventoryAssemblyItemsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	ids *[]string
	fullNames *[]string
	limit *int32
	cursor *string
	status *string
	updatedAfter *string
	updatedBefore *string
	nameContains *string
	nameStartsWith *string
	nameEndsWith *string
	nameFrom *string
	nameTo *string
	classIds *[]string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopInventoryAssemblyItemsGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopInventoryAssemblyItemsGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

// Filter for specific inventory assembly items by their QuickBooks-assigned unique identifier(s).  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopInventoryAssemblyItemsGetRequest) Ids(ids []string) ApiQuickbooksDesktopInventoryAssemblyItemsGetRequest {
	r.ids = &ids
	return r
}

// Filter for specific inventory assembly items by their full-name(s), case-insensitive. Like &#x60;id&#x60;, &#x60;fullName&#x60; is a unique identifier for an inventory assembly item, formed by by combining the names of its parent objects with its own &#x60;name&#x60;, separated by colons. For example, if an inventory assembly item is under \&quot;Assemblies\&quot; and has the &#x60;name&#x60; \&quot;Deluxe Kit\&quot;, its &#x60;fullName&#x60; would be \&quot;Assemblies:Deluxe Kit\&quot;.  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopInventoryAssemblyItemsGetRequest) FullNames(fullNames []string) ApiQuickbooksDesktopInventoryAssemblyItemsGetRequest {
	r.fullNames = &fullNames
	return r
}

// The maximum number of objects to return. Accepts values ranging from 1 to 150, defaults to 150. When used with cursor-based pagination, this parameter controls how many results are returned per page. To paginate through results, combine this with the &#x60;cursor&#x60; parameter. Each response will include a &#x60;nextCursor&#x60; value that can be passed to subsequent requests to retrieve the next page of results.
func (r ApiQuickbooksDesktopInventoryAssemblyItemsGetRequest) Limit(limit int32) ApiQuickbooksDesktopInventoryAssemblyItemsGetRequest {
	r.limit = &limit
	return r
}

// The pagination token to fetch the next set of results when paginating with the &#x60;limit&#x60; parameter. Do not include this parameter on the first call. Use the &#x60;nextCursor&#x60; value returned in the previous response to request subsequent results.
func (r ApiQuickbooksDesktopInventoryAssemblyItemsGetRequest) Cursor(cursor string) ApiQuickbooksDesktopInventoryAssemblyItemsGetRequest {
	r.cursor = &cursor
	return r
}

// Filter for inventory assembly items that are active, inactive, or both.
func (r ApiQuickbooksDesktopInventoryAssemblyItemsGetRequest) Status(status string) ApiQuickbooksDesktopInventoryAssemblyItemsGetRequest {
	r.status = &status
	return r
}

// Filter for inventory assembly items updated on or after this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 00:00:00 of that day.  **WARNING**: Due to a known issue in QuickBooks Desktop, the &#x60;updatedAfter&#x60; parameter may not correctly filter inventory assembly items by their updated dates. To accurately retrieve the desired inventory assembly items, we recommend avoiding this parameter and instead fetching a broader dataset, then filtering the results locally using the &#x60;updatedAt&#x60; property.
func (r ApiQuickbooksDesktopInventoryAssemblyItemsGetRequest) UpdatedAfter(updatedAfter string) ApiQuickbooksDesktopInventoryAssemblyItemsGetRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Filter for inventory assembly items updated on or before this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 23:59:59 of that day.  **WARNING**: Due to a known issue in QuickBooks Desktop, the &#x60;updatedBefore&#x60; parameter may not correctly filter inventory assembly items by their updated dates. To accurately retrieve the desired inventory assembly items, we recommend avoiding this parameter and instead fetching a broader dataset, then filtering the results locally using the &#x60;updatedAt&#x60; property.
func (r ApiQuickbooksDesktopInventoryAssemblyItemsGetRequest) UpdatedBefore(updatedBefore string) ApiQuickbooksDesktopInventoryAssemblyItemsGetRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Filter for inventory assembly items whose &#x60;name&#x60; contains this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameStartsWith&#x60; or &#x60;nameEndsWith&#x60;.
func (r ApiQuickbooksDesktopInventoryAssemblyItemsGetRequest) NameContains(nameContains string) ApiQuickbooksDesktopInventoryAssemblyItemsGetRequest {
	r.nameContains = &nameContains
	return r
}

// Filter for inventory assembly items whose &#x60;name&#x60; starts with this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameContains&#x60; or &#x60;nameEndsWith&#x60;.
func (r ApiQuickbooksDesktopInventoryAssemblyItemsGetRequest) NameStartsWith(nameStartsWith string) ApiQuickbooksDesktopInventoryAssemblyItemsGetRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Filter for inventory assembly items whose &#x60;name&#x60; ends with this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameContains&#x60; or &#x60;nameStartsWith&#x60;.
func (r ApiQuickbooksDesktopInventoryAssemblyItemsGetRequest) NameEndsWith(nameEndsWith string) ApiQuickbooksDesktopInventoryAssemblyItemsGetRequest {
	r.nameEndsWith = &nameEndsWith
	return r
}

// Filter for inventory assembly items whose &#x60;name&#x60; is alphabetically greater than or equal to this value.
func (r ApiQuickbooksDesktopInventoryAssemblyItemsGetRequest) NameFrom(nameFrom string) ApiQuickbooksDesktopInventoryAssemblyItemsGetRequest {
	r.nameFrom = &nameFrom
	return r
}

// Filter for inventory assembly items whose &#x60;name&#x60; is alphabetically less than or equal to this value.
func (r ApiQuickbooksDesktopInventoryAssemblyItemsGetRequest) NameTo(nameTo string) ApiQuickbooksDesktopInventoryAssemblyItemsGetRequest {
	r.nameTo = &nameTo
	return r
}

// Filter for inventory assembly items of these classes. A class is a way end-users can categorize inventory assembly items in QuickBooks.
func (r ApiQuickbooksDesktopInventoryAssemblyItemsGetRequest) ClassIds(classIds []string) ApiQuickbooksDesktopInventoryAssemblyItemsGetRequest {
	r.classIds = &classIds
	return r
}

func (r ApiQuickbooksDesktopInventoryAssemblyItemsGetRequest) Execute() (*QuickbooksDesktopInventoryAssemblyItemsGet200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopInventoryAssemblyItemsGetExecute(r)
}

/*
QuickbooksDesktopInventoryAssemblyItemsGet List all inventory assembly items

Returns a list of inventory assembly items. Use the `cursor` parameter to paginate through the results.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopInventoryAssemblyItemsGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopInventoryAssemblyItemsGet(ctx context.Context) ApiQuickbooksDesktopInventoryAssemblyItemsGetRequest {
	return ApiQuickbooksDesktopInventoryAssemblyItemsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopInventoryAssemblyItemsGet200Response
func (a *DefaultAPIService) QuickbooksDesktopInventoryAssemblyItemsGetExecute(r ApiQuickbooksDesktopInventoryAssemblyItemsGetRequest) (*QuickbooksDesktopInventoryAssemblyItemsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopInventoryAssemblyItemsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopInventoryAssemblyItemsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/inventory-assembly-items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.fullNames != nil {
		t := *r.fullNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fullNames", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fullNames", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 150
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	} else {
		var defaultValue string = "active"
		r.status = &defaultValue
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.nameContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameContains", r.nameContains, "form", "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameStartsWith", r.nameStartsWith, "form", "")
	}
	if r.nameEndsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameEndsWith", r.nameEndsWith, "form", "")
	}
	if r.nameFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameFrom", r.nameFrom, "form", "")
	}
	if r.nameTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameTo", r.nameTo, "form", "")
	}
	if r.classIds != nil {
		t := *r.classIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "classIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "classIds", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopInventoryAssemblyItemsIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopInventoryAssemblyItemsIdGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopInventoryAssemblyItemsIdGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopInventoryAssemblyItemsIdGetRequest) Execute() (*QbdInventoryAssemblyItem, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopInventoryAssemblyItemsIdGetExecute(r)
}

/*
QuickbooksDesktopInventoryAssemblyItemsIdGet Retrieve an inventory assembly item

Retrieves an inventory assembly item by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the inventory assembly item to retrieve.
 @return ApiQuickbooksDesktopInventoryAssemblyItemsIdGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopInventoryAssemblyItemsIdGet(ctx context.Context, id string) ApiQuickbooksDesktopInventoryAssemblyItemsIdGetRequest {
	return ApiQuickbooksDesktopInventoryAssemblyItemsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdInventoryAssemblyItem
func (a *DefaultAPIService) QuickbooksDesktopInventoryAssemblyItemsIdGetExecute(r ApiQuickbooksDesktopInventoryAssemblyItemsIdGetRequest) (*QbdInventoryAssemblyItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdInventoryAssemblyItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopInventoryAssemblyItemsIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/inventory-assembly-items/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopInventoryAssemblyItemsIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
	quickbooksDesktopInventoryAssemblyItemsIdPostRequest *QuickbooksDesktopInventoryAssemblyItemsIdPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopInventoryAssemblyItemsIdPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopInventoryAssemblyItemsIdPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopInventoryAssemblyItemsIdPostRequest) QuickbooksDesktopInventoryAssemblyItemsIdPostRequest(quickbooksDesktopInventoryAssemblyItemsIdPostRequest QuickbooksDesktopInventoryAssemblyItemsIdPostRequest) ApiQuickbooksDesktopInventoryAssemblyItemsIdPostRequest {
	r.quickbooksDesktopInventoryAssemblyItemsIdPostRequest = &quickbooksDesktopInventoryAssemblyItemsIdPostRequest
	return r
}

func (r ApiQuickbooksDesktopInventoryAssemblyItemsIdPostRequest) Execute() (*QbdInventoryAssemblyItem, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopInventoryAssemblyItemsIdPostExecute(r)
}

/*
QuickbooksDesktopInventoryAssemblyItemsIdPost Update an inventory assembly item

Updates an existing inventory assembly item.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the inventory assembly item to update.
 @return ApiQuickbooksDesktopInventoryAssemblyItemsIdPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopInventoryAssemblyItemsIdPost(ctx context.Context, id string) ApiQuickbooksDesktopInventoryAssemblyItemsIdPostRequest {
	return ApiQuickbooksDesktopInventoryAssemblyItemsIdPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdInventoryAssemblyItem
func (a *DefaultAPIService) QuickbooksDesktopInventoryAssemblyItemsIdPostExecute(r ApiQuickbooksDesktopInventoryAssemblyItemsIdPostRequest) (*QbdInventoryAssemblyItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdInventoryAssemblyItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopInventoryAssemblyItemsIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/inventory-assembly-items/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopInventoryAssemblyItemsIdPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopInventoryAssemblyItemsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	quickbooksDesktopInventoryAssemblyItemsPostRequest *QuickbooksDesktopInventoryAssemblyItemsPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopInventoryAssemblyItemsPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopInventoryAssemblyItemsPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopInventoryAssemblyItemsPostRequest) QuickbooksDesktopInventoryAssemblyItemsPostRequest(quickbooksDesktopInventoryAssemblyItemsPostRequest QuickbooksDesktopInventoryAssemblyItemsPostRequest) ApiQuickbooksDesktopInventoryAssemblyItemsPostRequest {
	r.quickbooksDesktopInventoryAssemblyItemsPostRequest = &quickbooksDesktopInventoryAssemblyItemsPostRequest
	return r
}

func (r ApiQuickbooksDesktopInventoryAssemblyItemsPostRequest) Execute() (*QbdInventoryAssemblyItem, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopInventoryAssemblyItemsPostExecute(r)
}

/*
QuickbooksDesktopInventoryAssemblyItemsPost Create an inventory assembly item

Creates a new inventory assembly item.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopInventoryAssemblyItemsPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopInventoryAssemblyItemsPost(ctx context.Context) ApiQuickbooksDesktopInventoryAssemblyItemsPostRequest {
	return ApiQuickbooksDesktopInventoryAssemblyItemsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QbdInventoryAssemblyItem
func (a *DefaultAPIService) QuickbooksDesktopInventoryAssemblyItemsPostExecute(r ApiQuickbooksDesktopInventoryAssemblyItemsPostRequest) (*QbdInventoryAssemblyItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdInventoryAssemblyItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopInventoryAssemblyItemsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/inventory-assembly-items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopInventoryAssemblyItemsPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopInventoryItemsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	ids *[]string
	fullNames *[]string
	limit *int32
	cursor *string
	status *string
	updatedAfter *string
	updatedBefore *string
	nameContains *string
	nameStartsWith *string
	nameEndsWith *string
	nameFrom *string
	nameTo *string
	classIds *[]string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopInventoryItemsGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopInventoryItemsGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

// Filter for specific inventory items by their QuickBooks-assigned unique identifier(s).  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopInventoryItemsGetRequest) Ids(ids []string) ApiQuickbooksDesktopInventoryItemsGetRequest {
	r.ids = &ids
	return r
}

// Filter for specific inventory items by their full-name(s), case-insensitive. Like &#x60;id&#x60;, &#x60;fullName&#x60; is a unique identifier for an inventory item, formed by by combining the names of its parent objects with its own &#x60;name&#x60;, separated by colons. For example, if an inventory item is under \&quot;Kitchen\&quot; and has the &#x60;name&#x60; \&quot;Cabinet\&quot;, its &#x60;fullName&#x60; would be \&quot;Kitchen:Cabinet\&quot;.  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopInventoryItemsGetRequest) FullNames(fullNames []string) ApiQuickbooksDesktopInventoryItemsGetRequest {
	r.fullNames = &fullNames
	return r
}

// The maximum number of objects to return. Accepts values ranging from 1 to 150, defaults to 150. When used with cursor-based pagination, this parameter controls how many results are returned per page. To paginate through results, combine this with the &#x60;cursor&#x60; parameter. Each response will include a &#x60;nextCursor&#x60; value that can be passed to subsequent requests to retrieve the next page of results.
func (r ApiQuickbooksDesktopInventoryItemsGetRequest) Limit(limit int32) ApiQuickbooksDesktopInventoryItemsGetRequest {
	r.limit = &limit
	return r
}

// The pagination token to fetch the next set of results when paginating with the &#x60;limit&#x60; parameter. Do not include this parameter on the first call. Use the &#x60;nextCursor&#x60; value returned in the previous response to request subsequent results.
func (r ApiQuickbooksDesktopInventoryItemsGetRequest) Cursor(cursor string) ApiQuickbooksDesktopInventoryItemsGetRequest {
	r.cursor = &cursor
	return r
}

// Filter for inventory items that are active, inactive, or both.
func (r ApiQuickbooksDesktopInventoryItemsGetRequest) Status(status string) ApiQuickbooksDesktopInventoryItemsGetRequest {
	r.status = &status
	return r
}

// Filter for inventory items updated on or after this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 00:00:00 of that day.  **WARNING**: Due to a known issue in QuickBooks Desktop, the &#x60;updatedAfter&#x60; parameter may not correctly filter inventory items by their updated dates. To accurately retrieve the desired inventory items, we recommend avoiding this parameter and instead fetching a broader dataset, then filtering the results locally using the &#x60;updatedAt&#x60; property.
func (r ApiQuickbooksDesktopInventoryItemsGetRequest) UpdatedAfter(updatedAfter string) ApiQuickbooksDesktopInventoryItemsGetRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Filter for inventory items updated on or before this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 23:59:59 of that day.  **WARNING**: Due to a known issue in QuickBooks Desktop, the &#x60;updatedBefore&#x60; parameter may not correctly filter inventory items by their updated dates. To accurately retrieve the desired inventory items, we recommend avoiding this parameter and instead fetching a broader dataset, then filtering the results locally using the &#x60;updatedAt&#x60; property.
func (r ApiQuickbooksDesktopInventoryItemsGetRequest) UpdatedBefore(updatedBefore string) ApiQuickbooksDesktopInventoryItemsGetRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Filter for inventory items whose &#x60;name&#x60; contains this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameStartsWith&#x60; or &#x60;nameEndsWith&#x60;.
func (r ApiQuickbooksDesktopInventoryItemsGetRequest) NameContains(nameContains string) ApiQuickbooksDesktopInventoryItemsGetRequest {
	r.nameContains = &nameContains
	return r
}

// Filter for inventory items whose &#x60;name&#x60; starts with this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameContains&#x60; or &#x60;nameEndsWith&#x60;.
func (r ApiQuickbooksDesktopInventoryItemsGetRequest) NameStartsWith(nameStartsWith string) ApiQuickbooksDesktopInventoryItemsGetRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Filter for inventory items whose &#x60;name&#x60; ends with this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameContains&#x60; or &#x60;nameStartsWith&#x60;.
func (r ApiQuickbooksDesktopInventoryItemsGetRequest) NameEndsWith(nameEndsWith string) ApiQuickbooksDesktopInventoryItemsGetRequest {
	r.nameEndsWith = &nameEndsWith
	return r
}

// Filter for inventory items whose &#x60;name&#x60; is alphabetically greater than or equal to this value.
func (r ApiQuickbooksDesktopInventoryItemsGetRequest) NameFrom(nameFrom string) ApiQuickbooksDesktopInventoryItemsGetRequest {
	r.nameFrom = &nameFrom
	return r
}

// Filter for inventory items whose &#x60;name&#x60; is alphabetically less than or equal to this value.
func (r ApiQuickbooksDesktopInventoryItemsGetRequest) NameTo(nameTo string) ApiQuickbooksDesktopInventoryItemsGetRequest {
	r.nameTo = &nameTo
	return r
}

// Filter for inventory items of these classes. A class is a way end-users can categorize inventory items in QuickBooks.
func (r ApiQuickbooksDesktopInventoryItemsGetRequest) ClassIds(classIds []string) ApiQuickbooksDesktopInventoryItemsGetRequest {
	r.classIds = &classIds
	return r
}

func (r ApiQuickbooksDesktopInventoryItemsGetRequest) Execute() (*QuickbooksDesktopInventoryItemsGet200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopInventoryItemsGetExecute(r)
}

/*
QuickbooksDesktopInventoryItemsGet List all inventory items

Returns a list of inventory items. Use the `cursor` parameter to paginate through the results.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopInventoryItemsGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopInventoryItemsGet(ctx context.Context) ApiQuickbooksDesktopInventoryItemsGetRequest {
	return ApiQuickbooksDesktopInventoryItemsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopInventoryItemsGet200Response
func (a *DefaultAPIService) QuickbooksDesktopInventoryItemsGetExecute(r ApiQuickbooksDesktopInventoryItemsGetRequest) (*QuickbooksDesktopInventoryItemsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopInventoryItemsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopInventoryItemsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/inventory-items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.fullNames != nil {
		t := *r.fullNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fullNames", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fullNames", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 150
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	} else {
		var defaultValue string = "active"
		r.status = &defaultValue
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.nameContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameContains", r.nameContains, "form", "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameStartsWith", r.nameStartsWith, "form", "")
	}
	if r.nameEndsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameEndsWith", r.nameEndsWith, "form", "")
	}
	if r.nameFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameFrom", r.nameFrom, "form", "")
	}
	if r.nameTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameTo", r.nameTo, "form", "")
	}
	if r.classIds != nil {
		t := *r.classIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "classIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "classIds", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopInventoryItemsIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopInventoryItemsIdGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopInventoryItemsIdGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopInventoryItemsIdGetRequest) Execute() (*QbdInventoryItem, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopInventoryItemsIdGetExecute(r)
}

/*
QuickbooksDesktopInventoryItemsIdGet Retrieve an inventory item

Retrieves an inventory item by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the inventory item to retrieve.
 @return ApiQuickbooksDesktopInventoryItemsIdGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopInventoryItemsIdGet(ctx context.Context, id string) ApiQuickbooksDesktopInventoryItemsIdGetRequest {
	return ApiQuickbooksDesktopInventoryItemsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdInventoryItem
func (a *DefaultAPIService) QuickbooksDesktopInventoryItemsIdGetExecute(r ApiQuickbooksDesktopInventoryItemsIdGetRequest) (*QbdInventoryItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdInventoryItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopInventoryItemsIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/inventory-items/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopInventoryItemsIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
	quickbooksDesktopInventoryItemsIdPostRequest *QuickbooksDesktopInventoryItemsIdPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopInventoryItemsIdPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopInventoryItemsIdPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopInventoryItemsIdPostRequest) QuickbooksDesktopInventoryItemsIdPostRequest(quickbooksDesktopInventoryItemsIdPostRequest QuickbooksDesktopInventoryItemsIdPostRequest) ApiQuickbooksDesktopInventoryItemsIdPostRequest {
	r.quickbooksDesktopInventoryItemsIdPostRequest = &quickbooksDesktopInventoryItemsIdPostRequest
	return r
}

func (r ApiQuickbooksDesktopInventoryItemsIdPostRequest) Execute() (*QbdInventoryItem, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopInventoryItemsIdPostExecute(r)
}

/*
QuickbooksDesktopInventoryItemsIdPost Update an inventory item

Updates an existing inventory item.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the inventory item to update.
 @return ApiQuickbooksDesktopInventoryItemsIdPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopInventoryItemsIdPost(ctx context.Context, id string) ApiQuickbooksDesktopInventoryItemsIdPostRequest {
	return ApiQuickbooksDesktopInventoryItemsIdPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdInventoryItem
func (a *DefaultAPIService) QuickbooksDesktopInventoryItemsIdPostExecute(r ApiQuickbooksDesktopInventoryItemsIdPostRequest) (*QbdInventoryItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdInventoryItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopInventoryItemsIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/inventory-items/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopInventoryItemsIdPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopInventoryItemsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	quickbooksDesktopInventoryItemsPostRequest *QuickbooksDesktopInventoryItemsPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopInventoryItemsPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopInventoryItemsPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopInventoryItemsPostRequest) QuickbooksDesktopInventoryItemsPostRequest(quickbooksDesktopInventoryItemsPostRequest QuickbooksDesktopInventoryItemsPostRequest) ApiQuickbooksDesktopInventoryItemsPostRequest {
	r.quickbooksDesktopInventoryItemsPostRequest = &quickbooksDesktopInventoryItemsPostRequest
	return r
}

func (r ApiQuickbooksDesktopInventoryItemsPostRequest) Execute() (*QbdInventoryItem, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopInventoryItemsPostExecute(r)
}

/*
QuickbooksDesktopInventoryItemsPost Create an inventory item

Creates a new inventory item.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopInventoryItemsPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopInventoryItemsPost(ctx context.Context) ApiQuickbooksDesktopInventoryItemsPostRequest {
	return ApiQuickbooksDesktopInventoryItemsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QbdInventoryItem
func (a *DefaultAPIService) QuickbooksDesktopInventoryItemsPostExecute(r ApiQuickbooksDesktopInventoryItemsPostRequest) (*QbdInventoryItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdInventoryItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopInventoryItemsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/inventory-items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopInventoryItemsPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopInventorySitesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	ids *[]string
	names *[]string
	status *string
	updatedAfter *string
	updatedBefore *string
	nameContains *string
	nameStartsWith *string
	nameEndsWith *string
	nameFrom *string
	nameTo *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopInventorySitesGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopInventorySitesGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

// Filter for specific inventory sites by their QuickBooks-assigned unique identifier(s).  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopInventorySitesGetRequest) Ids(ids []string) ApiQuickbooksDesktopInventorySitesGetRequest {
	r.ids = &ids
	return r
}

// Filter for specific inventory sites by their name(s), case-insensitive. Like &#x60;id&#x60;, &#x60;name&#x60; is a unique identifier for an inventory site.  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopInventorySitesGetRequest) Names(names []string) ApiQuickbooksDesktopInventorySitesGetRequest {
	r.names = &names
	return r
}

// Filter for inventory sites that are active, inactive, or both.
func (r ApiQuickbooksDesktopInventorySitesGetRequest) Status(status string) ApiQuickbooksDesktopInventorySitesGetRequest {
	r.status = &status
	return r
}

// Filter for inventory sites updated on or after this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 00:00:00 of that day.
func (r ApiQuickbooksDesktopInventorySitesGetRequest) UpdatedAfter(updatedAfter string) ApiQuickbooksDesktopInventorySitesGetRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Filter for inventory sites updated on or before this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 23:59:59 of that day.
func (r ApiQuickbooksDesktopInventorySitesGetRequest) UpdatedBefore(updatedBefore string) ApiQuickbooksDesktopInventorySitesGetRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Filter for inventory sites whose &#x60;name&#x60; contains this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameStartsWith&#x60; or &#x60;nameEndsWith&#x60;.
func (r ApiQuickbooksDesktopInventorySitesGetRequest) NameContains(nameContains string) ApiQuickbooksDesktopInventorySitesGetRequest {
	r.nameContains = &nameContains
	return r
}

// Filter for inventory sites whose &#x60;name&#x60; starts with this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameContains&#x60; or &#x60;nameEndsWith&#x60;.
func (r ApiQuickbooksDesktopInventorySitesGetRequest) NameStartsWith(nameStartsWith string) ApiQuickbooksDesktopInventorySitesGetRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Filter for inventory sites whose &#x60;name&#x60; ends with this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameContains&#x60; or &#x60;nameStartsWith&#x60;.
func (r ApiQuickbooksDesktopInventorySitesGetRequest) NameEndsWith(nameEndsWith string) ApiQuickbooksDesktopInventorySitesGetRequest {
	r.nameEndsWith = &nameEndsWith
	return r
}

// Filter for inventory sites whose &#x60;name&#x60; is alphabetically greater than or equal to this value.
func (r ApiQuickbooksDesktopInventorySitesGetRequest) NameFrom(nameFrom string) ApiQuickbooksDesktopInventorySitesGetRequest {
	r.nameFrom = &nameFrom
	return r
}

// Filter for inventory sites whose &#x60;name&#x60; is alphabetically less than or equal to this value.
func (r ApiQuickbooksDesktopInventorySitesGetRequest) NameTo(nameTo string) ApiQuickbooksDesktopInventorySitesGetRequest {
	r.nameTo = &nameTo
	return r
}

func (r ApiQuickbooksDesktopInventorySitesGetRequest) Execute() (*QuickbooksDesktopInventorySitesGet200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopInventorySitesGetExecute(r)
}

/*
QuickbooksDesktopInventorySitesGet List all inventory sites

Returns a list of inventory sites. NOTE: QuickBooks Desktop does not support pagination for inventory sites; hence, there is no `cursor` parameter. Users typically have few inventory sites.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopInventorySitesGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopInventorySitesGet(ctx context.Context) ApiQuickbooksDesktopInventorySitesGetRequest {
	return ApiQuickbooksDesktopInventorySitesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopInventorySitesGet200Response
func (a *DefaultAPIService) QuickbooksDesktopInventorySitesGetExecute(r ApiQuickbooksDesktopInventorySitesGetRequest) (*QuickbooksDesktopInventorySitesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopInventorySitesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopInventorySitesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/inventory-sites"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.names != nil {
		t := *r.names
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "names", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "names", t, "form", "multi")
		}
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	} else {
		var defaultValue string = "active"
		r.status = &defaultValue
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.nameContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameContains", r.nameContains, "form", "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameStartsWith", r.nameStartsWith, "form", "")
	}
	if r.nameEndsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameEndsWith", r.nameEndsWith, "form", "")
	}
	if r.nameFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameFrom", r.nameFrom, "form", "")
	}
	if r.nameTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameTo", r.nameTo, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopInventorySitesIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopInventorySitesIdGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopInventorySitesIdGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopInventorySitesIdGetRequest) Execute() (*QbdInventorySite, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopInventorySitesIdGetExecute(r)
}

/*
QuickbooksDesktopInventorySitesIdGet Retrieve an inventory site

Retrieves an inventory site by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the inventory site to retrieve.
 @return ApiQuickbooksDesktopInventorySitesIdGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopInventorySitesIdGet(ctx context.Context, id string) ApiQuickbooksDesktopInventorySitesIdGetRequest {
	return ApiQuickbooksDesktopInventorySitesIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdInventorySite
func (a *DefaultAPIService) QuickbooksDesktopInventorySitesIdGetExecute(r ApiQuickbooksDesktopInventorySitesIdGetRequest) (*QbdInventorySite, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdInventorySite
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopInventorySitesIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/inventory-sites/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopInventorySitesIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
	quickbooksDesktopInventorySitesIdPostRequest *QuickbooksDesktopInventorySitesIdPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopInventorySitesIdPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopInventorySitesIdPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopInventorySitesIdPostRequest) QuickbooksDesktopInventorySitesIdPostRequest(quickbooksDesktopInventorySitesIdPostRequest QuickbooksDesktopInventorySitesIdPostRequest) ApiQuickbooksDesktopInventorySitesIdPostRequest {
	r.quickbooksDesktopInventorySitesIdPostRequest = &quickbooksDesktopInventorySitesIdPostRequest
	return r
}

func (r ApiQuickbooksDesktopInventorySitesIdPostRequest) Execute() (*QbdInventorySite, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopInventorySitesIdPostExecute(r)
}

/*
QuickbooksDesktopInventorySitesIdPost Update an inventory site

Updates an existing inventory site.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the inventory site to update.
 @return ApiQuickbooksDesktopInventorySitesIdPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopInventorySitesIdPost(ctx context.Context, id string) ApiQuickbooksDesktopInventorySitesIdPostRequest {
	return ApiQuickbooksDesktopInventorySitesIdPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdInventorySite
func (a *DefaultAPIService) QuickbooksDesktopInventorySitesIdPostExecute(r ApiQuickbooksDesktopInventorySitesIdPostRequest) (*QbdInventorySite, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdInventorySite
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopInventorySitesIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/inventory-sites/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopInventorySitesIdPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopInventorySitesPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	quickbooksDesktopInventorySitesPostRequest *QuickbooksDesktopInventorySitesPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopInventorySitesPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopInventorySitesPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopInventorySitesPostRequest) QuickbooksDesktopInventorySitesPostRequest(quickbooksDesktopInventorySitesPostRequest QuickbooksDesktopInventorySitesPostRequest) ApiQuickbooksDesktopInventorySitesPostRequest {
	r.quickbooksDesktopInventorySitesPostRequest = &quickbooksDesktopInventorySitesPostRequest
	return r
}

func (r ApiQuickbooksDesktopInventorySitesPostRequest) Execute() (*QbdInventorySite, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopInventorySitesPostExecute(r)
}

/*
QuickbooksDesktopInventorySitesPost Create an inventory site

Creates a new inventory site.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopInventorySitesPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopInventorySitesPost(ctx context.Context) ApiQuickbooksDesktopInventorySitesPostRequest {
	return ApiQuickbooksDesktopInventorySitesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QbdInventorySite
func (a *DefaultAPIService) QuickbooksDesktopInventorySitesPostExecute(r ApiQuickbooksDesktopInventorySitesPostRequest) (*QbdInventorySite, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdInventorySite
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopInventorySitesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/inventory-sites"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopInventorySitesPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopInvoicesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	ids *[]string
	refNumbers *[]string
	limit *int32
	cursor *string
	updatedAfter *string
	updatedBefore *string
	transactionDateFrom *string
	transactionDateTo *string
	customerIds *[]string
	accountIds *[]string
	refNumberContains *string
	refNumberStartsWith *string
	refNumberEndsWith *string
	refNumberFrom *string
	refNumberTo *string
	currencyIds *[]string
	paymentStatus *string
	includeLineItems *bool
	includeLinkedTransactions *bool
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopInvoicesGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopInvoicesGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

// Filter for specific invoices by their QuickBooks-assigned unique identifier(s).  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopInvoicesGetRequest) Ids(ids []string) ApiQuickbooksDesktopInvoicesGetRequest {
	r.ids = &ids
	return r
}

// Filter for specific invoices by their ref-number(s), case-sensitive. In QuickBooks, ref-numbers are not required to be unique and can be arbitrarily changed by the QuickBooks user.  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopInvoicesGetRequest) RefNumbers(refNumbers []string) ApiQuickbooksDesktopInvoicesGetRequest {
	r.refNumbers = &refNumbers
	return r
}

// The maximum number of objects to return. Accepts values ranging from 1 to 150, defaults to 150. When used with cursor-based pagination, this parameter controls how many results are returned per page. To paginate through results, combine this with the &#x60;cursor&#x60; parameter. Each response will include a &#x60;nextCursor&#x60; value that can be passed to subsequent requests to retrieve the next page of results.
func (r ApiQuickbooksDesktopInvoicesGetRequest) Limit(limit int32) ApiQuickbooksDesktopInvoicesGetRequest {
	r.limit = &limit
	return r
}

// The pagination token to fetch the next set of results when paginating with the &#x60;limit&#x60; parameter. Do not include this parameter on the first call. Use the &#x60;nextCursor&#x60; value returned in the previous response to request subsequent results.
func (r ApiQuickbooksDesktopInvoicesGetRequest) Cursor(cursor string) ApiQuickbooksDesktopInvoicesGetRequest {
	r.cursor = &cursor
	return r
}

// Filter for invoices updated on or after this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 00:00:00 of that day.
func (r ApiQuickbooksDesktopInvoicesGetRequest) UpdatedAfter(updatedAfter string) ApiQuickbooksDesktopInvoicesGetRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Filter for invoices updated on or before this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 23:59:59 of that day.
func (r ApiQuickbooksDesktopInvoicesGetRequest) UpdatedBefore(updatedBefore string) ApiQuickbooksDesktopInvoicesGetRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Filter for invoices whose &#x60;date&#x60; field is on or after this date, in ISO 8601 format (YYYY-MM-DD).
func (r ApiQuickbooksDesktopInvoicesGetRequest) TransactionDateFrom(transactionDateFrom string) ApiQuickbooksDesktopInvoicesGetRequest {
	r.transactionDateFrom = &transactionDateFrom
	return r
}

// Filter for invoices whose &#x60;date&#x60; field is on or before this date, in ISO 8601 format (YYYY-MM-DD).
func (r ApiQuickbooksDesktopInvoicesGetRequest) TransactionDateTo(transactionDateTo string) ApiQuickbooksDesktopInvoicesGetRequest {
	r.transactionDateTo = &transactionDateTo
	return r
}

// Filter for invoices created for these customers.
func (r ApiQuickbooksDesktopInvoicesGetRequest) CustomerIds(customerIds []string) ApiQuickbooksDesktopInvoicesGetRequest {
	r.customerIds = &customerIds
	return r
}

// Filter for invoices associated with these accounts.
func (r ApiQuickbooksDesktopInvoicesGetRequest) AccountIds(accountIds []string) ApiQuickbooksDesktopInvoicesGetRequest {
	r.accountIds = &accountIds
	return r
}

// Filter for invoices whose &#x60;refNumber&#x60; contains this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberStartsWith&#x60; or &#x60;refNumberEndsWith&#x60;.
func (r ApiQuickbooksDesktopInvoicesGetRequest) RefNumberContains(refNumberContains string) ApiQuickbooksDesktopInvoicesGetRequest {
	r.refNumberContains = &refNumberContains
	return r
}

// Filter for invoices whose &#x60;refNumber&#x60; starts with this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberContains&#x60; or &#x60;refNumberEndsWith&#x60;.
func (r ApiQuickbooksDesktopInvoicesGetRequest) RefNumberStartsWith(refNumberStartsWith string) ApiQuickbooksDesktopInvoicesGetRequest {
	r.refNumberStartsWith = &refNumberStartsWith
	return r
}

// Filter for invoices whose &#x60;refNumber&#x60; ends with this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberContains&#x60; or &#x60;refNumberStartsWith&#x60;.
func (r ApiQuickbooksDesktopInvoicesGetRequest) RefNumberEndsWith(refNumberEndsWith string) ApiQuickbooksDesktopInvoicesGetRequest {
	r.refNumberEndsWith = &refNumberEndsWith
	return r
}

// Filter for invoices whose &#x60;refNumber&#x60; is greater than or equal to this value. If omitted, the range will begin with the first number of the list. Uses a numerical comparison for values that contain only digits; otherwise, uses a lexicographical comparison.
func (r ApiQuickbooksDesktopInvoicesGetRequest) RefNumberFrom(refNumberFrom string) ApiQuickbooksDesktopInvoicesGetRequest {
	r.refNumberFrom = &refNumberFrom
	return r
}

// Filter for invoices whose &#x60;refNumber&#x60; is less than or equal to this value. If omitted, the range will end with the last number of the list. Uses a numerical comparison for values that contain only digits; otherwise, uses a lexicographical comparison.
func (r ApiQuickbooksDesktopInvoicesGetRequest) RefNumberTo(refNumberTo string) ApiQuickbooksDesktopInvoicesGetRequest {
	r.refNumberTo = &refNumberTo
	return r
}

// Filter for invoices in these currencies.
func (r ApiQuickbooksDesktopInvoicesGetRequest) CurrencyIds(currencyIds []string) ApiQuickbooksDesktopInvoicesGetRequest {
	r.currencyIds = &currencyIds
	return r
}

// Filter for invoices that are paid, not paid, or both.
func (r ApiQuickbooksDesktopInvoicesGetRequest) PaymentStatus(paymentStatus string) ApiQuickbooksDesktopInvoicesGetRequest {
	r.paymentStatus = &paymentStatus
	return r
}

// Whether to include line items in the response. Defaults to &#x60;true&#x60;.
func (r ApiQuickbooksDesktopInvoicesGetRequest) IncludeLineItems(includeLineItems bool) ApiQuickbooksDesktopInvoicesGetRequest {
	r.includeLineItems = &includeLineItems
	return r
}

// Whether to include linked transactions in the response. Defaults to &#x60;false&#x60;. For example, a payment linked to the corresponding invoice.
func (r ApiQuickbooksDesktopInvoicesGetRequest) IncludeLinkedTransactions(includeLinkedTransactions bool) ApiQuickbooksDesktopInvoicesGetRequest {
	r.includeLinkedTransactions = &includeLinkedTransactions
	return r
}

func (r ApiQuickbooksDesktopInvoicesGetRequest) Execute() (*QuickbooksDesktopInvoicesGet200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopInvoicesGetExecute(r)
}

/*
QuickbooksDesktopInvoicesGet List all invoices

Returns a list of invoices. Use the `cursor` parameter to paginate through the results.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopInvoicesGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopInvoicesGet(ctx context.Context) ApiQuickbooksDesktopInvoicesGetRequest {
	return ApiQuickbooksDesktopInvoicesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopInvoicesGet200Response
func (a *DefaultAPIService) QuickbooksDesktopInvoicesGetExecute(r ApiQuickbooksDesktopInvoicesGetRequest) (*QuickbooksDesktopInvoicesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopInvoicesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopInvoicesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/invoices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.refNumbers != nil {
		t := *r.refNumbers
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "refNumbers", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "refNumbers", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 150
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.transactionDateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDateFrom", r.transactionDateFrom, "form", "")
	}
	if r.transactionDateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDateTo", r.transactionDateTo, "form", "")
	}
	if r.customerIds != nil {
		t := *r.customerIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "customerIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "customerIds", t, "form", "multi")
		}
	}
	if r.accountIds != nil {
		t := *r.accountIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountIds", t, "form", "multi")
		}
	}
	if r.refNumberContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberContains", r.refNumberContains, "form", "")
	}
	if r.refNumberStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberStartsWith", r.refNumberStartsWith, "form", "")
	}
	if r.refNumberEndsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberEndsWith", r.refNumberEndsWith, "form", "")
	}
	if r.refNumberFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberFrom", r.refNumberFrom, "form", "")
	}
	if r.refNumberTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberTo", r.refNumberTo, "form", "")
	}
	if r.currencyIds != nil {
		t := *r.currencyIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", t, "form", "multi")
		}
	}
	if r.paymentStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentStatus", r.paymentStatus, "form", "")
	} else {
		var defaultValue string = "all"
		r.paymentStatus = &defaultValue
	}
	if r.includeLineItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLineItems", r.includeLineItems, "form", "")
	} else {
		var defaultValue bool = true
		r.includeLineItems = &defaultValue
	}
	if r.includeLinkedTransactions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLinkedTransactions", r.includeLinkedTransactions, "form", "")
	} else {
		var defaultValue bool = false
		r.includeLinkedTransactions = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopInvoicesIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopInvoicesIdDeleteRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopInvoicesIdDeleteRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopInvoicesIdDeleteRequest) Execute() (*QuickbooksDesktopInvoicesIdDelete200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopInvoicesIdDeleteExecute(r)
}

/*
QuickbooksDesktopInvoicesIdDelete Delete an invoice

Permanently deletes a an invoice. The deletion will fail if the invoice is currently in use or has any linked transactions that are in use.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the invoice to delete.
 @return ApiQuickbooksDesktopInvoicesIdDeleteRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopInvoicesIdDelete(ctx context.Context, id string) ApiQuickbooksDesktopInvoicesIdDeleteRequest {
	return ApiQuickbooksDesktopInvoicesIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopInvoicesIdDelete200Response
func (a *DefaultAPIService) QuickbooksDesktopInvoicesIdDeleteExecute(r ApiQuickbooksDesktopInvoicesIdDeleteRequest) (*QuickbooksDesktopInvoicesIdDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopInvoicesIdDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopInvoicesIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/invoices/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopInvoicesIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopInvoicesIdGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopInvoicesIdGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopInvoicesIdGetRequest) Execute() (*QbdInvoice, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopInvoicesIdGetExecute(r)
}

/*
QuickbooksDesktopInvoicesIdGet Retrieve an invoice

Retrieves an invoice by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the invoice to retrieve.
 @return ApiQuickbooksDesktopInvoicesIdGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopInvoicesIdGet(ctx context.Context, id string) ApiQuickbooksDesktopInvoicesIdGetRequest {
	return ApiQuickbooksDesktopInvoicesIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdInvoice
func (a *DefaultAPIService) QuickbooksDesktopInvoicesIdGetExecute(r ApiQuickbooksDesktopInvoicesIdGetRequest) (*QbdInvoice, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdInvoice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopInvoicesIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/invoices/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopInvoicesIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
	quickbooksDesktopInvoicesIdPostRequest *QuickbooksDesktopInvoicesIdPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopInvoicesIdPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopInvoicesIdPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopInvoicesIdPostRequest) QuickbooksDesktopInvoicesIdPostRequest(quickbooksDesktopInvoicesIdPostRequest QuickbooksDesktopInvoicesIdPostRequest) ApiQuickbooksDesktopInvoicesIdPostRequest {
	r.quickbooksDesktopInvoicesIdPostRequest = &quickbooksDesktopInvoicesIdPostRequest
	return r
}

func (r ApiQuickbooksDesktopInvoicesIdPostRequest) Execute() (*QbdInvoice, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopInvoicesIdPostExecute(r)
}

/*
QuickbooksDesktopInvoicesIdPost Update an invoice

Updates an existing invoice.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the invoice to update.
 @return ApiQuickbooksDesktopInvoicesIdPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopInvoicesIdPost(ctx context.Context, id string) ApiQuickbooksDesktopInvoicesIdPostRequest {
	return ApiQuickbooksDesktopInvoicesIdPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdInvoice
func (a *DefaultAPIService) QuickbooksDesktopInvoicesIdPostExecute(r ApiQuickbooksDesktopInvoicesIdPostRequest) (*QbdInvoice, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdInvoice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopInvoicesIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/invoices/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopInvoicesIdPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopInvoicesPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	quickbooksDesktopInvoicesPostRequest *QuickbooksDesktopInvoicesPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopInvoicesPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopInvoicesPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopInvoicesPostRequest) QuickbooksDesktopInvoicesPostRequest(quickbooksDesktopInvoicesPostRequest QuickbooksDesktopInvoicesPostRequest) ApiQuickbooksDesktopInvoicesPostRequest {
	r.quickbooksDesktopInvoicesPostRequest = &quickbooksDesktopInvoicesPostRequest
	return r
}

func (r ApiQuickbooksDesktopInvoicesPostRequest) Execute() (*QbdInvoice, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopInvoicesPostExecute(r)
}

/*
QuickbooksDesktopInvoicesPost Create an invoice

Creates a new invoice.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopInvoicesPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopInvoicesPost(ctx context.Context) ApiQuickbooksDesktopInvoicesPostRequest {
	return ApiQuickbooksDesktopInvoicesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QbdInvoice
func (a *DefaultAPIService) QuickbooksDesktopInvoicesPostExecute(r ApiQuickbooksDesktopInvoicesPostRequest) (*QbdInvoice, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdInvoice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopInvoicesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/invoices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopInvoicesPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopItemReceiptsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	ids *[]string
	refNumbers *[]string
	limit *int32
	cursor *string
	updatedAfter *string
	updatedBefore *string
	transactionDateFrom *string
	transactionDateTo *string
	vendorIds *[]string
	accountIds *[]string
	refNumberContains *string
	refNumberStartsWith *string
	refNumberEndsWith *string
	refNumberFrom *string
	refNumberTo *string
	currencyIds *[]string
	includeLineItems *bool
	includeLinkedTransactions *bool
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopItemReceiptsGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopItemReceiptsGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

// Filter for specific item receipts by their QuickBooks-assigned unique identifier(s).  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopItemReceiptsGetRequest) Ids(ids []string) ApiQuickbooksDesktopItemReceiptsGetRequest {
	r.ids = &ids
	return r
}

// Filter for specific item receipts by their ref-number(s), case-sensitive. In QuickBooks, ref-numbers are not required to be unique and can be arbitrarily changed by the QuickBooks user.  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopItemReceiptsGetRequest) RefNumbers(refNumbers []string) ApiQuickbooksDesktopItemReceiptsGetRequest {
	r.refNumbers = &refNumbers
	return r
}

// The maximum number of objects to return. Accepts values ranging from 1 to 150, defaults to 150. When used with cursor-based pagination, this parameter controls how many results are returned per page. To paginate through results, combine this with the &#x60;cursor&#x60; parameter. Each response will include a &#x60;nextCursor&#x60; value that can be passed to subsequent requests to retrieve the next page of results.
func (r ApiQuickbooksDesktopItemReceiptsGetRequest) Limit(limit int32) ApiQuickbooksDesktopItemReceiptsGetRequest {
	r.limit = &limit
	return r
}

// The pagination token to fetch the next set of results when paginating with the &#x60;limit&#x60; parameter. Do not include this parameter on the first call. Use the &#x60;nextCursor&#x60; value returned in the previous response to request subsequent results.
func (r ApiQuickbooksDesktopItemReceiptsGetRequest) Cursor(cursor string) ApiQuickbooksDesktopItemReceiptsGetRequest {
	r.cursor = &cursor
	return r
}

// Filter for item receipts updated on or after this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 00:00:00 of that day.
func (r ApiQuickbooksDesktopItemReceiptsGetRequest) UpdatedAfter(updatedAfter string) ApiQuickbooksDesktopItemReceiptsGetRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Filter for item receipts updated on or before this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 23:59:59 of that day.
func (r ApiQuickbooksDesktopItemReceiptsGetRequest) UpdatedBefore(updatedBefore string) ApiQuickbooksDesktopItemReceiptsGetRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Filter for item receipts whose &#x60;date&#x60; field is on or after this date, in ISO 8601 format (YYYY-MM-DD).
func (r ApiQuickbooksDesktopItemReceiptsGetRequest) TransactionDateFrom(transactionDateFrom string) ApiQuickbooksDesktopItemReceiptsGetRequest {
	r.transactionDateFrom = &transactionDateFrom
	return r
}

// Filter for item receipts whose &#x60;date&#x60; field is on or before this date, in ISO 8601 format (YYYY-MM-DD).
func (r ApiQuickbooksDesktopItemReceiptsGetRequest) TransactionDateTo(transactionDateTo string) ApiQuickbooksDesktopItemReceiptsGetRequest {
	r.transactionDateTo = &transactionDateTo
	return r
}

// Filter for item receipts received from these vendors.
func (r ApiQuickbooksDesktopItemReceiptsGetRequest) VendorIds(vendorIds []string) ApiQuickbooksDesktopItemReceiptsGetRequest {
	r.vendorIds = &vendorIds
	return r
}

// Filter for item receipts associated with these accounts.
func (r ApiQuickbooksDesktopItemReceiptsGetRequest) AccountIds(accountIds []string) ApiQuickbooksDesktopItemReceiptsGetRequest {
	r.accountIds = &accountIds
	return r
}

// Filter for item receipts whose &#x60;refNumber&#x60; contains this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberStartsWith&#x60; or &#x60;refNumberEndsWith&#x60;.
func (r ApiQuickbooksDesktopItemReceiptsGetRequest) RefNumberContains(refNumberContains string) ApiQuickbooksDesktopItemReceiptsGetRequest {
	r.refNumberContains = &refNumberContains
	return r
}

// Filter for item receipts whose &#x60;refNumber&#x60; starts with this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberContains&#x60; or &#x60;refNumberEndsWith&#x60;.
func (r ApiQuickbooksDesktopItemReceiptsGetRequest) RefNumberStartsWith(refNumberStartsWith string) ApiQuickbooksDesktopItemReceiptsGetRequest {
	r.refNumberStartsWith = &refNumberStartsWith
	return r
}

// Filter for item receipts whose &#x60;refNumber&#x60; ends with this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberContains&#x60; or &#x60;refNumberStartsWith&#x60;.
func (r ApiQuickbooksDesktopItemReceiptsGetRequest) RefNumberEndsWith(refNumberEndsWith string) ApiQuickbooksDesktopItemReceiptsGetRequest {
	r.refNumberEndsWith = &refNumberEndsWith
	return r
}

// Filter for item receipts whose &#x60;refNumber&#x60; is greater than or equal to this value. If omitted, the range will begin with the first number of the list. Uses a numerical comparison for values that contain only digits; otherwise, uses a lexicographical comparison.
func (r ApiQuickbooksDesktopItemReceiptsGetRequest) RefNumberFrom(refNumberFrom string) ApiQuickbooksDesktopItemReceiptsGetRequest {
	r.refNumberFrom = &refNumberFrom
	return r
}

// Filter for item receipts whose &#x60;refNumber&#x60; is less than or equal to this value. If omitted, the range will end with the last number of the list. Uses a numerical comparison for values that contain only digits; otherwise, uses a lexicographical comparison.
func (r ApiQuickbooksDesktopItemReceiptsGetRequest) RefNumberTo(refNumberTo string) ApiQuickbooksDesktopItemReceiptsGetRequest {
	r.refNumberTo = &refNumberTo
	return r
}

// Filter for item receipts in these currencies.
func (r ApiQuickbooksDesktopItemReceiptsGetRequest) CurrencyIds(currencyIds []string) ApiQuickbooksDesktopItemReceiptsGetRequest {
	r.currencyIds = &currencyIds
	return r
}

// Whether to include line items in the response. Defaults to &#x60;true&#x60;.
func (r ApiQuickbooksDesktopItemReceiptsGetRequest) IncludeLineItems(includeLineItems bool) ApiQuickbooksDesktopItemReceiptsGetRequest {
	r.includeLineItems = &includeLineItems
	return r
}

// Whether to include linked transactions in the response. Defaults to &#x60;false&#x60;. For example, a payment linked to the corresponding item receipt.
func (r ApiQuickbooksDesktopItemReceiptsGetRequest) IncludeLinkedTransactions(includeLinkedTransactions bool) ApiQuickbooksDesktopItemReceiptsGetRequest {
	r.includeLinkedTransactions = &includeLinkedTransactions
	return r
}

func (r ApiQuickbooksDesktopItemReceiptsGetRequest) Execute() (*QuickbooksDesktopItemReceiptsGet200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopItemReceiptsGetExecute(r)
}

/*
QuickbooksDesktopItemReceiptsGet List all item receipts

Returns a list of item receipts. Use the `cursor` parameter to paginate through the results.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopItemReceiptsGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopItemReceiptsGet(ctx context.Context) ApiQuickbooksDesktopItemReceiptsGetRequest {
	return ApiQuickbooksDesktopItemReceiptsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopItemReceiptsGet200Response
func (a *DefaultAPIService) QuickbooksDesktopItemReceiptsGetExecute(r ApiQuickbooksDesktopItemReceiptsGetRequest) (*QuickbooksDesktopItemReceiptsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopItemReceiptsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopItemReceiptsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/item-receipts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.refNumbers != nil {
		t := *r.refNumbers
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "refNumbers", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "refNumbers", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 150
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.transactionDateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDateFrom", r.transactionDateFrom, "form", "")
	}
	if r.transactionDateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDateTo", r.transactionDateTo, "form", "")
	}
	if r.vendorIds != nil {
		t := *r.vendorIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vendorIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vendorIds", t, "form", "multi")
		}
	}
	if r.accountIds != nil {
		t := *r.accountIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountIds", t, "form", "multi")
		}
	}
	if r.refNumberContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberContains", r.refNumberContains, "form", "")
	}
	if r.refNumberStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberStartsWith", r.refNumberStartsWith, "form", "")
	}
	if r.refNumberEndsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberEndsWith", r.refNumberEndsWith, "form", "")
	}
	if r.refNumberFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberFrom", r.refNumberFrom, "form", "")
	}
	if r.refNumberTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberTo", r.refNumberTo, "form", "")
	}
	if r.currencyIds != nil {
		t := *r.currencyIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", t, "form", "multi")
		}
	}
	if r.includeLineItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLineItems", r.includeLineItems, "form", "")
	} else {
		var defaultValue bool = true
		r.includeLineItems = &defaultValue
	}
	if r.includeLinkedTransactions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLinkedTransactions", r.includeLinkedTransactions, "form", "")
	} else {
		var defaultValue bool = false
		r.includeLinkedTransactions = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopItemReceiptsIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopItemReceiptsIdDeleteRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopItemReceiptsIdDeleteRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopItemReceiptsIdDeleteRequest) Execute() (*QuickbooksDesktopItemReceiptsIdDelete200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopItemReceiptsIdDeleteExecute(r)
}

/*
QuickbooksDesktopItemReceiptsIdDelete Delete an item receipt

Permanently deletes a an item receipt. The deletion will fail if the item receipt is currently in use or has any linked transactions that are in use.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the item receipt to delete.
 @return ApiQuickbooksDesktopItemReceiptsIdDeleteRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopItemReceiptsIdDelete(ctx context.Context, id string) ApiQuickbooksDesktopItemReceiptsIdDeleteRequest {
	return ApiQuickbooksDesktopItemReceiptsIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopItemReceiptsIdDelete200Response
func (a *DefaultAPIService) QuickbooksDesktopItemReceiptsIdDeleteExecute(r ApiQuickbooksDesktopItemReceiptsIdDeleteRequest) (*QuickbooksDesktopItemReceiptsIdDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopItemReceiptsIdDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopItemReceiptsIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/item-receipts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopItemReceiptsIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopItemReceiptsIdGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopItemReceiptsIdGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopItemReceiptsIdGetRequest) Execute() (*QbdItemReceipt, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopItemReceiptsIdGetExecute(r)
}

/*
QuickbooksDesktopItemReceiptsIdGet Retrieve an item receipt

Retrieves an item receipt by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the item receipt to retrieve.
 @return ApiQuickbooksDesktopItemReceiptsIdGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopItemReceiptsIdGet(ctx context.Context, id string) ApiQuickbooksDesktopItemReceiptsIdGetRequest {
	return ApiQuickbooksDesktopItemReceiptsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdItemReceipt
func (a *DefaultAPIService) QuickbooksDesktopItemReceiptsIdGetExecute(r ApiQuickbooksDesktopItemReceiptsIdGetRequest) (*QbdItemReceipt, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdItemReceipt
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopItemReceiptsIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/item-receipts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopItemReceiptsIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
	quickbooksDesktopItemReceiptsIdPostRequest *QuickbooksDesktopItemReceiptsIdPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopItemReceiptsIdPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopItemReceiptsIdPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopItemReceiptsIdPostRequest) QuickbooksDesktopItemReceiptsIdPostRequest(quickbooksDesktopItemReceiptsIdPostRequest QuickbooksDesktopItemReceiptsIdPostRequest) ApiQuickbooksDesktopItemReceiptsIdPostRequest {
	r.quickbooksDesktopItemReceiptsIdPostRequest = &quickbooksDesktopItemReceiptsIdPostRequest
	return r
}

func (r ApiQuickbooksDesktopItemReceiptsIdPostRequest) Execute() (*QbdItemReceipt, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopItemReceiptsIdPostExecute(r)
}

/*
QuickbooksDesktopItemReceiptsIdPost Update an item receipt

Updates an existing item receipt.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the item receipt to update.
 @return ApiQuickbooksDesktopItemReceiptsIdPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopItemReceiptsIdPost(ctx context.Context, id string) ApiQuickbooksDesktopItemReceiptsIdPostRequest {
	return ApiQuickbooksDesktopItemReceiptsIdPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdItemReceipt
func (a *DefaultAPIService) QuickbooksDesktopItemReceiptsIdPostExecute(r ApiQuickbooksDesktopItemReceiptsIdPostRequest) (*QbdItemReceipt, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdItemReceipt
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopItemReceiptsIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/item-receipts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopItemReceiptsIdPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopItemReceiptsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	quickbooksDesktopItemReceiptsPostRequest *QuickbooksDesktopItemReceiptsPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopItemReceiptsPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopItemReceiptsPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopItemReceiptsPostRequest) QuickbooksDesktopItemReceiptsPostRequest(quickbooksDesktopItemReceiptsPostRequest QuickbooksDesktopItemReceiptsPostRequest) ApiQuickbooksDesktopItemReceiptsPostRequest {
	r.quickbooksDesktopItemReceiptsPostRequest = &quickbooksDesktopItemReceiptsPostRequest
	return r
}

func (r ApiQuickbooksDesktopItemReceiptsPostRequest) Execute() (*QbdItemReceipt, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopItemReceiptsPostExecute(r)
}

/*
QuickbooksDesktopItemReceiptsPost Create an item receipt

Creates a new item receipt.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopItemReceiptsPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopItemReceiptsPost(ctx context.Context) ApiQuickbooksDesktopItemReceiptsPostRequest {
	return ApiQuickbooksDesktopItemReceiptsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QbdItemReceipt
func (a *DefaultAPIService) QuickbooksDesktopItemReceiptsPostExecute(r ApiQuickbooksDesktopItemReceiptsPostRequest) (*QbdItemReceipt, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdItemReceipt
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopItemReceiptsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/item-receipts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopItemReceiptsPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopJournalEntriesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	ids *[]string
	refNumbers *[]string
	limit *int32
	cursor *string
	updatedAfter *string
	updatedBefore *string
	transactionDateFrom *string
	transactionDateTo *string
	entityIds *[]string
	accountIds *[]string
	refNumberContains *string
	refNumberStartsWith *string
	refNumberEndsWith *string
	refNumberFrom *string
	refNumberTo *string
	currencyIds *[]string
	includeLineItems *bool
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopJournalEntriesGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopJournalEntriesGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

// Filter for specific journal entries by their QuickBooks-assigned unique identifier(s).  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopJournalEntriesGetRequest) Ids(ids []string) ApiQuickbooksDesktopJournalEntriesGetRequest {
	r.ids = &ids
	return r
}

// Filter for specific journal entries by their ref-number(s), case-sensitive. In QuickBooks, ref-numbers are not required to be unique and can be arbitrarily changed by the QuickBooks user.  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopJournalEntriesGetRequest) RefNumbers(refNumbers []string) ApiQuickbooksDesktopJournalEntriesGetRequest {
	r.refNumbers = &refNumbers
	return r
}

// The maximum number of objects to return. Accepts values ranging from 1 to 150, defaults to 150. When used with cursor-based pagination, this parameter controls how many results are returned per page. To paginate through results, combine this with the &#x60;cursor&#x60; parameter. Each response will include a &#x60;nextCursor&#x60; value that can be passed to subsequent requests to retrieve the next page of results.
func (r ApiQuickbooksDesktopJournalEntriesGetRequest) Limit(limit int32) ApiQuickbooksDesktopJournalEntriesGetRequest {
	r.limit = &limit
	return r
}

// The pagination token to fetch the next set of results when paginating with the &#x60;limit&#x60; parameter. Do not include this parameter on the first call. Use the &#x60;nextCursor&#x60; value returned in the previous response to request subsequent results.
func (r ApiQuickbooksDesktopJournalEntriesGetRequest) Cursor(cursor string) ApiQuickbooksDesktopJournalEntriesGetRequest {
	r.cursor = &cursor
	return r
}

// Filter for journal entries updated on or after this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 00:00:00 of that day.
func (r ApiQuickbooksDesktopJournalEntriesGetRequest) UpdatedAfter(updatedAfter string) ApiQuickbooksDesktopJournalEntriesGetRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Filter for journal entries updated on or before this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 23:59:59 of that day.
func (r ApiQuickbooksDesktopJournalEntriesGetRequest) UpdatedBefore(updatedBefore string) ApiQuickbooksDesktopJournalEntriesGetRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Filter for journal entries whose &#x60;date&#x60; field is on or after this date, in ISO 8601 format (YYYY-MM-DD).
func (r ApiQuickbooksDesktopJournalEntriesGetRequest) TransactionDateFrom(transactionDateFrom string) ApiQuickbooksDesktopJournalEntriesGetRequest {
	r.transactionDateFrom = &transactionDateFrom
	return r
}

// Filter for journal entries whose &#x60;date&#x60; field is on or before this date, in ISO 8601 format (YYYY-MM-DD).
func (r ApiQuickbooksDesktopJournalEntriesGetRequest) TransactionDateTo(transactionDateTo string) ApiQuickbooksDesktopJournalEntriesGetRequest {
	r.transactionDateTo = &transactionDateTo
	return r
}

// Filter for journal entries associated with these entities (customers, vendors, employees, etc.).
func (r ApiQuickbooksDesktopJournalEntriesGetRequest) EntityIds(entityIds []string) ApiQuickbooksDesktopJournalEntriesGetRequest {
	r.entityIds = &entityIds
	return r
}

// Filter for journal entries associated with these accounts.
func (r ApiQuickbooksDesktopJournalEntriesGetRequest) AccountIds(accountIds []string) ApiQuickbooksDesktopJournalEntriesGetRequest {
	r.accountIds = &accountIds
	return r
}

// Filter for journal entries whose &#x60;refNumber&#x60; contains this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberStartsWith&#x60; or &#x60;refNumberEndsWith&#x60;.
func (r ApiQuickbooksDesktopJournalEntriesGetRequest) RefNumberContains(refNumberContains string) ApiQuickbooksDesktopJournalEntriesGetRequest {
	r.refNumberContains = &refNumberContains
	return r
}

// Filter for journal entries whose &#x60;refNumber&#x60; starts with this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberContains&#x60; or &#x60;refNumberEndsWith&#x60;.
func (r ApiQuickbooksDesktopJournalEntriesGetRequest) RefNumberStartsWith(refNumberStartsWith string) ApiQuickbooksDesktopJournalEntriesGetRequest {
	r.refNumberStartsWith = &refNumberStartsWith
	return r
}

// Filter for journal entries whose &#x60;refNumber&#x60; ends with this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberContains&#x60; or &#x60;refNumberStartsWith&#x60;.
func (r ApiQuickbooksDesktopJournalEntriesGetRequest) RefNumberEndsWith(refNumberEndsWith string) ApiQuickbooksDesktopJournalEntriesGetRequest {
	r.refNumberEndsWith = &refNumberEndsWith
	return r
}

// Filter for journal entries whose &#x60;refNumber&#x60; is greater than or equal to this value. If omitted, the range will begin with the first number of the list. Uses a numerical comparison for values that contain only digits; otherwise, uses a lexicographical comparison.
func (r ApiQuickbooksDesktopJournalEntriesGetRequest) RefNumberFrom(refNumberFrom string) ApiQuickbooksDesktopJournalEntriesGetRequest {
	r.refNumberFrom = &refNumberFrom
	return r
}

// Filter for journal entries whose &#x60;refNumber&#x60; is less than or equal to this value. If omitted, the range will end with the last number of the list. Uses a numerical comparison for values that contain only digits; otherwise, uses a lexicographical comparison.
func (r ApiQuickbooksDesktopJournalEntriesGetRequest) RefNumberTo(refNumberTo string) ApiQuickbooksDesktopJournalEntriesGetRequest {
	r.refNumberTo = &refNumberTo
	return r
}

// Filter for journal entries in these currencies.
func (r ApiQuickbooksDesktopJournalEntriesGetRequest) CurrencyIds(currencyIds []string) ApiQuickbooksDesktopJournalEntriesGetRequest {
	r.currencyIds = &currencyIds
	return r
}

// Whether to include line items in the response. Defaults to &#x60;true&#x60;.
func (r ApiQuickbooksDesktopJournalEntriesGetRequest) IncludeLineItems(includeLineItems bool) ApiQuickbooksDesktopJournalEntriesGetRequest {
	r.includeLineItems = &includeLineItems
	return r
}

func (r ApiQuickbooksDesktopJournalEntriesGetRequest) Execute() (*QuickbooksDesktopJournalEntriesGet200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopJournalEntriesGetExecute(r)
}

/*
QuickbooksDesktopJournalEntriesGet List all journal entries

Returns a list of journal entries. Use the `cursor` parameter to paginate through the results.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopJournalEntriesGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopJournalEntriesGet(ctx context.Context) ApiQuickbooksDesktopJournalEntriesGetRequest {
	return ApiQuickbooksDesktopJournalEntriesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopJournalEntriesGet200Response
func (a *DefaultAPIService) QuickbooksDesktopJournalEntriesGetExecute(r ApiQuickbooksDesktopJournalEntriesGetRequest) (*QuickbooksDesktopJournalEntriesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopJournalEntriesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopJournalEntriesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/journal-entries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.refNumbers != nil {
		t := *r.refNumbers
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "refNumbers", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "refNumbers", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 150
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.transactionDateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDateFrom", r.transactionDateFrom, "form", "")
	}
	if r.transactionDateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDateTo", r.transactionDateTo, "form", "")
	}
	if r.entityIds != nil {
		t := *r.entityIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "entityIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "entityIds", t, "form", "multi")
		}
	}
	if r.accountIds != nil {
		t := *r.accountIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountIds", t, "form", "multi")
		}
	}
	if r.refNumberContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberContains", r.refNumberContains, "form", "")
	}
	if r.refNumberStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberStartsWith", r.refNumberStartsWith, "form", "")
	}
	if r.refNumberEndsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberEndsWith", r.refNumberEndsWith, "form", "")
	}
	if r.refNumberFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberFrom", r.refNumberFrom, "form", "")
	}
	if r.refNumberTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberTo", r.refNumberTo, "form", "")
	}
	if r.currencyIds != nil {
		t := *r.currencyIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", t, "form", "multi")
		}
	}
	if r.includeLineItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLineItems", r.includeLineItems, "form", "")
	} else {
		var defaultValue bool = true
		r.includeLineItems = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopJournalEntriesIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopJournalEntriesIdDeleteRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopJournalEntriesIdDeleteRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopJournalEntriesIdDeleteRequest) Execute() (*QuickbooksDesktopJournalEntriesIdDelete200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopJournalEntriesIdDeleteExecute(r)
}

/*
QuickbooksDesktopJournalEntriesIdDelete Delete a journal entry

Permanently deletes a a journal entry. The deletion will fail if the journal entry is currently in use or has any linked transactions that are in use.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the journal entry to delete.
 @return ApiQuickbooksDesktopJournalEntriesIdDeleteRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopJournalEntriesIdDelete(ctx context.Context, id string) ApiQuickbooksDesktopJournalEntriesIdDeleteRequest {
	return ApiQuickbooksDesktopJournalEntriesIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopJournalEntriesIdDelete200Response
func (a *DefaultAPIService) QuickbooksDesktopJournalEntriesIdDeleteExecute(r ApiQuickbooksDesktopJournalEntriesIdDeleteRequest) (*QuickbooksDesktopJournalEntriesIdDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopJournalEntriesIdDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopJournalEntriesIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/journal-entries/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopJournalEntriesIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopJournalEntriesIdGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopJournalEntriesIdGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopJournalEntriesIdGetRequest) Execute() (*QbdJournalEntry, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopJournalEntriesIdGetExecute(r)
}

/*
QuickbooksDesktopJournalEntriesIdGet Retrieve a journal entry

Retrieves a journal entry by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the journal entry to retrieve.
 @return ApiQuickbooksDesktopJournalEntriesIdGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopJournalEntriesIdGet(ctx context.Context, id string) ApiQuickbooksDesktopJournalEntriesIdGetRequest {
	return ApiQuickbooksDesktopJournalEntriesIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdJournalEntry
func (a *DefaultAPIService) QuickbooksDesktopJournalEntriesIdGetExecute(r ApiQuickbooksDesktopJournalEntriesIdGetRequest) (*QbdJournalEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdJournalEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopJournalEntriesIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/journal-entries/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopJournalEntriesIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
	quickbooksDesktopJournalEntriesIdPostRequest *QuickbooksDesktopJournalEntriesIdPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopJournalEntriesIdPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopJournalEntriesIdPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopJournalEntriesIdPostRequest) QuickbooksDesktopJournalEntriesIdPostRequest(quickbooksDesktopJournalEntriesIdPostRequest QuickbooksDesktopJournalEntriesIdPostRequest) ApiQuickbooksDesktopJournalEntriesIdPostRequest {
	r.quickbooksDesktopJournalEntriesIdPostRequest = &quickbooksDesktopJournalEntriesIdPostRequest
	return r
}

func (r ApiQuickbooksDesktopJournalEntriesIdPostRequest) Execute() (*QbdJournalEntry, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopJournalEntriesIdPostExecute(r)
}

/*
QuickbooksDesktopJournalEntriesIdPost Update a journal entry

Updates an existing journal entry.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the journal entry to update.
 @return ApiQuickbooksDesktopJournalEntriesIdPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopJournalEntriesIdPost(ctx context.Context, id string) ApiQuickbooksDesktopJournalEntriesIdPostRequest {
	return ApiQuickbooksDesktopJournalEntriesIdPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdJournalEntry
func (a *DefaultAPIService) QuickbooksDesktopJournalEntriesIdPostExecute(r ApiQuickbooksDesktopJournalEntriesIdPostRequest) (*QbdJournalEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdJournalEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopJournalEntriesIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/journal-entries/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopJournalEntriesIdPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopJournalEntriesPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	quickbooksDesktopJournalEntriesPostRequest *QuickbooksDesktopJournalEntriesPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopJournalEntriesPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopJournalEntriesPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopJournalEntriesPostRequest) QuickbooksDesktopJournalEntriesPostRequest(quickbooksDesktopJournalEntriesPostRequest QuickbooksDesktopJournalEntriesPostRequest) ApiQuickbooksDesktopJournalEntriesPostRequest {
	r.quickbooksDesktopJournalEntriesPostRequest = &quickbooksDesktopJournalEntriesPostRequest
	return r
}

func (r ApiQuickbooksDesktopJournalEntriesPostRequest) Execute() (*QbdJournalEntry, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopJournalEntriesPostExecute(r)
}

/*
QuickbooksDesktopJournalEntriesPost Create a journal entry

Creates a new journal entry.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopJournalEntriesPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopJournalEntriesPost(ctx context.Context) ApiQuickbooksDesktopJournalEntriesPostRequest {
	return ApiQuickbooksDesktopJournalEntriesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QbdJournalEntry
func (a *DefaultAPIService) QuickbooksDesktopJournalEntriesPostExecute(r ApiQuickbooksDesktopJournalEntriesPostRequest) (*QbdJournalEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdJournalEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopJournalEntriesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/journal-entries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopJournalEntriesPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopNonInventoryItemsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	ids *[]string
	fullNames *[]string
	limit *int32
	cursor *string
	status *string
	updatedAfter *string
	updatedBefore *string
	nameContains *string
	nameStartsWith *string
	nameEndsWith *string
	nameFrom *string
	nameTo *string
	classIds *[]string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopNonInventoryItemsGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopNonInventoryItemsGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

// Filter for specific non-inventory items by their QuickBooks-assigned unique identifier(s).  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopNonInventoryItemsGetRequest) Ids(ids []string) ApiQuickbooksDesktopNonInventoryItemsGetRequest {
	r.ids = &ids
	return r
}

// Filter for specific non-inventory items by their full-name(s), case-insensitive. Like &#x60;id&#x60;, &#x60;fullName&#x60; is a unique identifier for a non-inventory item, formed by by combining the names of its parent objects with its own &#x60;name&#x60;, separated by colons. For example, if a non-inventory item is under \&quot;Office Supplies\&quot; and has the &#x60;name&#x60; \&quot;Printer Ink Cartridge\&quot;, its &#x60;fullName&#x60; would be \&quot;Office Supplies:Printer Ink Cartridge\&quot;.  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopNonInventoryItemsGetRequest) FullNames(fullNames []string) ApiQuickbooksDesktopNonInventoryItemsGetRequest {
	r.fullNames = &fullNames
	return r
}

// The maximum number of objects to return. Accepts values ranging from 1 to 150, defaults to 150. When used with cursor-based pagination, this parameter controls how many results are returned per page. To paginate through results, combine this with the &#x60;cursor&#x60; parameter. Each response will include a &#x60;nextCursor&#x60; value that can be passed to subsequent requests to retrieve the next page of results.
func (r ApiQuickbooksDesktopNonInventoryItemsGetRequest) Limit(limit int32) ApiQuickbooksDesktopNonInventoryItemsGetRequest {
	r.limit = &limit
	return r
}

// The pagination token to fetch the next set of results when paginating with the &#x60;limit&#x60; parameter. Do not include this parameter on the first call. Use the &#x60;nextCursor&#x60; value returned in the previous response to request subsequent results.
func (r ApiQuickbooksDesktopNonInventoryItemsGetRequest) Cursor(cursor string) ApiQuickbooksDesktopNonInventoryItemsGetRequest {
	r.cursor = &cursor
	return r
}

// Filter for non-inventory items that are active, inactive, or both.
func (r ApiQuickbooksDesktopNonInventoryItemsGetRequest) Status(status string) ApiQuickbooksDesktopNonInventoryItemsGetRequest {
	r.status = &status
	return r
}

// Filter for non-inventory items updated on or after this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 00:00:00 of that day.
func (r ApiQuickbooksDesktopNonInventoryItemsGetRequest) UpdatedAfter(updatedAfter string) ApiQuickbooksDesktopNonInventoryItemsGetRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Filter for non-inventory items updated on or before this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 23:59:59 of that day.
func (r ApiQuickbooksDesktopNonInventoryItemsGetRequest) UpdatedBefore(updatedBefore string) ApiQuickbooksDesktopNonInventoryItemsGetRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Filter for non-inventory items whose &#x60;name&#x60; contains this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameStartsWith&#x60; or &#x60;nameEndsWith&#x60;.
func (r ApiQuickbooksDesktopNonInventoryItemsGetRequest) NameContains(nameContains string) ApiQuickbooksDesktopNonInventoryItemsGetRequest {
	r.nameContains = &nameContains
	return r
}

// Filter for non-inventory items whose &#x60;name&#x60; starts with this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameContains&#x60; or &#x60;nameEndsWith&#x60;.
func (r ApiQuickbooksDesktopNonInventoryItemsGetRequest) NameStartsWith(nameStartsWith string) ApiQuickbooksDesktopNonInventoryItemsGetRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Filter for non-inventory items whose &#x60;name&#x60; ends with this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameContains&#x60; or &#x60;nameStartsWith&#x60;.
func (r ApiQuickbooksDesktopNonInventoryItemsGetRequest) NameEndsWith(nameEndsWith string) ApiQuickbooksDesktopNonInventoryItemsGetRequest {
	r.nameEndsWith = &nameEndsWith
	return r
}

// Filter for non-inventory items whose &#x60;name&#x60; is alphabetically greater than or equal to this value.
func (r ApiQuickbooksDesktopNonInventoryItemsGetRequest) NameFrom(nameFrom string) ApiQuickbooksDesktopNonInventoryItemsGetRequest {
	r.nameFrom = &nameFrom
	return r
}

// Filter for non-inventory items whose &#x60;name&#x60; is alphabetically less than or equal to this value.
func (r ApiQuickbooksDesktopNonInventoryItemsGetRequest) NameTo(nameTo string) ApiQuickbooksDesktopNonInventoryItemsGetRequest {
	r.nameTo = &nameTo
	return r
}

// Filter for non-inventory items of these classes. A class is a way end-users can categorize non-inventory items in QuickBooks.
func (r ApiQuickbooksDesktopNonInventoryItemsGetRequest) ClassIds(classIds []string) ApiQuickbooksDesktopNonInventoryItemsGetRequest {
	r.classIds = &classIds
	return r
}

func (r ApiQuickbooksDesktopNonInventoryItemsGetRequest) Execute() (*QuickbooksDesktopNonInventoryItemsGet200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopNonInventoryItemsGetExecute(r)
}

/*
QuickbooksDesktopNonInventoryItemsGet List all non-inventory items

Returns a list of non-inventory items. Use the `cursor` parameter to paginate through the results.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopNonInventoryItemsGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopNonInventoryItemsGet(ctx context.Context) ApiQuickbooksDesktopNonInventoryItemsGetRequest {
	return ApiQuickbooksDesktopNonInventoryItemsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopNonInventoryItemsGet200Response
func (a *DefaultAPIService) QuickbooksDesktopNonInventoryItemsGetExecute(r ApiQuickbooksDesktopNonInventoryItemsGetRequest) (*QuickbooksDesktopNonInventoryItemsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopNonInventoryItemsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopNonInventoryItemsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/non-inventory-items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.fullNames != nil {
		t := *r.fullNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fullNames", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fullNames", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 150
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	} else {
		var defaultValue string = "active"
		r.status = &defaultValue
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.nameContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameContains", r.nameContains, "form", "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameStartsWith", r.nameStartsWith, "form", "")
	}
	if r.nameEndsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameEndsWith", r.nameEndsWith, "form", "")
	}
	if r.nameFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameFrom", r.nameFrom, "form", "")
	}
	if r.nameTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameTo", r.nameTo, "form", "")
	}
	if r.classIds != nil {
		t := *r.classIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "classIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "classIds", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopNonInventoryItemsIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopNonInventoryItemsIdGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopNonInventoryItemsIdGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopNonInventoryItemsIdGetRequest) Execute() (*QbdNonInventoryItem, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopNonInventoryItemsIdGetExecute(r)
}

/*
QuickbooksDesktopNonInventoryItemsIdGet Retrieve a non-inventory item

Retrieves a non-inventory item by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the non-inventory item to retrieve.
 @return ApiQuickbooksDesktopNonInventoryItemsIdGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopNonInventoryItemsIdGet(ctx context.Context, id string) ApiQuickbooksDesktopNonInventoryItemsIdGetRequest {
	return ApiQuickbooksDesktopNonInventoryItemsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdNonInventoryItem
func (a *DefaultAPIService) QuickbooksDesktopNonInventoryItemsIdGetExecute(r ApiQuickbooksDesktopNonInventoryItemsIdGetRequest) (*QbdNonInventoryItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdNonInventoryItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopNonInventoryItemsIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/non-inventory-items/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopNonInventoryItemsIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
	quickbooksDesktopNonInventoryItemsIdPostRequest *QuickbooksDesktopNonInventoryItemsIdPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopNonInventoryItemsIdPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopNonInventoryItemsIdPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopNonInventoryItemsIdPostRequest) QuickbooksDesktopNonInventoryItemsIdPostRequest(quickbooksDesktopNonInventoryItemsIdPostRequest QuickbooksDesktopNonInventoryItemsIdPostRequest) ApiQuickbooksDesktopNonInventoryItemsIdPostRequest {
	r.quickbooksDesktopNonInventoryItemsIdPostRequest = &quickbooksDesktopNonInventoryItemsIdPostRequest
	return r
}

func (r ApiQuickbooksDesktopNonInventoryItemsIdPostRequest) Execute() (*QbdNonInventoryItem, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopNonInventoryItemsIdPostExecute(r)
}

/*
QuickbooksDesktopNonInventoryItemsIdPost Update a non-inventory item

Updates an existing non-inventory item.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the non-inventory item to update.
 @return ApiQuickbooksDesktopNonInventoryItemsIdPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopNonInventoryItemsIdPost(ctx context.Context, id string) ApiQuickbooksDesktopNonInventoryItemsIdPostRequest {
	return ApiQuickbooksDesktopNonInventoryItemsIdPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdNonInventoryItem
func (a *DefaultAPIService) QuickbooksDesktopNonInventoryItemsIdPostExecute(r ApiQuickbooksDesktopNonInventoryItemsIdPostRequest) (*QbdNonInventoryItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdNonInventoryItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopNonInventoryItemsIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/non-inventory-items/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopNonInventoryItemsIdPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopNonInventoryItemsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	quickbooksDesktopNonInventoryItemsPostRequest *QuickbooksDesktopNonInventoryItemsPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopNonInventoryItemsPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopNonInventoryItemsPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopNonInventoryItemsPostRequest) QuickbooksDesktopNonInventoryItemsPostRequest(quickbooksDesktopNonInventoryItemsPostRequest QuickbooksDesktopNonInventoryItemsPostRequest) ApiQuickbooksDesktopNonInventoryItemsPostRequest {
	r.quickbooksDesktopNonInventoryItemsPostRequest = &quickbooksDesktopNonInventoryItemsPostRequest
	return r
}

func (r ApiQuickbooksDesktopNonInventoryItemsPostRequest) Execute() (*QbdNonInventoryItem, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopNonInventoryItemsPostExecute(r)
}

/*
QuickbooksDesktopNonInventoryItemsPost Create a non-inventory item

Creates a new non-inventory item.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopNonInventoryItemsPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopNonInventoryItemsPost(ctx context.Context) ApiQuickbooksDesktopNonInventoryItemsPostRequest {
	return ApiQuickbooksDesktopNonInventoryItemsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QbdNonInventoryItem
func (a *DefaultAPIService) QuickbooksDesktopNonInventoryItemsPostExecute(r ApiQuickbooksDesktopNonInventoryItemsPostRequest) (*QbdNonInventoryItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdNonInventoryItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopNonInventoryItemsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/non-inventory-items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopNonInventoryItemsPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopPayrollWageItemsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	ids *[]string
	names *[]string
	limit *int32
	cursor *string
	status *string
	updatedAfter *string
	updatedBefore *string
	nameContains *string
	nameStartsWith *string
	nameEndsWith *string
	nameFrom *string
	nameTo *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopPayrollWageItemsGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopPayrollWageItemsGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

// Filter for specific payroll wage items by their QuickBooks-assigned unique identifier(s).  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopPayrollWageItemsGetRequest) Ids(ids []string) ApiQuickbooksDesktopPayrollWageItemsGetRequest {
	r.ids = &ids
	return r
}

// Filter for specific payroll wage items by their name(s), case-insensitive. Like &#x60;id&#x60;, &#x60;name&#x60; is a unique identifier for a payroll wage item.  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopPayrollWageItemsGetRequest) Names(names []string) ApiQuickbooksDesktopPayrollWageItemsGetRequest {
	r.names = &names
	return r
}

// The maximum number of objects to return. Accepts values ranging from 1 to 150, defaults to 150. When used with cursor-based pagination, this parameter controls how many results are returned per page. To paginate through results, combine this with the &#x60;cursor&#x60; parameter. Each response will include a &#x60;nextCursor&#x60; value that can be passed to subsequent requests to retrieve the next page of results.
func (r ApiQuickbooksDesktopPayrollWageItemsGetRequest) Limit(limit int32) ApiQuickbooksDesktopPayrollWageItemsGetRequest {
	r.limit = &limit
	return r
}

// The pagination token to fetch the next set of results when paginating with the &#x60;limit&#x60; parameter. Do not include this parameter on the first call. Use the &#x60;nextCursor&#x60; value returned in the previous response to request subsequent results.
func (r ApiQuickbooksDesktopPayrollWageItemsGetRequest) Cursor(cursor string) ApiQuickbooksDesktopPayrollWageItemsGetRequest {
	r.cursor = &cursor
	return r
}

// Filter for payroll wage items that are active, inactive, or both.
func (r ApiQuickbooksDesktopPayrollWageItemsGetRequest) Status(status string) ApiQuickbooksDesktopPayrollWageItemsGetRequest {
	r.status = &status
	return r
}

// Filter for payroll wage items updated on or after this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 00:00:00 of that day.
func (r ApiQuickbooksDesktopPayrollWageItemsGetRequest) UpdatedAfter(updatedAfter string) ApiQuickbooksDesktopPayrollWageItemsGetRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Filter for payroll wage items updated on or before this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 23:59:59 of that day.
func (r ApiQuickbooksDesktopPayrollWageItemsGetRequest) UpdatedBefore(updatedBefore string) ApiQuickbooksDesktopPayrollWageItemsGetRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Filter for payroll wage items whose &#x60;name&#x60; contains this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameStartsWith&#x60; or &#x60;nameEndsWith&#x60;.
func (r ApiQuickbooksDesktopPayrollWageItemsGetRequest) NameContains(nameContains string) ApiQuickbooksDesktopPayrollWageItemsGetRequest {
	r.nameContains = &nameContains
	return r
}

// Filter for payroll wage items whose &#x60;name&#x60; starts with this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameContains&#x60; or &#x60;nameEndsWith&#x60;.
func (r ApiQuickbooksDesktopPayrollWageItemsGetRequest) NameStartsWith(nameStartsWith string) ApiQuickbooksDesktopPayrollWageItemsGetRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Filter for payroll wage items whose &#x60;name&#x60; ends with this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameContains&#x60; or &#x60;nameStartsWith&#x60;.
func (r ApiQuickbooksDesktopPayrollWageItemsGetRequest) NameEndsWith(nameEndsWith string) ApiQuickbooksDesktopPayrollWageItemsGetRequest {
	r.nameEndsWith = &nameEndsWith
	return r
}

// Filter for payroll wage items whose &#x60;name&#x60; is alphabetically greater than or equal to this value.
func (r ApiQuickbooksDesktopPayrollWageItemsGetRequest) NameFrom(nameFrom string) ApiQuickbooksDesktopPayrollWageItemsGetRequest {
	r.nameFrom = &nameFrom
	return r
}

// Filter for payroll wage items whose &#x60;name&#x60; is alphabetically less than or equal to this value.
func (r ApiQuickbooksDesktopPayrollWageItemsGetRequest) NameTo(nameTo string) ApiQuickbooksDesktopPayrollWageItemsGetRequest {
	r.nameTo = &nameTo
	return r
}

func (r ApiQuickbooksDesktopPayrollWageItemsGetRequest) Execute() (*QuickbooksDesktopPayrollWageItemsGet200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopPayrollWageItemsGetExecute(r)
}

/*
QuickbooksDesktopPayrollWageItemsGet List all payroll wage items

Returns a list of payroll wage items. Use the `cursor` parameter to paginate through the results.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopPayrollWageItemsGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopPayrollWageItemsGet(ctx context.Context) ApiQuickbooksDesktopPayrollWageItemsGetRequest {
	return ApiQuickbooksDesktopPayrollWageItemsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopPayrollWageItemsGet200Response
func (a *DefaultAPIService) QuickbooksDesktopPayrollWageItemsGetExecute(r ApiQuickbooksDesktopPayrollWageItemsGetRequest) (*QuickbooksDesktopPayrollWageItemsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopPayrollWageItemsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopPayrollWageItemsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/payroll-wage-items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.names != nil {
		t := *r.names
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "names", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "names", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 150
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	} else {
		var defaultValue string = "active"
		r.status = &defaultValue
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.nameContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameContains", r.nameContains, "form", "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameStartsWith", r.nameStartsWith, "form", "")
	}
	if r.nameEndsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameEndsWith", r.nameEndsWith, "form", "")
	}
	if r.nameFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameFrom", r.nameFrom, "form", "")
	}
	if r.nameTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameTo", r.nameTo, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopPayrollWageItemsIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopPayrollWageItemsIdGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopPayrollWageItemsIdGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopPayrollWageItemsIdGetRequest) Execute() (*QbdPayrollWageItem, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopPayrollWageItemsIdGetExecute(r)
}

/*
QuickbooksDesktopPayrollWageItemsIdGet Retrieve a payroll wage item

Retrieves a payroll wage item by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the payroll wage item to retrieve.
 @return ApiQuickbooksDesktopPayrollWageItemsIdGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopPayrollWageItemsIdGet(ctx context.Context, id string) ApiQuickbooksDesktopPayrollWageItemsIdGetRequest {
	return ApiQuickbooksDesktopPayrollWageItemsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdPayrollWageItem
func (a *DefaultAPIService) QuickbooksDesktopPayrollWageItemsIdGetExecute(r ApiQuickbooksDesktopPayrollWageItemsIdGetRequest) (*QbdPayrollWageItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdPayrollWageItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopPayrollWageItemsIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/payroll-wage-items/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopPayrollWageItemsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	quickbooksDesktopPayrollWageItemsPostRequest *QuickbooksDesktopPayrollWageItemsPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopPayrollWageItemsPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopPayrollWageItemsPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopPayrollWageItemsPostRequest) QuickbooksDesktopPayrollWageItemsPostRequest(quickbooksDesktopPayrollWageItemsPostRequest QuickbooksDesktopPayrollWageItemsPostRequest) ApiQuickbooksDesktopPayrollWageItemsPostRequest {
	r.quickbooksDesktopPayrollWageItemsPostRequest = &quickbooksDesktopPayrollWageItemsPostRequest
	return r
}

func (r ApiQuickbooksDesktopPayrollWageItemsPostRequest) Execute() (*QbdPayrollWageItem, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopPayrollWageItemsPostExecute(r)
}

/*
QuickbooksDesktopPayrollWageItemsPost Create a payroll wage item

Creates a new payroll wage item.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopPayrollWageItemsPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopPayrollWageItemsPost(ctx context.Context) ApiQuickbooksDesktopPayrollWageItemsPostRequest {
	return ApiQuickbooksDesktopPayrollWageItemsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QbdPayrollWageItem
func (a *DefaultAPIService) QuickbooksDesktopPayrollWageItemsPostExecute(r ApiQuickbooksDesktopPayrollWageItemsPostRequest) (*QbdPayrollWageItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdPayrollWageItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopPayrollWageItemsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/payroll-wage-items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopPayrollWageItemsPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopPreferencesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopPreferencesGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopPreferencesGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopPreferencesGetRequest) Execute() (*QbdPreferences, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopPreferencesGetExecute(r)
}

/*
QuickbooksDesktopPreferencesGet Retrieve company file preferences

Returns the preferences that the QuickBooks administrator has set for all users of the connected company file. Note that preferences cannot be modified through the API, only through the QuickBooks Desktop user interface.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopPreferencesGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopPreferencesGet(ctx context.Context) ApiQuickbooksDesktopPreferencesGetRequest {
	return ApiQuickbooksDesktopPreferencesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QbdPreferences
func (a *DefaultAPIService) QuickbooksDesktopPreferencesGetExecute(r ApiQuickbooksDesktopPreferencesGetRequest) (*QbdPreferences, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdPreferences
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopPreferencesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/preferences"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopPriceLevelsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	ids *[]string
	names *[]string
	limit *int32
	status *string
	updatedAfter *string
	updatedBefore *string
	nameContains *string
	nameStartsWith *string
	nameEndsWith *string
	nameFrom *string
	nameTo *string
	itemIds *[]string
	currencyIds *[]string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopPriceLevelsGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopPriceLevelsGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

// Filter for specific price levels by their QuickBooks-assigned unique identifier(s).  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopPriceLevelsGetRequest) Ids(ids []string) ApiQuickbooksDesktopPriceLevelsGetRequest {
	r.ids = &ids
	return r
}

// Filter for specific price levels by their name(s), case-insensitive. Like &#x60;id&#x60;, &#x60;name&#x60; is a unique identifier for a price level.  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopPriceLevelsGetRequest) Names(names []string) ApiQuickbooksDesktopPriceLevelsGetRequest {
	r.names = &names
	return r
}

// The maximum number of objects to return.  **IMPORTANT**: QuickBooks Desktop does not support cursor-based pagination for price levels. This parameter will limit the response size, but you cannot fetch subsequent results using a cursor. For pagination, use the name-range parameters instead (e.g., &#x60;nameFrom&#x3D;A&amp;nameTo&#x3D;B&#x60;).  When this parameter is omitted, the endpoint returns all price levels without limit, unlike paginated endpoints which default to 150 records. This is acceptable because price levels typically have low record counts.
func (r ApiQuickbooksDesktopPriceLevelsGetRequest) Limit(limit int32) ApiQuickbooksDesktopPriceLevelsGetRequest {
	r.limit = &limit
	return r
}

// Filter for price levels that are active, inactive, or both.
func (r ApiQuickbooksDesktopPriceLevelsGetRequest) Status(status string) ApiQuickbooksDesktopPriceLevelsGetRequest {
	r.status = &status
	return r
}

// Filter for price levels updated on or after this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 00:00:00 of that day.
func (r ApiQuickbooksDesktopPriceLevelsGetRequest) UpdatedAfter(updatedAfter string) ApiQuickbooksDesktopPriceLevelsGetRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Filter for price levels updated on or before this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 23:59:59 of that day.
func (r ApiQuickbooksDesktopPriceLevelsGetRequest) UpdatedBefore(updatedBefore string) ApiQuickbooksDesktopPriceLevelsGetRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Filter for price levels whose &#x60;name&#x60; contains this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameStartsWith&#x60; or &#x60;nameEndsWith&#x60;.
func (r ApiQuickbooksDesktopPriceLevelsGetRequest) NameContains(nameContains string) ApiQuickbooksDesktopPriceLevelsGetRequest {
	r.nameContains = &nameContains
	return r
}

// Filter for price levels whose &#x60;name&#x60; starts with this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameContains&#x60; or &#x60;nameEndsWith&#x60;.
func (r ApiQuickbooksDesktopPriceLevelsGetRequest) NameStartsWith(nameStartsWith string) ApiQuickbooksDesktopPriceLevelsGetRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Filter for price levels whose &#x60;name&#x60; ends with this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameContains&#x60; or &#x60;nameStartsWith&#x60;.
func (r ApiQuickbooksDesktopPriceLevelsGetRequest) NameEndsWith(nameEndsWith string) ApiQuickbooksDesktopPriceLevelsGetRequest {
	r.nameEndsWith = &nameEndsWith
	return r
}

// Filter for price levels whose &#x60;name&#x60; is alphabetically greater than or equal to this value.
func (r ApiQuickbooksDesktopPriceLevelsGetRequest) NameFrom(nameFrom string) ApiQuickbooksDesktopPriceLevelsGetRequest {
	r.nameFrom = &nameFrom
	return r
}

// Filter for price levels whose &#x60;name&#x60; is alphabetically less than or equal to this value.
func (r ApiQuickbooksDesktopPriceLevelsGetRequest) NameTo(nameTo string) ApiQuickbooksDesktopPriceLevelsGetRequest {
	r.nameTo = &nameTo
	return r
}

// Filter for price levels containing these items.
func (r ApiQuickbooksDesktopPriceLevelsGetRequest) ItemIds(itemIds []string) ApiQuickbooksDesktopPriceLevelsGetRequest {
	r.itemIds = &itemIds
	return r
}

// Filter for price levels in these currencies.
func (r ApiQuickbooksDesktopPriceLevelsGetRequest) CurrencyIds(currencyIds []string) ApiQuickbooksDesktopPriceLevelsGetRequest {
	r.currencyIds = &currencyIds
	return r
}

func (r ApiQuickbooksDesktopPriceLevelsGetRequest) Execute() (*QuickbooksDesktopPriceLevelsGet200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopPriceLevelsGetExecute(r)
}

/*
QuickbooksDesktopPriceLevelsGet List all price levels

Returns a list of price levels. NOTE: QuickBooks Desktop does not support pagination for price levels; hence, there is no `cursor` parameter. Users typically have few price levels.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopPriceLevelsGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopPriceLevelsGet(ctx context.Context) ApiQuickbooksDesktopPriceLevelsGetRequest {
	return ApiQuickbooksDesktopPriceLevelsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopPriceLevelsGet200Response
func (a *DefaultAPIService) QuickbooksDesktopPriceLevelsGetExecute(r ApiQuickbooksDesktopPriceLevelsGetRequest) (*QuickbooksDesktopPriceLevelsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopPriceLevelsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopPriceLevelsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/price-levels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.names != nil {
		t := *r.names
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "names", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "names", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	} else {
		var defaultValue string = "active"
		r.status = &defaultValue
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.nameContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameContains", r.nameContains, "form", "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameStartsWith", r.nameStartsWith, "form", "")
	}
	if r.nameEndsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameEndsWith", r.nameEndsWith, "form", "")
	}
	if r.nameFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameFrom", r.nameFrom, "form", "")
	}
	if r.nameTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameTo", r.nameTo, "form", "")
	}
	if r.itemIds != nil {
		t := *r.itemIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "itemIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "itemIds", t, "form", "multi")
		}
	}
	if r.currencyIds != nil {
		t := *r.currencyIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopPriceLevelsIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopPriceLevelsIdGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopPriceLevelsIdGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopPriceLevelsIdGetRequest) Execute() (*QbdPriceLevel, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopPriceLevelsIdGetExecute(r)
}

/*
QuickbooksDesktopPriceLevelsIdGet Retrieve a price level

Retrieves a price level by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the price level to retrieve.
 @return ApiQuickbooksDesktopPriceLevelsIdGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopPriceLevelsIdGet(ctx context.Context, id string) ApiQuickbooksDesktopPriceLevelsIdGetRequest {
	return ApiQuickbooksDesktopPriceLevelsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdPriceLevel
func (a *DefaultAPIService) QuickbooksDesktopPriceLevelsIdGetExecute(r ApiQuickbooksDesktopPriceLevelsIdGetRequest) (*QbdPriceLevel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdPriceLevel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopPriceLevelsIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/price-levels/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopPriceLevelsIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
	quickbooksDesktopPriceLevelsIdPostRequest *QuickbooksDesktopPriceLevelsIdPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopPriceLevelsIdPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopPriceLevelsIdPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopPriceLevelsIdPostRequest) QuickbooksDesktopPriceLevelsIdPostRequest(quickbooksDesktopPriceLevelsIdPostRequest QuickbooksDesktopPriceLevelsIdPostRequest) ApiQuickbooksDesktopPriceLevelsIdPostRequest {
	r.quickbooksDesktopPriceLevelsIdPostRequest = &quickbooksDesktopPriceLevelsIdPostRequest
	return r
}

func (r ApiQuickbooksDesktopPriceLevelsIdPostRequest) Execute() (*QbdPriceLevel, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopPriceLevelsIdPostExecute(r)
}

/*
QuickbooksDesktopPriceLevelsIdPost Update a price level

Updates an existing price level.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the price level to update.
 @return ApiQuickbooksDesktopPriceLevelsIdPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopPriceLevelsIdPost(ctx context.Context, id string) ApiQuickbooksDesktopPriceLevelsIdPostRequest {
	return ApiQuickbooksDesktopPriceLevelsIdPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdPriceLevel
func (a *DefaultAPIService) QuickbooksDesktopPriceLevelsIdPostExecute(r ApiQuickbooksDesktopPriceLevelsIdPostRequest) (*QbdPriceLevel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdPriceLevel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopPriceLevelsIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/price-levels/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopPriceLevelsIdPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopPriceLevelsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	quickbooksDesktopPriceLevelsPostRequest *QuickbooksDesktopPriceLevelsPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopPriceLevelsPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopPriceLevelsPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopPriceLevelsPostRequest) QuickbooksDesktopPriceLevelsPostRequest(quickbooksDesktopPriceLevelsPostRequest QuickbooksDesktopPriceLevelsPostRequest) ApiQuickbooksDesktopPriceLevelsPostRequest {
	r.quickbooksDesktopPriceLevelsPostRequest = &quickbooksDesktopPriceLevelsPostRequest
	return r
}

func (r ApiQuickbooksDesktopPriceLevelsPostRequest) Execute() (*QbdPriceLevel, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopPriceLevelsPostExecute(r)
}

/*
QuickbooksDesktopPriceLevelsPost Create a price level

Creates a new price level.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopPriceLevelsPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopPriceLevelsPost(ctx context.Context) ApiQuickbooksDesktopPriceLevelsPostRequest {
	return ApiQuickbooksDesktopPriceLevelsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QbdPriceLevel
func (a *DefaultAPIService) QuickbooksDesktopPriceLevelsPostExecute(r ApiQuickbooksDesktopPriceLevelsPostRequest) (*QbdPriceLevel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdPriceLevel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopPriceLevelsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/price-levels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopPriceLevelsPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopPurchaseOrdersGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	ids *[]string
	refNumbers *[]string
	limit *int32
	cursor *string
	updatedAfter *string
	updatedBefore *string
	transactionDateFrom *string
	transactionDateTo *string
	vendorIds *[]string
	accountIds *[]string
	refNumberContains *string
	refNumberStartsWith *string
	refNumberEndsWith *string
	refNumberFrom *string
	refNumberTo *string
	currencyIds *[]string
	includeLineItems *bool
	includeLinkedTransactions *bool
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopPurchaseOrdersGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopPurchaseOrdersGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

// Filter for specific purchase orders by their QuickBooks-assigned unique identifier(s).  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopPurchaseOrdersGetRequest) Ids(ids []string) ApiQuickbooksDesktopPurchaseOrdersGetRequest {
	r.ids = &ids
	return r
}

// Filter for specific purchase orders by their ref-number(s), case-sensitive. In QuickBooks, ref-numbers are not required to be unique and can be arbitrarily changed by the QuickBooks user.  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopPurchaseOrdersGetRequest) RefNumbers(refNumbers []string) ApiQuickbooksDesktopPurchaseOrdersGetRequest {
	r.refNumbers = &refNumbers
	return r
}

// The maximum number of objects to return. Accepts values ranging from 1 to 150, defaults to 150. When used with cursor-based pagination, this parameter controls how many results are returned per page. To paginate through results, combine this with the &#x60;cursor&#x60; parameter. Each response will include a &#x60;nextCursor&#x60; value that can be passed to subsequent requests to retrieve the next page of results.
func (r ApiQuickbooksDesktopPurchaseOrdersGetRequest) Limit(limit int32) ApiQuickbooksDesktopPurchaseOrdersGetRequest {
	r.limit = &limit
	return r
}

// The pagination token to fetch the next set of results when paginating with the &#x60;limit&#x60; parameter. Do not include this parameter on the first call. Use the &#x60;nextCursor&#x60; value returned in the previous response to request subsequent results.
func (r ApiQuickbooksDesktopPurchaseOrdersGetRequest) Cursor(cursor string) ApiQuickbooksDesktopPurchaseOrdersGetRequest {
	r.cursor = &cursor
	return r
}

// Filter for purchase orders updated on or after this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 00:00:00 of that day.
func (r ApiQuickbooksDesktopPurchaseOrdersGetRequest) UpdatedAfter(updatedAfter string) ApiQuickbooksDesktopPurchaseOrdersGetRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Filter for purchase orders updated on or before this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 23:59:59 of that day.
func (r ApiQuickbooksDesktopPurchaseOrdersGetRequest) UpdatedBefore(updatedBefore string) ApiQuickbooksDesktopPurchaseOrdersGetRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Filter for purchase orders whose &#x60;date&#x60; field is on or after this date, in ISO 8601 format (YYYY-MM-DD).
func (r ApiQuickbooksDesktopPurchaseOrdersGetRequest) TransactionDateFrom(transactionDateFrom string) ApiQuickbooksDesktopPurchaseOrdersGetRequest {
	r.transactionDateFrom = &transactionDateFrom
	return r
}

// Filter for purchase orders whose &#x60;date&#x60; field is on or before this date, in ISO 8601 format (YYYY-MM-DD).
func (r ApiQuickbooksDesktopPurchaseOrdersGetRequest) TransactionDateTo(transactionDateTo string) ApiQuickbooksDesktopPurchaseOrdersGetRequest {
	r.transactionDateTo = &transactionDateTo
	return r
}

// Filter for purchase orders sent to these vendors.
func (r ApiQuickbooksDesktopPurchaseOrdersGetRequest) VendorIds(vendorIds []string) ApiQuickbooksDesktopPurchaseOrdersGetRequest {
	r.vendorIds = &vendorIds
	return r
}

// Filter for purchase orders associated with these accounts.
func (r ApiQuickbooksDesktopPurchaseOrdersGetRequest) AccountIds(accountIds []string) ApiQuickbooksDesktopPurchaseOrdersGetRequest {
	r.accountIds = &accountIds
	return r
}

// Filter for purchase orders whose &#x60;refNumber&#x60; contains this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberStartsWith&#x60; or &#x60;refNumberEndsWith&#x60;.
func (r ApiQuickbooksDesktopPurchaseOrdersGetRequest) RefNumberContains(refNumberContains string) ApiQuickbooksDesktopPurchaseOrdersGetRequest {
	r.refNumberContains = &refNumberContains
	return r
}

// Filter for purchase orders whose &#x60;refNumber&#x60; starts with this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberContains&#x60; or &#x60;refNumberEndsWith&#x60;.
func (r ApiQuickbooksDesktopPurchaseOrdersGetRequest) RefNumberStartsWith(refNumberStartsWith string) ApiQuickbooksDesktopPurchaseOrdersGetRequest {
	r.refNumberStartsWith = &refNumberStartsWith
	return r
}

// Filter for purchase orders whose &#x60;refNumber&#x60; ends with this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberContains&#x60; or &#x60;refNumberStartsWith&#x60;.
func (r ApiQuickbooksDesktopPurchaseOrdersGetRequest) RefNumberEndsWith(refNumberEndsWith string) ApiQuickbooksDesktopPurchaseOrdersGetRequest {
	r.refNumberEndsWith = &refNumberEndsWith
	return r
}

// Filter for purchase orders whose &#x60;refNumber&#x60; is greater than or equal to this value. If omitted, the range will begin with the first number of the list. Uses a numerical comparison for values that contain only digits; otherwise, uses a lexicographical comparison.
func (r ApiQuickbooksDesktopPurchaseOrdersGetRequest) RefNumberFrom(refNumberFrom string) ApiQuickbooksDesktopPurchaseOrdersGetRequest {
	r.refNumberFrom = &refNumberFrom
	return r
}

// Filter for purchase orders whose &#x60;refNumber&#x60; is less than or equal to this value. If omitted, the range will end with the last number of the list. Uses a numerical comparison for values that contain only digits; otherwise, uses a lexicographical comparison.
func (r ApiQuickbooksDesktopPurchaseOrdersGetRequest) RefNumberTo(refNumberTo string) ApiQuickbooksDesktopPurchaseOrdersGetRequest {
	r.refNumberTo = &refNumberTo
	return r
}

// Filter for purchase orders in these currencies.
func (r ApiQuickbooksDesktopPurchaseOrdersGetRequest) CurrencyIds(currencyIds []string) ApiQuickbooksDesktopPurchaseOrdersGetRequest {
	r.currencyIds = &currencyIds
	return r
}

// Whether to include line items in the response. Defaults to &#x60;true&#x60;.
func (r ApiQuickbooksDesktopPurchaseOrdersGetRequest) IncludeLineItems(includeLineItems bool) ApiQuickbooksDesktopPurchaseOrdersGetRequest {
	r.includeLineItems = &includeLineItems
	return r
}

// Whether to include linked transactions in the response. Defaults to &#x60;false&#x60;. For example, a payment linked to the corresponding purchase order.
func (r ApiQuickbooksDesktopPurchaseOrdersGetRequest) IncludeLinkedTransactions(includeLinkedTransactions bool) ApiQuickbooksDesktopPurchaseOrdersGetRequest {
	r.includeLinkedTransactions = &includeLinkedTransactions
	return r
}

func (r ApiQuickbooksDesktopPurchaseOrdersGetRequest) Execute() (*QuickbooksDesktopPurchaseOrdersGet200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopPurchaseOrdersGetExecute(r)
}

/*
QuickbooksDesktopPurchaseOrdersGet List all purchase orders

Returns a list of purchase orders. Use the `cursor` parameter to paginate through the results.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopPurchaseOrdersGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopPurchaseOrdersGet(ctx context.Context) ApiQuickbooksDesktopPurchaseOrdersGetRequest {
	return ApiQuickbooksDesktopPurchaseOrdersGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopPurchaseOrdersGet200Response
func (a *DefaultAPIService) QuickbooksDesktopPurchaseOrdersGetExecute(r ApiQuickbooksDesktopPurchaseOrdersGetRequest) (*QuickbooksDesktopPurchaseOrdersGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopPurchaseOrdersGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopPurchaseOrdersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/purchase-orders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.refNumbers != nil {
		t := *r.refNumbers
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "refNumbers", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "refNumbers", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 150
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.transactionDateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDateFrom", r.transactionDateFrom, "form", "")
	}
	if r.transactionDateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDateTo", r.transactionDateTo, "form", "")
	}
	if r.vendorIds != nil {
		t := *r.vendorIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vendorIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vendorIds", t, "form", "multi")
		}
	}
	if r.accountIds != nil {
		t := *r.accountIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountIds", t, "form", "multi")
		}
	}
	if r.refNumberContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberContains", r.refNumberContains, "form", "")
	}
	if r.refNumberStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberStartsWith", r.refNumberStartsWith, "form", "")
	}
	if r.refNumberEndsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberEndsWith", r.refNumberEndsWith, "form", "")
	}
	if r.refNumberFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberFrom", r.refNumberFrom, "form", "")
	}
	if r.refNumberTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberTo", r.refNumberTo, "form", "")
	}
	if r.currencyIds != nil {
		t := *r.currencyIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", t, "form", "multi")
		}
	}
	if r.includeLineItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLineItems", r.includeLineItems, "form", "")
	} else {
		var defaultValue bool = true
		r.includeLineItems = &defaultValue
	}
	if r.includeLinkedTransactions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLinkedTransactions", r.includeLinkedTransactions, "form", "")
	} else {
		var defaultValue bool = false
		r.includeLinkedTransactions = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopPurchaseOrdersIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopPurchaseOrdersIdDeleteRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopPurchaseOrdersIdDeleteRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopPurchaseOrdersIdDeleteRequest) Execute() (*QuickbooksDesktopPurchaseOrdersIdDelete200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopPurchaseOrdersIdDeleteExecute(r)
}

/*
QuickbooksDesktopPurchaseOrdersIdDelete Delete a purchase order

Permanently deletes a a purchase order. The deletion will fail if the purchase order is currently in use or has any linked transactions that are in use.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the purchase order to delete.
 @return ApiQuickbooksDesktopPurchaseOrdersIdDeleteRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopPurchaseOrdersIdDelete(ctx context.Context, id string) ApiQuickbooksDesktopPurchaseOrdersIdDeleteRequest {
	return ApiQuickbooksDesktopPurchaseOrdersIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopPurchaseOrdersIdDelete200Response
func (a *DefaultAPIService) QuickbooksDesktopPurchaseOrdersIdDeleteExecute(r ApiQuickbooksDesktopPurchaseOrdersIdDeleteRequest) (*QuickbooksDesktopPurchaseOrdersIdDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopPurchaseOrdersIdDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopPurchaseOrdersIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/purchase-orders/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopPurchaseOrdersIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopPurchaseOrdersIdGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopPurchaseOrdersIdGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopPurchaseOrdersIdGetRequest) Execute() (*QbdPurchaseOrder, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopPurchaseOrdersIdGetExecute(r)
}

/*
QuickbooksDesktopPurchaseOrdersIdGet Retrieve a purchase order

Retrieves a purchase order by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the purchase order to retrieve.
 @return ApiQuickbooksDesktopPurchaseOrdersIdGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopPurchaseOrdersIdGet(ctx context.Context, id string) ApiQuickbooksDesktopPurchaseOrdersIdGetRequest {
	return ApiQuickbooksDesktopPurchaseOrdersIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdPurchaseOrder
func (a *DefaultAPIService) QuickbooksDesktopPurchaseOrdersIdGetExecute(r ApiQuickbooksDesktopPurchaseOrdersIdGetRequest) (*QbdPurchaseOrder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdPurchaseOrder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopPurchaseOrdersIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/purchase-orders/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopPurchaseOrdersIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
	quickbooksDesktopPurchaseOrdersIdPostRequest *QuickbooksDesktopPurchaseOrdersIdPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopPurchaseOrdersIdPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopPurchaseOrdersIdPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopPurchaseOrdersIdPostRequest) QuickbooksDesktopPurchaseOrdersIdPostRequest(quickbooksDesktopPurchaseOrdersIdPostRequest QuickbooksDesktopPurchaseOrdersIdPostRequest) ApiQuickbooksDesktopPurchaseOrdersIdPostRequest {
	r.quickbooksDesktopPurchaseOrdersIdPostRequest = &quickbooksDesktopPurchaseOrdersIdPostRequest
	return r
}

func (r ApiQuickbooksDesktopPurchaseOrdersIdPostRequest) Execute() (*QbdPurchaseOrder, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopPurchaseOrdersIdPostExecute(r)
}

/*
QuickbooksDesktopPurchaseOrdersIdPost Update a purchase order

Updates an existing purchase order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the purchase order to update.
 @return ApiQuickbooksDesktopPurchaseOrdersIdPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopPurchaseOrdersIdPost(ctx context.Context, id string) ApiQuickbooksDesktopPurchaseOrdersIdPostRequest {
	return ApiQuickbooksDesktopPurchaseOrdersIdPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdPurchaseOrder
func (a *DefaultAPIService) QuickbooksDesktopPurchaseOrdersIdPostExecute(r ApiQuickbooksDesktopPurchaseOrdersIdPostRequest) (*QbdPurchaseOrder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdPurchaseOrder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopPurchaseOrdersIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/purchase-orders/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopPurchaseOrdersIdPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopPurchaseOrdersPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	quickbooksDesktopPurchaseOrdersPostRequest *QuickbooksDesktopPurchaseOrdersPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopPurchaseOrdersPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopPurchaseOrdersPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopPurchaseOrdersPostRequest) QuickbooksDesktopPurchaseOrdersPostRequest(quickbooksDesktopPurchaseOrdersPostRequest QuickbooksDesktopPurchaseOrdersPostRequest) ApiQuickbooksDesktopPurchaseOrdersPostRequest {
	r.quickbooksDesktopPurchaseOrdersPostRequest = &quickbooksDesktopPurchaseOrdersPostRequest
	return r
}

func (r ApiQuickbooksDesktopPurchaseOrdersPostRequest) Execute() (*QbdPurchaseOrder, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopPurchaseOrdersPostExecute(r)
}

/*
QuickbooksDesktopPurchaseOrdersPost Create a purchase order

Creates a new purchase order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopPurchaseOrdersPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopPurchaseOrdersPost(ctx context.Context) ApiQuickbooksDesktopPurchaseOrdersPostRequest {
	return ApiQuickbooksDesktopPurchaseOrdersPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QbdPurchaseOrder
func (a *DefaultAPIService) QuickbooksDesktopPurchaseOrdersPostExecute(r ApiQuickbooksDesktopPurchaseOrdersPostRequest) (*QbdPurchaseOrder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdPurchaseOrder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopPurchaseOrdersPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/purchase-orders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopPurchaseOrdersPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopReceivePaymentsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	ids *[]string
	refNumbers *[]string
	limit *int32
	cursor *string
	updatedAfter *string
	updatedBefore *string
	transactionDateFrom *string
	transactionDateTo *string
	customerIds *[]string
	accountIds *[]string
	refNumberContains *string
	refNumberStartsWith *string
	refNumberEndsWith *string
	refNumberFrom *string
	refNumberTo *string
	currencyIds *[]string
	includeLineItems *bool
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopReceivePaymentsGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopReceivePaymentsGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

// Filter for specific receive-payments by their QuickBooks-assigned unique identifier(s).  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopReceivePaymentsGetRequest) Ids(ids []string) ApiQuickbooksDesktopReceivePaymentsGetRequest {
	r.ids = &ids
	return r
}

// Filter for specific receive-payments by their ref-number(s), case-sensitive. In QuickBooks, ref-numbers are not required to be unique and can be arbitrarily changed by the QuickBooks user.  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopReceivePaymentsGetRequest) RefNumbers(refNumbers []string) ApiQuickbooksDesktopReceivePaymentsGetRequest {
	r.refNumbers = &refNumbers
	return r
}

// The maximum number of objects to return. Accepts values ranging from 1 to 150, defaults to 150. When used with cursor-based pagination, this parameter controls how many results are returned per page. To paginate through results, combine this with the &#x60;cursor&#x60; parameter. Each response will include a &#x60;nextCursor&#x60; value that can be passed to subsequent requests to retrieve the next page of results.
func (r ApiQuickbooksDesktopReceivePaymentsGetRequest) Limit(limit int32) ApiQuickbooksDesktopReceivePaymentsGetRequest {
	r.limit = &limit
	return r
}

// The pagination token to fetch the next set of results when paginating with the &#x60;limit&#x60; parameter. Do not include this parameter on the first call. Use the &#x60;nextCursor&#x60; value returned in the previous response to request subsequent results.
func (r ApiQuickbooksDesktopReceivePaymentsGetRequest) Cursor(cursor string) ApiQuickbooksDesktopReceivePaymentsGetRequest {
	r.cursor = &cursor
	return r
}

// Filter for receive-payments updated on or after this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 00:00:00 of that day.
func (r ApiQuickbooksDesktopReceivePaymentsGetRequest) UpdatedAfter(updatedAfter string) ApiQuickbooksDesktopReceivePaymentsGetRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Filter for receive-payments updated on or before this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 23:59:59 of that day.
func (r ApiQuickbooksDesktopReceivePaymentsGetRequest) UpdatedBefore(updatedBefore string) ApiQuickbooksDesktopReceivePaymentsGetRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Filter for receive-payments whose &#x60;date&#x60; field is on or after this date, in ISO 8601 format (YYYY-MM-DD).
func (r ApiQuickbooksDesktopReceivePaymentsGetRequest) TransactionDateFrom(transactionDateFrom string) ApiQuickbooksDesktopReceivePaymentsGetRequest {
	r.transactionDateFrom = &transactionDateFrom
	return r
}

// Filter for receive-payments whose &#x60;date&#x60; field is on or before this date, in ISO 8601 format (YYYY-MM-DD).
func (r ApiQuickbooksDesktopReceivePaymentsGetRequest) TransactionDateTo(transactionDateTo string) ApiQuickbooksDesktopReceivePaymentsGetRequest {
	r.transactionDateTo = &transactionDateTo
	return r
}

// Filter for receive-payments received from these customers.
func (r ApiQuickbooksDesktopReceivePaymentsGetRequest) CustomerIds(customerIds []string) ApiQuickbooksDesktopReceivePaymentsGetRequest {
	r.customerIds = &customerIds
	return r
}

// Filter for receive-payments associated with these accounts.
func (r ApiQuickbooksDesktopReceivePaymentsGetRequest) AccountIds(accountIds []string) ApiQuickbooksDesktopReceivePaymentsGetRequest {
	r.accountIds = &accountIds
	return r
}

// Filter for receive-payments whose &#x60;refNumber&#x60; contains this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberStartsWith&#x60; or &#x60;refNumberEndsWith&#x60;.
func (r ApiQuickbooksDesktopReceivePaymentsGetRequest) RefNumberContains(refNumberContains string) ApiQuickbooksDesktopReceivePaymentsGetRequest {
	r.refNumberContains = &refNumberContains
	return r
}

// Filter for receive-payments whose &#x60;refNumber&#x60; starts with this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberContains&#x60; or &#x60;refNumberEndsWith&#x60;.
func (r ApiQuickbooksDesktopReceivePaymentsGetRequest) RefNumberStartsWith(refNumberStartsWith string) ApiQuickbooksDesktopReceivePaymentsGetRequest {
	r.refNumberStartsWith = &refNumberStartsWith
	return r
}

// Filter for receive-payments whose &#x60;refNumber&#x60; ends with this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberContains&#x60; or &#x60;refNumberStartsWith&#x60;.
func (r ApiQuickbooksDesktopReceivePaymentsGetRequest) RefNumberEndsWith(refNumberEndsWith string) ApiQuickbooksDesktopReceivePaymentsGetRequest {
	r.refNumberEndsWith = &refNumberEndsWith
	return r
}

// Filter for receive-payments whose &#x60;refNumber&#x60; is greater than or equal to this value. If omitted, the range will begin with the first number of the list. Uses a numerical comparison for values that contain only digits; otherwise, uses a lexicographical comparison.
func (r ApiQuickbooksDesktopReceivePaymentsGetRequest) RefNumberFrom(refNumberFrom string) ApiQuickbooksDesktopReceivePaymentsGetRequest {
	r.refNumberFrom = &refNumberFrom
	return r
}

// Filter for receive-payments whose &#x60;refNumber&#x60; is less than or equal to this value. If omitted, the range will end with the last number of the list. Uses a numerical comparison for values that contain only digits; otherwise, uses a lexicographical comparison.
func (r ApiQuickbooksDesktopReceivePaymentsGetRequest) RefNumberTo(refNumberTo string) ApiQuickbooksDesktopReceivePaymentsGetRequest {
	r.refNumberTo = &refNumberTo
	return r
}

// Filter for receive-payments in these currencies.
func (r ApiQuickbooksDesktopReceivePaymentsGetRequest) CurrencyIds(currencyIds []string) ApiQuickbooksDesktopReceivePaymentsGetRequest {
	r.currencyIds = &currencyIds
	return r
}

// Whether to include line items in the response. Defaults to &#x60;true&#x60;.
func (r ApiQuickbooksDesktopReceivePaymentsGetRequest) IncludeLineItems(includeLineItems bool) ApiQuickbooksDesktopReceivePaymentsGetRequest {
	r.includeLineItems = &includeLineItems
	return r
}

func (r ApiQuickbooksDesktopReceivePaymentsGetRequest) Execute() (*QuickbooksDesktopReceivePaymentsGet200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopReceivePaymentsGetExecute(r)
}

/*
QuickbooksDesktopReceivePaymentsGet List all receive-payments

Returns a list of receive-payments. Use the `cursor` parameter to paginate through the results.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopReceivePaymentsGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopReceivePaymentsGet(ctx context.Context) ApiQuickbooksDesktopReceivePaymentsGetRequest {
	return ApiQuickbooksDesktopReceivePaymentsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopReceivePaymentsGet200Response
func (a *DefaultAPIService) QuickbooksDesktopReceivePaymentsGetExecute(r ApiQuickbooksDesktopReceivePaymentsGetRequest) (*QuickbooksDesktopReceivePaymentsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopReceivePaymentsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopReceivePaymentsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/receive-payments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.refNumbers != nil {
		t := *r.refNumbers
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "refNumbers", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "refNumbers", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 150
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.transactionDateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDateFrom", r.transactionDateFrom, "form", "")
	}
	if r.transactionDateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDateTo", r.transactionDateTo, "form", "")
	}
	if r.customerIds != nil {
		t := *r.customerIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "customerIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "customerIds", t, "form", "multi")
		}
	}
	if r.accountIds != nil {
		t := *r.accountIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountIds", t, "form", "multi")
		}
	}
	if r.refNumberContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberContains", r.refNumberContains, "form", "")
	}
	if r.refNumberStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberStartsWith", r.refNumberStartsWith, "form", "")
	}
	if r.refNumberEndsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberEndsWith", r.refNumberEndsWith, "form", "")
	}
	if r.refNumberFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberFrom", r.refNumberFrom, "form", "")
	}
	if r.refNumberTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberTo", r.refNumberTo, "form", "")
	}
	if r.currencyIds != nil {
		t := *r.currencyIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", t, "form", "multi")
		}
	}
	if r.includeLineItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLineItems", r.includeLineItems, "form", "")
	} else {
		var defaultValue bool = true
		r.includeLineItems = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopReceivePaymentsIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopReceivePaymentsIdDeleteRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopReceivePaymentsIdDeleteRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopReceivePaymentsIdDeleteRequest) Execute() (*QuickbooksDesktopReceivePaymentsIdDelete200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopReceivePaymentsIdDeleteExecute(r)
}

/*
QuickbooksDesktopReceivePaymentsIdDelete Delete a receive-payment

Permanently deletes a a receive-payment. The deletion will fail if the receive-payment is currently in use or has any linked transactions that are in use.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the receive-payment to delete.
 @return ApiQuickbooksDesktopReceivePaymentsIdDeleteRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopReceivePaymentsIdDelete(ctx context.Context, id string) ApiQuickbooksDesktopReceivePaymentsIdDeleteRequest {
	return ApiQuickbooksDesktopReceivePaymentsIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopReceivePaymentsIdDelete200Response
func (a *DefaultAPIService) QuickbooksDesktopReceivePaymentsIdDeleteExecute(r ApiQuickbooksDesktopReceivePaymentsIdDeleteRequest) (*QuickbooksDesktopReceivePaymentsIdDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopReceivePaymentsIdDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopReceivePaymentsIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/receive-payments/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopReceivePaymentsIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopReceivePaymentsIdGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopReceivePaymentsIdGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopReceivePaymentsIdGetRequest) Execute() (*QbdReceivePayment, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopReceivePaymentsIdGetExecute(r)
}

/*
QuickbooksDesktopReceivePaymentsIdGet Retrieve a receive-payment

Retrieves a receive-payment by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the receive-payment to retrieve.
 @return ApiQuickbooksDesktopReceivePaymentsIdGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopReceivePaymentsIdGet(ctx context.Context, id string) ApiQuickbooksDesktopReceivePaymentsIdGetRequest {
	return ApiQuickbooksDesktopReceivePaymentsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdReceivePayment
func (a *DefaultAPIService) QuickbooksDesktopReceivePaymentsIdGetExecute(r ApiQuickbooksDesktopReceivePaymentsIdGetRequest) (*QbdReceivePayment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdReceivePayment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopReceivePaymentsIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/receive-payments/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopReceivePaymentsIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
	quickbooksDesktopReceivePaymentsIdPostRequest *QuickbooksDesktopReceivePaymentsIdPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopReceivePaymentsIdPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopReceivePaymentsIdPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopReceivePaymentsIdPostRequest) QuickbooksDesktopReceivePaymentsIdPostRequest(quickbooksDesktopReceivePaymentsIdPostRequest QuickbooksDesktopReceivePaymentsIdPostRequest) ApiQuickbooksDesktopReceivePaymentsIdPostRequest {
	r.quickbooksDesktopReceivePaymentsIdPostRequest = &quickbooksDesktopReceivePaymentsIdPostRequest
	return r
}

func (r ApiQuickbooksDesktopReceivePaymentsIdPostRequest) Execute() (*QbdReceivePayment, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopReceivePaymentsIdPostExecute(r)
}

/*
QuickbooksDesktopReceivePaymentsIdPost Update a receive-payment

Updates an existing receive-payment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the receive-payment to update.
 @return ApiQuickbooksDesktopReceivePaymentsIdPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopReceivePaymentsIdPost(ctx context.Context, id string) ApiQuickbooksDesktopReceivePaymentsIdPostRequest {
	return ApiQuickbooksDesktopReceivePaymentsIdPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdReceivePayment
func (a *DefaultAPIService) QuickbooksDesktopReceivePaymentsIdPostExecute(r ApiQuickbooksDesktopReceivePaymentsIdPostRequest) (*QbdReceivePayment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdReceivePayment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopReceivePaymentsIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/receive-payments/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopReceivePaymentsIdPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopReceivePaymentsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	quickbooksDesktopReceivePaymentsPostRequest *QuickbooksDesktopReceivePaymentsPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopReceivePaymentsPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopReceivePaymentsPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopReceivePaymentsPostRequest) QuickbooksDesktopReceivePaymentsPostRequest(quickbooksDesktopReceivePaymentsPostRequest QuickbooksDesktopReceivePaymentsPostRequest) ApiQuickbooksDesktopReceivePaymentsPostRequest {
	r.quickbooksDesktopReceivePaymentsPostRequest = &quickbooksDesktopReceivePaymentsPostRequest
	return r
}

func (r ApiQuickbooksDesktopReceivePaymentsPostRequest) Execute() (*QbdReceivePayment, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopReceivePaymentsPostExecute(r)
}

/*
QuickbooksDesktopReceivePaymentsPost Create a receive-payment

Creates a new receive-payment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopReceivePaymentsPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopReceivePaymentsPost(ctx context.Context) ApiQuickbooksDesktopReceivePaymentsPostRequest {
	return ApiQuickbooksDesktopReceivePaymentsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QbdReceivePayment
func (a *DefaultAPIService) QuickbooksDesktopReceivePaymentsPostExecute(r ApiQuickbooksDesktopReceivePaymentsPostRequest) (*QbdReceivePayment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdReceivePayment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopReceivePaymentsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/receive-payments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopReceivePaymentsPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopSalesOrdersGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	ids *[]string
	refNumbers *[]string
	limit *int32
	cursor *string
	updatedAfter *string
	updatedBefore *string
	transactionDateFrom *string
	transactionDateTo *string
	customerIds *[]string
	refNumberContains *string
	refNumberStartsWith *string
	refNumberEndsWith *string
	refNumberFrom *string
	refNumberTo *string
	currencyIds *[]string
	includeLineItems *bool
	includeLinkedTransactions *bool
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopSalesOrdersGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopSalesOrdersGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

// Filter for specific sales orders by their QuickBooks-assigned unique identifier(s).  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopSalesOrdersGetRequest) Ids(ids []string) ApiQuickbooksDesktopSalesOrdersGetRequest {
	r.ids = &ids
	return r
}

// Filter for specific sales orders by their ref-number(s), case-sensitive. In QuickBooks, ref-numbers are not required to be unique and can be arbitrarily changed by the QuickBooks user.  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopSalesOrdersGetRequest) RefNumbers(refNumbers []string) ApiQuickbooksDesktopSalesOrdersGetRequest {
	r.refNumbers = &refNumbers
	return r
}

// The maximum number of objects to return. Accepts values ranging from 1 to 150, defaults to 150. When used with cursor-based pagination, this parameter controls how many results are returned per page. To paginate through results, combine this with the &#x60;cursor&#x60; parameter. Each response will include a &#x60;nextCursor&#x60; value that can be passed to subsequent requests to retrieve the next page of results.
func (r ApiQuickbooksDesktopSalesOrdersGetRequest) Limit(limit int32) ApiQuickbooksDesktopSalesOrdersGetRequest {
	r.limit = &limit
	return r
}

// The pagination token to fetch the next set of results when paginating with the &#x60;limit&#x60; parameter. Do not include this parameter on the first call. Use the &#x60;nextCursor&#x60; value returned in the previous response to request subsequent results.
func (r ApiQuickbooksDesktopSalesOrdersGetRequest) Cursor(cursor string) ApiQuickbooksDesktopSalesOrdersGetRequest {
	r.cursor = &cursor
	return r
}

// Filter for sales orders updated on or after this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 00:00:00 of that day.
func (r ApiQuickbooksDesktopSalesOrdersGetRequest) UpdatedAfter(updatedAfter string) ApiQuickbooksDesktopSalesOrdersGetRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Filter for sales orders updated on or before this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 23:59:59 of that day.
func (r ApiQuickbooksDesktopSalesOrdersGetRequest) UpdatedBefore(updatedBefore string) ApiQuickbooksDesktopSalesOrdersGetRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Filter for sales orders whose &#x60;date&#x60; field is on or after this date, in ISO 8601 format (YYYY-MM-DD).
func (r ApiQuickbooksDesktopSalesOrdersGetRequest) TransactionDateFrom(transactionDateFrom string) ApiQuickbooksDesktopSalesOrdersGetRequest {
	r.transactionDateFrom = &transactionDateFrom
	return r
}

// Filter for sales orders whose &#x60;date&#x60; field is on or before this date, in ISO 8601 format (YYYY-MM-DD).
func (r ApiQuickbooksDesktopSalesOrdersGetRequest) TransactionDateTo(transactionDateTo string) ApiQuickbooksDesktopSalesOrdersGetRequest {
	r.transactionDateTo = &transactionDateTo
	return r
}

// Filter for sales orders created for these customers.
func (r ApiQuickbooksDesktopSalesOrdersGetRequest) CustomerIds(customerIds []string) ApiQuickbooksDesktopSalesOrdersGetRequest {
	r.customerIds = &customerIds
	return r
}

// Filter for sales orders whose &#x60;refNumber&#x60; contains this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberStartsWith&#x60; or &#x60;refNumberEndsWith&#x60;.
func (r ApiQuickbooksDesktopSalesOrdersGetRequest) RefNumberContains(refNumberContains string) ApiQuickbooksDesktopSalesOrdersGetRequest {
	r.refNumberContains = &refNumberContains
	return r
}

// Filter for sales orders whose &#x60;refNumber&#x60; starts with this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberContains&#x60; or &#x60;refNumberEndsWith&#x60;.
func (r ApiQuickbooksDesktopSalesOrdersGetRequest) RefNumberStartsWith(refNumberStartsWith string) ApiQuickbooksDesktopSalesOrdersGetRequest {
	r.refNumberStartsWith = &refNumberStartsWith
	return r
}

// Filter for sales orders whose &#x60;refNumber&#x60; ends with this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberContains&#x60; or &#x60;refNumberStartsWith&#x60;.
func (r ApiQuickbooksDesktopSalesOrdersGetRequest) RefNumberEndsWith(refNumberEndsWith string) ApiQuickbooksDesktopSalesOrdersGetRequest {
	r.refNumberEndsWith = &refNumberEndsWith
	return r
}

// Filter for sales orders whose &#x60;refNumber&#x60; is greater than or equal to this value. If omitted, the range will begin with the first number of the list. Uses a numerical comparison for values that contain only digits; otherwise, uses a lexicographical comparison.
func (r ApiQuickbooksDesktopSalesOrdersGetRequest) RefNumberFrom(refNumberFrom string) ApiQuickbooksDesktopSalesOrdersGetRequest {
	r.refNumberFrom = &refNumberFrom
	return r
}

// Filter for sales orders whose &#x60;refNumber&#x60; is less than or equal to this value. If omitted, the range will end with the last number of the list. Uses a numerical comparison for values that contain only digits; otherwise, uses a lexicographical comparison.
func (r ApiQuickbooksDesktopSalesOrdersGetRequest) RefNumberTo(refNumberTo string) ApiQuickbooksDesktopSalesOrdersGetRequest {
	r.refNumberTo = &refNumberTo
	return r
}

// Filter for sales orders in these currencies.
func (r ApiQuickbooksDesktopSalesOrdersGetRequest) CurrencyIds(currencyIds []string) ApiQuickbooksDesktopSalesOrdersGetRequest {
	r.currencyIds = &currencyIds
	return r
}

// Whether to include line items in the response. Defaults to &#x60;true&#x60;.
func (r ApiQuickbooksDesktopSalesOrdersGetRequest) IncludeLineItems(includeLineItems bool) ApiQuickbooksDesktopSalesOrdersGetRequest {
	r.includeLineItems = &includeLineItems
	return r
}

// Whether to include linked transactions in the response. Defaults to &#x60;false&#x60;. For example, a payment linked to the corresponding sales order.
func (r ApiQuickbooksDesktopSalesOrdersGetRequest) IncludeLinkedTransactions(includeLinkedTransactions bool) ApiQuickbooksDesktopSalesOrdersGetRequest {
	r.includeLinkedTransactions = &includeLinkedTransactions
	return r
}

func (r ApiQuickbooksDesktopSalesOrdersGetRequest) Execute() (*QuickbooksDesktopSalesOrdersGet200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopSalesOrdersGetExecute(r)
}

/*
QuickbooksDesktopSalesOrdersGet List all sales orders

Returns a list of sales orders. Use the `cursor` parameter to paginate through the results.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopSalesOrdersGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopSalesOrdersGet(ctx context.Context) ApiQuickbooksDesktopSalesOrdersGetRequest {
	return ApiQuickbooksDesktopSalesOrdersGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopSalesOrdersGet200Response
func (a *DefaultAPIService) QuickbooksDesktopSalesOrdersGetExecute(r ApiQuickbooksDesktopSalesOrdersGetRequest) (*QuickbooksDesktopSalesOrdersGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopSalesOrdersGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopSalesOrdersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/sales-orders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.refNumbers != nil {
		t := *r.refNumbers
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "refNumbers", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "refNumbers", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 150
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.transactionDateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDateFrom", r.transactionDateFrom, "form", "")
	}
	if r.transactionDateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDateTo", r.transactionDateTo, "form", "")
	}
	if r.customerIds != nil {
		t := *r.customerIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "customerIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "customerIds", t, "form", "multi")
		}
	}
	if r.refNumberContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberContains", r.refNumberContains, "form", "")
	}
	if r.refNumberStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberStartsWith", r.refNumberStartsWith, "form", "")
	}
	if r.refNumberEndsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberEndsWith", r.refNumberEndsWith, "form", "")
	}
	if r.refNumberFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberFrom", r.refNumberFrom, "form", "")
	}
	if r.refNumberTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberTo", r.refNumberTo, "form", "")
	}
	if r.currencyIds != nil {
		t := *r.currencyIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", t, "form", "multi")
		}
	}
	if r.includeLineItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLineItems", r.includeLineItems, "form", "")
	} else {
		var defaultValue bool = true
		r.includeLineItems = &defaultValue
	}
	if r.includeLinkedTransactions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLinkedTransactions", r.includeLinkedTransactions, "form", "")
	} else {
		var defaultValue bool = false
		r.includeLinkedTransactions = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopSalesOrdersIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopSalesOrdersIdDeleteRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopSalesOrdersIdDeleteRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopSalesOrdersIdDeleteRequest) Execute() (*QuickbooksDesktopSalesOrdersIdDelete200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopSalesOrdersIdDeleteExecute(r)
}

/*
QuickbooksDesktopSalesOrdersIdDelete Delete a sales order

Permanently deletes a a sales order. The deletion will fail if the sales order is currently in use or has any linked transactions that are in use.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the sales order to delete.
 @return ApiQuickbooksDesktopSalesOrdersIdDeleteRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopSalesOrdersIdDelete(ctx context.Context, id string) ApiQuickbooksDesktopSalesOrdersIdDeleteRequest {
	return ApiQuickbooksDesktopSalesOrdersIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopSalesOrdersIdDelete200Response
func (a *DefaultAPIService) QuickbooksDesktopSalesOrdersIdDeleteExecute(r ApiQuickbooksDesktopSalesOrdersIdDeleteRequest) (*QuickbooksDesktopSalesOrdersIdDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopSalesOrdersIdDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopSalesOrdersIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/sales-orders/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopSalesOrdersIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopSalesOrdersIdGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopSalesOrdersIdGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopSalesOrdersIdGetRequest) Execute() (*QbdSalesOrder, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopSalesOrdersIdGetExecute(r)
}

/*
QuickbooksDesktopSalesOrdersIdGet Retrieve a sales order

Retrieves a sales order by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the sales order to retrieve.
 @return ApiQuickbooksDesktopSalesOrdersIdGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopSalesOrdersIdGet(ctx context.Context, id string) ApiQuickbooksDesktopSalesOrdersIdGetRequest {
	return ApiQuickbooksDesktopSalesOrdersIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdSalesOrder
func (a *DefaultAPIService) QuickbooksDesktopSalesOrdersIdGetExecute(r ApiQuickbooksDesktopSalesOrdersIdGetRequest) (*QbdSalesOrder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdSalesOrder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopSalesOrdersIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/sales-orders/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopSalesOrdersIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
	quickbooksDesktopSalesOrdersIdPostRequest *QuickbooksDesktopSalesOrdersIdPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopSalesOrdersIdPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopSalesOrdersIdPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopSalesOrdersIdPostRequest) QuickbooksDesktopSalesOrdersIdPostRequest(quickbooksDesktopSalesOrdersIdPostRequest QuickbooksDesktopSalesOrdersIdPostRequest) ApiQuickbooksDesktopSalesOrdersIdPostRequest {
	r.quickbooksDesktopSalesOrdersIdPostRequest = &quickbooksDesktopSalesOrdersIdPostRequest
	return r
}

func (r ApiQuickbooksDesktopSalesOrdersIdPostRequest) Execute() (*QbdSalesOrder, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopSalesOrdersIdPostExecute(r)
}

/*
QuickbooksDesktopSalesOrdersIdPost Update a sales order

Updates an existing sales order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the sales order to update.
 @return ApiQuickbooksDesktopSalesOrdersIdPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopSalesOrdersIdPost(ctx context.Context, id string) ApiQuickbooksDesktopSalesOrdersIdPostRequest {
	return ApiQuickbooksDesktopSalesOrdersIdPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdSalesOrder
func (a *DefaultAPIService) QuickbooksDesktopSalesOrdersIdPostExecute(r ApiQuickbooksDesktopSalesOrdersIdPostRequest) (*QbdSalesOrder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdSalesOrder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopSalesOrdersIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/sales-orders/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopSalesOrdersIdPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopSalesOrdersPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	quickbooksDesktopSalesOrdersPostRequest *QuickbooksDesktopSalesOrdersPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopSalesOrdersPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopSalesOrdersPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopSalesOrdersPostRequest) QuickbooksDesktopSalesOrdersPostRequest(quickbooksDesktopSalesOrdersPostRequest QuickbooksDesktopSalesOrdersPostRequest) ApiQuickbooksDesktopSalesOrdersPostRequest {
	r.quickbooksDesktopSalesOrdersPostRequest = &quickbooksDesktopSalesOrdersPostRequest
	return r
}

func (r ApiQuickbooksDesktopSalesOrdersPostRequest) Execute() (*QbdSalesOrder, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopSalesOrdersPostExecute(r)
}

/*
QuickbooksDesktopSalesOrdersPost Create a sales order

Creates a new sales order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopSalesOrdersPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopSalesOrdersPost(ctx context.Context) ApiQuickbooksDesktopSalesOrdersPostRequest {
	return ApiQuickbooksDesktopSalesOrdersPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QbdSalesOrder
func (a *DefaultAPIService) QuickbooksDesktopSalesOrdersPostExecute(r ApiQuickbooksDesktopSalesOrdersPostRequest) (*QbdSalesOrder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdSalesOrder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopSalesOrdersPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/sales-orders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopSalesOrdersPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopSalesReceiptsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	ids *[]string
	refNumbers *[]string
	limit *int32
	cursor *string
	updatedAfter *string
	updatedBefore *string
	transactionDateFrom *string
	transactionDateTo *string
	customerIds *[]string
	accountIds *[]string
	refNumberContains *string
	refNumberStartsWith *string
	refNumberEndsWith *string
	refNumberFrom *string
	refNumberTo *string
	currencyIds *[]string
	includeLineItems *bool
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopSalesReceiptsGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopSalesReceiptsGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

// Filter for specific sales receipts by their QuickBooks-assigned unique identifier(s).  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopSalesReceiptsGetRequest) Ids(ids []string) ApiQuickbooksDesktopSalesReceiptsGetRequest {
	r.ids = &ids
	return r
}

// Filter for specific sales receipts by their ref-number(s), case-sensitive. In QuickBooks, ref-numbers are not required to be unique and can be arbitrarily changed by the QuickBooks user.  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopSalesReceiptsGetRequest) RefNumbers(refNumbers []string) ApiQuickbooksDesktopSalesReceiptsGetRequest {
	r.refNumbers = &refNumbers
	return r
}

// The maximum number of objects to return. Accepts values ranging from 1 to 150, defaults to 150. When used with cursor-based pagination, this parameter controls how many results are returned per page. To paginate through results, combine this with the &#x60;cursor&#x60; parameter. Each response will include a &#x60;nextCursor&#x60; value that can be passed to subsequent requests to retrieve the next page of results.
func (r ApiQuickbooksDesktopSalesReceiptsGetRequest) Limit(limit int32) ApiQuickbooksDesktopSalesReceiptsGetRequest {
	r.limit = &limit
	return r
}

// The pagination token to fetch the next set of results when paginating with the &#x60;limit&#x60; parameter. Do not include this parameter on the first call. Use the &#x60;nextCursor&#x60; value returned in the previous response to request subsequent results.
func (r ApiQuickbooksDesktopSalesReceiptsGetRequest) Cursor(cursor string) ApiQuickbooksDesktopSalesReceiptsGetRequest {
	r.cursor = &cursor
	return r
}

// Filter for sales receipts updated on or after this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 00:00:00 of that day.
func (r ApiQuickbooksDesktopSalesReceiptsGetRequest) UpdatedAfter(updatedAfter string) ApiQuickbooksDesktopSalesReceiptsGetRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Filter for sales receipts updated on or before this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 23:59:59 of that day.
func (r ApiQuickbooksDesktopSalesReceiptsGetRequest) UpdatedBefore(updatedBefore string) ApiQuickbooksDesktopSalesReceiptsGetRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Filter for sales receipts whose &#x60;date&#x60; field is on or after this date, in ISO 8601 format (YYYY-MM-DD).
func (r ApiQuickbooksDesktopSalesReceiptsGetRequest) TransactionDateFrom(transactionDateFrom string) ApiQuickbooksDesktopSalesReceiptsGetRequest {
	r.transactionDateFrom = &transactionDateFrom
	return r
}

// Filter for sales receipts whose &#x60;date&#x60; field is on or before this date, in ISO 8601 format (YYYY-MM-DD).
func (r ApiQuickbooksDesktopSalesReceiptsGetRequest) TransactionDateTo(transactionDateTo string) ApiQuickbooksDesktopSalesReceiptsGetRequest {
	r.transactionDateTo = &transactionDateTo
	return r
}

// Filter for sales receipts created for these customers.
func (r ApiQuickbooksDesktopSalesReceiptsGetRequest) CustomerIds(customerIds []string) ApiQuickbooksDesktopSalesReceiptsGetRequest {
	r.customerIds = &customerIds
	return r
}

// Filter for sales receipts associated with these accounts.
func (r ApiQuickbooksDesktopSalesReceiptsGetRequest) AccountIds(accountIds []string) ApiQuickbooksDesktopSalesReceiptsGetRequest {
	r.accountIds = &accountIds
	return r
}

// Filter for sales receipts whose &#x60;refNumber&#x60; contains this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberStartsWith&#x60; or &#x60;refNumberEndsWith&#x60;.
func (r ApiQuickbooksDesktopSalesReceiptsGetRequest) RefNumberContains(refNumberContains string) ApiQuickbooksDesktopSalesReceiptsGetRequest {
	r.refNumberContains = &refNumberContains
	return r
}

// Filter for sales receipts whose &#x60;refNumber&#x60; starts with this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberContains&#x60; or &#x60;refNumberEndsWith&#x60;.
func (r ApiQuickbooksDesktopSalesReceiptsGetRequest) RefNumberStartsWith(refNumberStartsWith string) ApiQuickbooksDesktopSalesReceiptsGetRequest {
	r.refNumberStartsWith = &refNumberStartsWith
	return r
}

// Filter for sales receipts whose &#x60;refNumber&#x60; ends with this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberContains&#x60; or &#x60;refNumberStartsWith&#x60;.
func (r ApiQuickbooksDesktopSalesReceiptsGetRequest) RefNumberEndsWith(refNumberEndsWith string) ApiQuickbooksDesktopSalesReceiptsGetRequest {
	r.refNumberEndsWith = &refNumberEndsWith
	return r
}

// Filter for sales receipts whose &#x60;refNumber&#x60; is greater than or equal to this value. If omitted, the range will begin with the first number of the list. Uses a numerical comparison for values that contain only digits; otherwise, uses a lexicographical comparison.
func (r ApiQuickbooksDesktopSalesReceiptsGetRequest) RefNumberFrom(refNumberFrom string) ApiQuickbooksDesktopSalesReceiptsGetRequest {
	r.refNumberFrom = &refNumberFrom
	return r
}

// Filter for sales receipts whose &#x60;refNumber&#x60; is less than or equal to this value. If omitted, the range will end with the last number of the list. Uses a numerical comparison for values that contain only digits; otherwise, uses a lexicographical comparison.
func (r ApiQuickbooksDesktopSalesReceiptsGetRequest) RefNumberTo(refNumberTo string) ApiQuickbooksDesktopSalesReceiptsGetRequest {
	r.refNumberTo = &refNumberTo
	return r
}

// Filter for sales receipts in these currencies.
func (r ApiQuickbooksDesktopSalesReceiptsGetRequest) CurrencyIds(currencyIds []string) ApiQuickbooksDesktopSalesReceiptsGetRequest {
	r.currencyIds = &currencyIds
	return r
}

// Whether to include line items in the response. Defaults to &#x60;true&#x60;.
func (r ApiQuickbooksDesktopSalesReceiptsGetRequest) IncludeLineItems(includeLineItems bool) ApiQuickbooksDesktopSalesReceiptsGetRequest {
	r.includeLineItems = &includeLineItems
	return r
}

func (r ApiQuickbooksDesktopSalesReceiptsGetRequest) Execute() (*QuickbooksDesktopSalesReceiptsGet200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopSalesReceiptsGetExecute(r)
}

/*
QuickbooksDesktopSalesReceiptsGet List all sales receipts

Returns a list of sales receipts. Use the `cursor` parameter to paginate through the results.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopSalesReceiptsGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopSalesReceiptsGet(ctx context.Context) ApiQuickbooksDesktopSalesReceiptsGetRequest {
	return ApiQuickbooksDesktopSalesReceiptsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopSalesReceiptsGet200Response
func (a *DefaultAPIService) QuickbooksDesktopSalesReceiptsGetExecute(r ApiQuickbooksDesktopSalesReceiptsGetRequest) (*QuickbooksDesktopSalesReceiptsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopSalesReceiptsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopSalesReceiptsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/sales-receipts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.refNumbers != nil {
		t := *r.refNumbers
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "refNumbers", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "refNumbers", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 150
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.transactionDateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDateFrom", r.transactionDateFrom, "form", "")
	}
	if r.transactionDateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDateTo", r.transactionDateTo, "form", "")
	}
	if r.customerIds != nil {
		t := *r.customerIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "customerIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "customerIds", t, "form", "multi")
		}
	}
	if r.accountIds != nil {
		t := *r.accountIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountIds", t, "form", "multi")
		}
	}
	if r.refNumberContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberContains", r.refNumberContains, "form", "")
	}
	if r.refNumberStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberStartsWith", r.refNumberStartsWith, "form", "")
	}
	if r.refNumberEndsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberEndsWith", r.refNumberEndsWith, "form", "")
	}
	if r.refNumberFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberFrom", r.refNumberFrom, "form", "")
	}
	if r.refNumberTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberTo", r.refNumberTo, "form", "")
	}
	if r.currencyIds != nil {
		t := *r.currencyIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", t, "form", "multi")
		}
	}
	if r.includeLineItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLineItems", r.includeLineItems, "form", "")
	} else {
		var defaultValue bool = true
		r.includeLineItems = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopSalesReceiptsIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopSalesReceiptsIdDeleteRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopSalesReceiptsIdDeleteRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopSalesReceiptsIdDeleteRequest) Execute() (*QuickbooksDesktopSalesReceiptsIdDelete200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopSalesReceiptsIdDeleteExecute(r)
}

/*
QuickbooksDesktopSalesReceiptsIdDelete Delete a sales receipt

Permanently deletes a a sales receipt. The deletion will fail if the sales receipt is currently in use or has any linked transactions that are in use.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the sales receipt to delete.
 @return ApiQuickbooksDesktopSalesReceiptsIdDeleteRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopSalesReceiptsIdDelete(ctx context.Context, id string) ApiQuickbooksDesktopSalesReceiptsIdDeleteRequest {
	return ApiQuickbooksDesktopSalesReceiptsIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopSalesReceiptsIdDelete200Response
func (a *DefaultAPIService) QuickbooksDesktopSalesReceiptsIdDeleteExecute(r ApiQuickbooksDesktopSalesReceiptsIdDeleteRequest) (*QuickbooksDesktopSalesReceiptsIdDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopSalesReceiptsIdDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopSalesReceiptsIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/sales-receipts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopSalesReceiptsIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopSalesReceiptsIdGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopSalesReceiptsIdGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopSalesReceiptsIdGetRequest) Execute() (*QbdSalesReceipt, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopSalesReceiptsIdGetExecute(r)
}

/*
QuickbooksDesktopSalesReceiptsIdGet Retrieve a sales receipt

Retrieves a sales receipt by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the sales receipt to retrieve.
 @return ApiQuickbooksDesktopSalesReceiptsIdGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopSalesReceiptsIdGet(ctx context.Context, id string) ApiQuickbooksDesktopSalesReceiptsIdGetRequest {
	return ApiQuickbooksDesktopSalesReceiptsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdSalesReceipt
func (a *DefaultAPIService) QuickbooksDesktopSalesReceiptsIdGetExecute(r ApiQuickbooksDesktopSalesReceiptsIdGetRequest) (*QbdSalesReceipt, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdSalesReceipt
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopSalesReceiptsIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/sales-receipts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopSalesReceiptsIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
	quickbooksDesktopSalesReceiptsIdPostRequest *QuickbooksDesktopSalesReceiptsIdPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopSalesReceiptsIdPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopSalesReceiptsIdPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopSalesReceiptsIdPostRequest) QuickbooksDesktopSalesReceiptsIdPostRequest(quickbooksDesktopSalesReceiptsIdPostRequest QuickbooksDesktopSalesReceiptsIdPostRequest) ApiQuickbooksDesktopSalesReceiptsIdPostRequest {
	r.quickbooksDesktopSalesReceiptsIdPostRequest = &quickbooksDesktopSalesReceiptsIdPostRequest
	return r
}

func (r ApiQuickbooksDesktopSalesReceiptsIdPostRequest) Execute() (*QbdSalesReceipt, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopSalesReceiptsIdPostExecute(r)
}

/*
QuickbooksDesktopSalesReceiptsIdPost Update a sales receipt

Updates an existing sales receipt.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the sales receipt to update.
 @return ApiQuickbooksDesktopSalesReceiptsIdPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopSalesReceiptsIdPost(ctx context.Context, id string) ApiQuickbooksDesktopSalesReceiptsIdPostRequest {
	return ApiQuickbooksDesktopSalesReceiptsIdPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdSalesReceipt
func (a *DefaultAPIService) QuickbooksDesktopSalesReceiptsIdPostExecute(r ApiQuickbooksDesktopSalesReceiptsIdPostRequest) (*QbdSalesReceipt, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdSalesReceipt
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopSalesReceiptsIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/sales-receipts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopSalesReceiptsIdPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopSalesReceiptsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	quickbooksDesktopSalesReceiptsPostRequest *QuickbooksDesktopSalesReceiptsPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopSalesReceiptsPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopSalesReceiptsPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopSalesReceiptsPostRequest) QuickbooksDesktopSalesReceiptsPostRequest(quickbooksDesktopSalesReceiptsPostRequest QuickbooksDesktopSalesReceiptsPostRequest) ApiQuickbooksDesktopSalesReceiptsPostRequest {
	r.quickbooksDesktopSalesReceiptsPostRequest = &quickbooksDesktopSalesReceiptsPostRequest
	return r
}

func (r ApiQuickbooksDesktopSalesReceiptsPostRequest) Execute() (*QbdSalesReceipt, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopSalesReceiptsPostExecute(r)
}

/*
QuickbooksDesktopSalesReceiptsPost Create a sales receipt

Creates a new sales receipt.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopSalesReceiptsPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopSalesReceiptsPost(ctx context.Context) ApiQuickbooksDesktopSalesReceiptsPostRequest {
	return ApiQuickbooksDesktopSalesReceiptsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QbdSalesReceipt
func (a *DefaultAPIService) QuickbooksDesktopSalesReceiptsPostExecute(r ApiQuickbooksDesktopSalesReceiptsPostRequest) (*QbdSalesReceipt, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdSalesReceipt
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopSalesReceiptsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/sales-receipts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopSalesReceiptsPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopSalesRepresentativesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	ids *[]string
	names *[]string
	limit *int32
	status *string
	updatedAfter *string
	updatedBefore *string
	nameContains *string
	nameStartsWith *string
	nameEndsWith *string
	nameFrom *string
	nameTo *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopSalesRepresentativesGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopSalesRepresentativesGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

// Filter for specific sales representatives by their QuickBooks-assigned unique identifier(s).  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopSalesRepresentativesGetRequest) Ids(ids []string) ApiQuickbooksDesktopSalesRepresentativesGetRequest {
	r.ids = &ids
	return r
}

// Filter for specific sales representatives by their name(s), case-insensitive. Like &#x60;id&#x60;, &#x60;name&#x60; is a unique identifier for a sales representative.  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopSalesRepresentativesGetRequest) Names(names []string) ApiQuickbooksDesktopSalesRepresentativesGetRequest {
	r.names = &names
	return r
}

// The maximum number of objects to return.  **IMPORTANT**: QuickBooks Desktop does not support cursor-based pagination for sales representatives. This parameter will limit the response size, but you cannot fetch subsequent results using a cursor. For pagination, use the name-range parameters instead (e.g., &#x60;nameFrom&#x3D;A&amp;nameTo&#x3D;B&#x60;).  When this parameter is omitted, the endpoint returns all sales representatives without limit, unlike paginated endpoints which default to 150 records. This is acceptable because sales representatives typically have low record counts.
func (r ApiQuickbooksDesktopSalesRepresentativesGetRequest) Limit(limit int32) ApiQuickbooksDesktopSalesRepresentativesGetRequest {
	r.limit = &limit
	return r
}

// Filter for sales representatives that are active, inactive, or both.
func (r ApiQuickbooksDesktopSalesRepresentativesGetRequest) Status(status string) ApiQuickbooksDesktopSalesRepresentativesGetRequest {
	r.status = &status
	return r
}

// Filter for sales representatives updated on or after this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 00:00:00 of that day.
func (r ApiQuickbooksDesktopSalesRepresentativesGetRequest) UpdatedAfter(updatedAfter string) ApiQuickbooksDesktopSalesRepresentativesGetRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Filter for sales representatives updated on or before this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 23:59:59 of that day.
func (r ApiQuickbooksDesktopSalesRepresentativesGetRequest) UpdatedBefore(updatedBefore string) ApiQuickbooksDesktopSalesRepresentativesGetRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Filter for sales representatives whose &#x60;name&#x60; contains this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameStartsWith&#x60; or &#x60;nameEndsWith&#x60;.
func (r ApiQuickbooksDesktopSalesRepresentativesGetRequest) NameContains(nameContains string) ApiQuickbooksDesktopSalesRepresentativesGetRequest {
	r.nameContains = &nameContains
	return r
}

// Filter for sales representatives whose &#x60;name&#x60; starts with this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameContains&#x60; or &#x60;nameEndsWith&#x60;.
func (r ApiQuickbooksDesktopSalesRepresentativesGetRequest) NameStartsWith(nameStartsWith string) ApiQuickbooksDesktopSalesRepresentativesGetRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Filter for sales representatives whose &#x60;name&#x60; ends with this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameContains&#x60; or &#x60;nameStartsWith&#x60;.
func (r ApiQuickbooksDesktopSalesRepresentativesGetRequest) NameEndsWith(nameEndsWith string) ApiQuickbooksDesktopSalesRepresentativesGetRequest {
	r.nameEndsWith = &nameEndsWith
	return r
}

// Filter for sales representatives whose &#x60;name&#x60; is alphabetically greater than or equal to this value.
func (r ApiQuickbooksDesktopSalesRepresentativesGetRequest) NameFrom(nameFrom string) ApiQuickbooksDesktopSalesRepresentativesGetRequest {
	r.nameFrom = &nameFrom
	return r
}

// Filter for sales representatives whose &#x60;name&#x60; is alphabetically less than or equal to this value.
func (r ApiQuickbooksDesktopSalesRepresentativesGetRequest) NameTo(nameTo string) ApiQuickbooksDesktopSalesRepresentativesGetRequest {
	r.nameTo = &nameTo
	return r
}

func (r ApiQuickbooksDesktopSalesRepresentativesGetRequest) Execute() (*QuickbooksDesktopSalesRepresentativesGet200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopSalesRepresentativesGetExecute(r)
}

/*
QuickbooksDesktopSalesRepresentativesGet List all sales representatives

Returns a list of sales representatives. NOTE: QuickBooks Desktop does not support pagination for sales representatives; hence, there is no `cursor` parameter. Users typically have few sales representatives.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopSalesRepresentativesGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopSalesRepresentativesGet(ctx context.Context) ApiQuickbooksDesktopSalesRepresentativesGetRequest {
	return ApiQuickbooksDesktopSalesRepresentativesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopSalesRepresentativesGet200Response
func (a *DefaultAPIService) QuickbooksDesktopSalesRepresentativesGetExecute(r ApiQuickbooksDesktopSalesRepresentativesGetRequest) (*QuickbooksDesktopSalesRepresentativesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopSalesRepresentativesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopSalesRepresentativesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/sales-representatives"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.names != nil {
		t := *r.names
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "names", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "names", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	} else {
		var defaultValue string = "active"
		r.status = &defaultValue
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.nameContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameContains", r.nameContains, "form", "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameStartsWith", r.nameStartsWith, "form", "")
	}
	if r.nameEndsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameEndsWith", r.nameEndsWith, "form", "")
	}
	if r.nameFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameFrom", r.nameFrom, "form", "")
	}
	if r.nameTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameTo", r.nameTo, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopSalesRepresentativesIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopSalesRepresentativesIdGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopSalesRepresentativesIdGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopSalesRepresentativesIdGetRequest) Execute() (*QbdSalesRepresentative, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopSalesRepresentativesIdGetExecute(r)
}

/*
QuickbooksDesktopSalesRepresentativesIdGet Retrieve a sales representative

Retrieves a sales representative by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the sales representative to retrieve.
 @return ApiQuickbooksDesktopSalesRepresentativesIdGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopSalesRepresentativesIdGet(ctx context.Context, id string) ApiQuickbooksDesktopSalesRepresentativesIdGetRequest {
	return ApiQuickbooksDesktopSalesRepresentativesIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdSalesRepresentative
func (a *DefaultAPIService) QuickbooksDesktopSalesRepresentativesIdGetExecute(r ApiQuickbooksDesktopSalesRepresentativesIdGetRequest) (*QbdSalesRepresentative, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdSalesRepresentative
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopSalesRepresentativesIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/sales-representatives/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopSalesRepresentativesIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
	quickbooksDesktopSalesRepresentativesIdPostRequest *QuickbooksDesktopSalesRepresentativesIdPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopSalesRepresentativesIdPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopSalesRepresentativesIdPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopSalesRepresentativesIdPostRequest) QuickbooksDesktopSalesRepresentativesIdPostRequest(quickbooksDesktopSalesRepresentativesIdPostRequest QuickbooksDesktopSalesRepresentativesIdPostRequest) ApiQuickbooksDesktopSalesRepresentativesIdPostRequest {
	r.quickbooksDesktopSalesRepresentativesIdPostRequest = &quickbooksDesktopSalesRepresentativesIdPostRequest
	return r
}

func (r ApiQuickbooksDesktopSalesRepresentativesIdPostRequest) Execute() (*QbdSalesRepresentative, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopSalesRepresentativesIdPostExecute(r)
}

/*
QuickbooksDesktopSalesRepresentativesIdPost Update a sales representative

Updates an existing sales representative.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the sales representative to update.
 @return ApiQuickbooksDesktopSalesRepresentativesIdPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopSalesRepresentativesIdPost(ctx context.Context, id string) ApiQuickbooksDesktopSalesRepresentativesIdPostRequest {
	return ApiQuickbooksDesktopSalesRepresentativesIdPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdSalesRepresentative
func (a *DefaultAPIService) QuickbooksDesktopSalesRepresentativesIdPostExecute(r ApiQuickbooksDesktopSalesRepresentativesIdPostRequest) (*QbdSalesRepresentative, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdSalesRepresentative
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopSalesRepresentativesIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/sales-representatives/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopSalesRepresentativesIdPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopSalesRepresentativesPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	quickbooksDesktopSalesRepresentativesPostRequest *QuickbooksDesktopSalesRepresentativesPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopSalesRepresentativesPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopSalesRepresentativesPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopSalesRepresentativesPostRequest) QuickbooksDesktopSalesRepresentativesPostRequest(quickbooksDesktopSalesRepresentativesPostRequest QuickbooksDesktopSalesRepresentativesPostRequest) ApiQuickbooksDesktopSalesRepresentativesPostRequest {
	r.quickbooksDesktopSalesRepresentativesPostRequest = &quickbooksDesktopSalesRepresentativesPostRequest
	return r
}

func (r ApiQuickbooksDesktopSalesRepresentativesPostRequest) Execute() (*QbdSalesRepresentative, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopSalesRepresentativesPostExecute(r)
}

/*
QuickbooksDesktopSalesRepresentativesPost Create a sales representative

Creates a new sales representative.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopSalesRepresentativesPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopSalesRepresentativesPost(ctx context.Context) ApiQuickbooksDesktopSalesRepresentativesPostRequest {
	return ApiQuickbooksDesktopSalesRepresentativesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QbdSalesRepresentative
func (a *DefaultAPIService) QuickbooksDesktopSalesRepresentativesPostExecute(r ApiQuickbooksDesktopSalesRepresentativesPostRequest) (*QbdSalesRepresentative, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdSalesRepresentative
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopSalesRepresentativesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/sales-representatives"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopSalesRepresentativesPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopSalesTaxCodesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	ids *[]string
	names *[]string
	limit *int32
	status *string
	updatedAfter *string
	updatedBefore *string
	nameContains *string
	nameStartsWith *string
	nameEndsWith *string
	nameFrom *string
	nameTo *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopSalesTaxCodesGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopSalesTaxCodesGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

// Filter for specific sales-tax codes by their QuickBooks-assigned unique identifier(s).  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopSalesTaxCodesGetRequest) Ids(ids []string) ApiQuickbooksDesktopSalesTaxCodesGetRequest {
	r.ids = &ids
	return r
}

// Filter for specific sales-tax codes by their name(s), case-insensitive. Like &#x60;id&#x60;, &#x60;name&#x60; is a unique identifier for a sales-tax code.  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopSalesTaxCodesGetRequest) Names(names []string) ApiQuickbooksDesktopSalesTaxCodesGetRequest {
	r.names = &names
	return r
}

// The maximum number of objects to return.  **IMPORTANT**: QuickBooks Desktop does not support cursor-based pagination for sales-tax codes. This parameter will limit the response size, but you cannot fetch subsequent results using a cursor. For pagination, use the name-range parameters instead (e.g., &#x60;nameFrom&#x3D;A&amp;nameTo&#x3D;B&#x60;).  When this parameter is omitted, the endpoint returns all sales-tax codes without limit, unlike paginated endpoints which default to 150 records. This is acceptable because sales-tax codes typically have low record counts.
func (r ApiQuickbooksDesktopSalesTaxCodesGetRequest) Limit(limit int32) ApiQuickbooksDesktopSalesTaxCodesGetRequest {
	r.limit = &limit
	return r
}

// Filter for sales-tax codes that are active, inactive, or both.
func (r ApiQuickbooksDesktopSalesTaxCodesGetRequest) Status(status string) ApiQuickbooksDesktopSalesTaxCodesGetRequest {
	r.status = &status
	return r
}

// Filter for sales-tax codes updated on or after this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 00:00:00 of that day.
func (r ApiQuickbooksDesktopSalesTaxCodesGetRequest) UpdatedAfter(updatedAfter string) ApiQuickbooksDesktopSalesTaxCodesGetRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Filter for sales-tax codes updated on or before this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 23:59:59 of that day.
func (r ApiQuickbooksDesktopSalesTaxCodesGetRequest) UpdatedBefore(updatedBefore string) ApiQuickbooksDesktopSalesTaxCodesGetRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Filter for sales-tax codes whose &#x60;name&#x60; contains this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameStartsWith&#x60; or &#x60;nameEndsWith&#x60;.
func (r ApiQuickbooksDesktopSalesTaxCodesGetRequest) NameContains(nameContains string) ApiQuickbooksDesktopSalesTaxCodesGetRequest {
	r.nameContains = &nameContains
	return r
}

// Filter for sales-tax codes whose &#x60;name&#x60; starts with this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameContains&#x60; or &#x60;nameEndsWith&#x60;.
func (r ApiQuickbooksDesktopSalesTaxCodesGetRequest) NameStartsWith(nameStartsWith string) ApiQuickbooksDesktopSalesTaxCodesGetRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Filter for sales-tax codes whose &#x60;name&#x60; ends with this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameContains&#x60; or &#x60;nameStartsWith&#x60;.
func (r ApiQuickbooksDesktopSalesTaxCodesGetRequest) NameEndsWith(nameEndsWith string) ApiQuickbooksDesktopSalesTaxCodesGetRequest {
	r.nameEndsWith = &nameEndsWith
	return r
}

// Filter for sales-tax codes whose &#x60;name&#x60; is alphabetically greater than or equal to this value.
func (r ApiQuickbooksDesktopSalesTaxCodesGetRequest) NameFrom(nameFrom string) ApiQuickbooksDesktopSalesTaxCodesGetRequest {
	r.nameFrom = &nameFrom
	return r
}

// Filter for sales-tax codes whose &#x60;name&#x60; is alphabetically less than or equal to this value.
func (r ApiQuickbooksDesktopSalesTaxCodesGetRequest) NameTo(nameTo string) ApiQuickbooksDesktopSalesTaxCodesGetRequest {
	r.nameTo = &nameTo
	return r
}

func (r ApiQuickbooksDesktopSalesTaxCodesGetRequest) Execute() (*QuickbooksDesktopSalesTaxCodesGet200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopSalesTaxCodesGetExecute(r)
}

/*
QuickbooksDesktopSalesTaxCodesGet List all sales-tax codes

Returns a list of sales-tax codes. NOTE: QuickBooks Desktop does not support pagination for sales-tax codes; hence, there is no `cursor` parameter. Users typically have few sales-tax codes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopSalesTaxCodesGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopSalesTaxCodesGet(ctx context.Context) ApiQuickbooksDesktopSalesTaxCodesGetRequest {
	return ApiQuickbooksDesktopSalesTaxCodesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopSalesTaxCodesGet200Response
func (a *DefaultAPIService) QuickbooksDesktopSalesTaxCodesGetExecute(r ApiQuickbooksDesktopSalesTaxCodesGetRequest) (*QuickbooksDesktopSalesTaxCodesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopSalesTaxCodesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopSalesTaxCodesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/sales-tax-codes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.names != nil {
		t := *r.names
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "names", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "names", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	} else {
		var defaultValue string = "active"
		r.status = &defaultValue
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.nameContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameContains", r.nameContains, "form", "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameStartsWith", r.nameStartsWith, "form", "")
	}
	if r.nameEndsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameEndsWith", r.nameEndsWith, "form", "")
	}
	if r.nameFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameFrom", r.nameFrom, "form", "")
	}
	if r.nameTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameTo", r.nameTo, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopSalesTaxCodesIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopSalesTaxCodesIdGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopSalesTaxCodesIdGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopSalesTaxCodesIdGetRequest) Execute() (*QbdSalesTaxCode, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopSalesTaxCodesIdGetExecute(r)
}

/*
QuickbooksDesktopSalesTaxCodesIdGet Retrieve a sales-tax code

Retrieves a sales-tax code by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the sales-tax code to retrieve.
 @return ApiQuickbooksDesktopSalesTaxCodesIdGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopSalesTaxCodesIdGet(ctx context.Context, id string) ApiQuickbooksDesktopSalesTaxCodesIdGetRequest {
	return ApiQuickbooksDesktopSalesTaxCodesIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdSalesTaxCode
func (a *DefaultAPIService) QuickbooksDesktopSalesTaxCodesIdGetExecute(r ApiQuickbooksDesktopSalesTaxCodesIdGetRequest) (*QbdSalesTaxCode, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdSalesTaxCode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopSalesTaxCodesIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/sales-tax-codes/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopSalesTaxCodesIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
	quickbooksDesktopSalesTaxCodesIdPostRequest *QuickbooksDesktopSalesTaxCodesIdPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopSalesTaxCodesIdPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopSalesTaxCodesIdPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopSalesTaxCodesIdPostRequest) QuickbooksDesktopSalesTaxCodesIdPostRequest(quickbooksDesktopSalesTaxCodesIdPostRequest QuickbooksDesktopSalesTaxCodesIdPostRequest) ApiQuickbooksDesktopSalesTaxCodesIdPostRequest {
	r.quickbooksDesktopSalesTaxCodesIdPostRequest = &quickbooksDesktopSalesTaxCodesIdPostRequest
	return r
}

func (r ApiQuickbooksDesktopSalesTaxCodesIdPostRequest) Execute() (*QbdSalesTaxCode, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopSalesTaxCodesIdPostExecute(r)
}

/*
QuickbooksDesktopSalesTaxCodesIdPost Update a sales-tax code

Updates an existing sales-tax code.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the sales-tax code to update.
 @return ApiQuickbooksDesktopSalesTaxCodesIdPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopSalesTaxCodesIdPost(ctx context.Context, id string) ApiQuickbooksDesktopSalesTaxCodesIdPostRequest {
	return ApiQuickbooksDesktopSalesTaxCodesIdPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdSalesTaxCode
func (a *DefaultAPIService) QuickbooksDesktopSalesTaxCodesIdPostExecute(r ApiQuickbooksDesktopSalesTaxCodesIdPostRequest) (*QbdSalesTaxCode, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdSalesTaxCode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopSalesTaxCodesIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/sales-tax-codes/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopSalesTaxCodesIdPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopSalesTaxCodesPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	quickbooksDesktopSalesTaxCodesPostRequest *QuickbooksDesktopSalesTaxCodesPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopSalesTaxCodesPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopSalesTaxCodesPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopSalesTaxCodesPostRequest) QuickbooksDesktopSalesTaxCodesPostRequest(quickbooksDesktopSalesTaxCodesPostRequest QuickbooksDesktopSalesTaxCodesPostRequest) ApiQuickbooksDesktopSalesTaxCodesPostRequest {
	r.quickbooksDesktopSalesTaxCodesPostRequest = &quickbooksDesktopSalesTaxCodesPostRequest
	return r
}

func (r ApiQuickbooksDesktopSalesTaxCodesPostRequest) Execute() (*QbdSalesTaxCode, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopSalesTaxCodesPostExecute(r)
}

/*
QuickbooksDesktopSalesTaxCodesPost Create a sales-tax code

Creates a new sales-tax code.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopSalesTaxCodesPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopSalesTaxCodesPost(ctx context.Context) ApiQuickbooksDesktopSalesTaxCodesPostRequest {
	return ApiQuickbooksDesktopSalesTaxCodesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QbdSalesTaxCode
func (a *DefaultAPIService) QuickbooksDesktopSalesTaxCodesPostExecute(r ApiQuickbooksDesktopSalesTaxCodesPostRequest) (*QbdSalesTaxCode, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdSalesTaxCode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopSalesTaxCodesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/sales-tax-codes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopSalesTaxCodesPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopSalesTaxItemsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	ids *[]string
	names *[]string
	limit *int32
	cursor *string
	status *string
	updatedAfter *string
	updatedBefore *string
	nameContains *string
	nameStartsWith *string
	nameEndsWith *string
	nameFrom *string
	nameTo *string
	classIds *[]string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopSalesTaxItemsGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopSalesTaxItemsGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

// Filter for specific sales-tax items by their QuickBooks-assigned unique identifier(s).  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopSalesTaxItemsGetRequest) Ids(ids []string) ApiQuickbooksDesktopSalesTaxItemsGetRequest {
	r.ids = &ids
	return r
}

// Filter for specific sales-tax items by their name(s), case-insensitive. Like &#x60;id&#x60;, &#x60;name&#x60; is a unique identifier for a sales-tax item.  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopSalesTaxItemsGetRequest) Names(names []string) ApiQuickbooksDesktopSalesTaxItemsGetRequest {
	r.names = &names
	return r
}

// The maximum number of objects to return. Accepts values ranging from 1 to 150, defaults to 150. When used with cursor-based pagination, this parameter controls how many results are returned per page. To paginate through results, combine this with the &#x60;cursor&#x60; parameter. Each response will include a &#x60;nextCursor&#x60; value that can be passed to subsequent requests to retrieve the next page of results.
func (r ApiQuickbooksDesktopSalesTaxItemsGetRequest) Limit(limit int32) ApiQuickbooksDesktopSalesTaxItemsGetRequest {
	r.limit = &limit
	return r
}

// The pagination token to fetch the next set of results when paginating with the &#x60;limit&#x60; parameter. Do not include this parameter on the first call. Use the &#x60;nextCursor&#x60; value returned in the previous response to request subsequent results.
func (r ApiQuickbooksDesktopSalesTaxItemsGetRequest) Cursor(cursor string) ApiQuickbooksDesktopSalesTaxItemsGetRequest {
	r.cursor = &cursor
	return r
}

// Filter for sales-tax items that are active, inactive, or both.
func (r ApiQuickbooksDesktopSalesTaxItemsGetRequest) Status(status string) ApiQuickbooksDesktopSalesTaxItemsGetRequest {
	r.status = &status
	return r
}

// Filter for sales-tax items updated on or after this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 00:00:00 of that day.
func (r ApiQuickbooksDesktopSalesTaxItemsGetRequest) UpdatedAfter(updatedAfter string) ApiQuickbooksDesktopSalesTaxItemsGetRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Filter for sales-tax items updated on or before this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 23:59:59 of that day.
func (r ApiQuickbooksDesktopSalesTaxItemsGetRequest) UpdatedBefore(updatedBefore string) ApiQuickbooksDesktopSalesTaxItemsGetRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Filter for sales-tax items whose &#x60;name&#x60; contains this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameStartsWith&#x60; or &#x60;nameEndsWith&#x60;.
func (r ApiQuickbooksDesktopSalesTaxItemsGetRequest) NameContains(nameContains string) ApiQuickbooksDesktopSalesTaxItemsGetRequest {
	r.nameContains = &nameContains
	return r
}

// Filter for sales-tax items whose &#x60;name&#x60; starts with this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameContains&#x60; or &#x60;nameEndsWith&#x60;.
func (r ApiQuickbooksDesktopSalesTaxItemsGetRequest) NameStartsWith(nameStartsWith string) ApiQuickbooksDesktopSalesTaxItemsGetRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Filter for sales-tax items whose &#x60;name&#x60; ends with this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameContains&#x60; or &#x60;nameStartsWith&#x60;.
func (r ApiQuickbooksDesktopSalesTaxItemsGetRequest) NameEndsWith(nameEndsWith string) ApiQuickbooksDesktopSalesTaxItemsGetRequest {
	r.nameEndsWith = &nameEndsWith
	return r
}

// Filter for sales-tax items whose &#x60;name&#x60; is alphabetically greater than or equal to this value.
func (r ApiQuickbooksDesktopSalesTaxItemsGetRequest) NameFrom(nameFrom string) ApiQuickbooksDesktopSalesTaxItemsGetRequest {
	r.nameFrom = &nameFrom
	return r
}

// Filter for sales-tax items whose &#x60;name&#x60; is alphabetically less than or equal to this value.
func (r ApiQuickbooksDesktopSalesTaxItemsGetRequest) NameTo(nameTo string) ApiQuickbooksDesktopSalesTaxItemsGetRequest {
	r.nameTo = &nameTo
	return r
}

// Filter for sales-tax items of these classes. A class is a way end-users can categorize sales-tax items in QuickBooks.
func (r ApiQuickbooksDesktopSalesTaxItemsGetRequest) ClassIds(classIds []string) ApiQuickbooksDesktopSalesTaxItemsGetRequest {
	r.classIds = &classIds
	return r
}

func (r ApiQuickbooksDesktopSalesTaxItemsGetRequest) Execute() (*QuickbooksDesktopSalesTaxItemsGet200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopSalesTaxItemsGetExecute(r)
}

/*
QuickbooksDesktopSalesTaxItemsGet List all sales-tax items

Returns a list of sales-tax items. Use the `cursor` parameter to paginate through the results.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopSalesTaxItemsGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopSalesTaxItemsGet(ctx context.Context) ApiQuickbooksDesktopSalesTaxItemsGetRequest {
	return ApiQuickbooksDesktopSalesTaxItemsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopSalesTaxItemsGet200Response
func (a *DefaultAPIService) QuickbooksDesktopSalesTaxItemsGetExecute(r ApiQuickbooksDesktopSalesTaxItemsGetRequest) (*QuickbooksDesktopSalesTaxItemsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopSalesTaxItemsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopSalesTaxItemsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/sales-tax-items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.names != nil {
		t := *r.names
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "names", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "names", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 150
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	} else {
		var defaultValue string = "active"
		r.status = &defaultValue
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.nameContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameContains", r.nameContains, "form", "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameStartsWith", r.nameStartsWith, "form", "")
	}
	if r.nameEndsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameEndsWith", r.nameEndsWith, "form", "")
	}
	if r.nameFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameFrom", r.nameFrom, "form", "")
	}
	if r.nameTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameTo", r.nameTo, "form", "")
	}
	if r.classIds != nil {
		t := *r.classIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "classIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "classIds", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopSalesTaxItemsIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopSalesTaxItemsIdGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopSalesTaxItemsIdGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopSalesTaxItemsIdGetRequest) Execute() (*QbdSalesTaxItem, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopSalesTaxItemsIdGetExecute(r)
}

/*
QuickbooksDesktopSalesTaxItemsIdGet Retrieve a sales-tax item

Retrieves a sales-tax item by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the sales-tax item to retrieve.
 @return ApiQuickbooksDesktopSalesTaxItemsIdGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopSalesTaxItemsIdGet(ctx context.Context, id string) ApiQuickbooksDesktopSalesTaxItemsIdGetRequest {
	return ApiQuickbooksDesktopSalesTaxItemsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdSalesTaxItem
func (a *DefaultAPIService) QuickbooksDesktopSalesTaxItemsIdGetExecute(r ApiQuickbooksDesktopSalesTaxItemsIdGetRequest) (*QbdSalesTaxItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdSalesTaxItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopSalesTaxItemsIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/sales-tax-items/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopSalesTaxItemsIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
	quickbooksDesktopSalesTaxItemsIdPostRequest *QuickbooksDesktopSalesTaxItemsIdPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopSalesTaxItemsIdPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopSalesTaxItemsIdPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopSalesTaxItemsIdPostRequest) QuickbooksDesktopSalesTaxItemsIdPostRequest(quickbooksDesktopSalesTaxItemsIdPostRequest QuickbooksDesktopSalesTaxItemsIdPostRequest) ApiQuickbooksDesktopSalesTaxItemsIdPostRequest {
	r.quickbooksDesktopSalesTaxItemsIdPostRequest = &quickbooksDesktopSalesTaxItemsIdPostRequest
	return r
}

func (r ApiQuickbooksDesktopSalesTaxItemsIdPostRequest) Execute() (*QbdSalesTaxItem, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopSalesTaxItemsIdPostExecute(r)
}

/*
QuickbooksDesktopSalesTaxItemsIdPost Update a sales-tax item

Updates an existing sales-tax item.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the sales-tax item to update.
 @return ApiQuickbooksDesktopSalesTaxItemsIdPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopSalesTaxItemsIdPost(ctx context.Context, id string) ApiQuickbooksDesktopSalesTaxItemsIdPostRequest {
	return ApiQuickbooksDesktopSalesTaxItemsIdPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdSalesTaxItem
func (a *DefaultAPIService) QuickbooksDesktopSalesTaxItemsIdPostExecute(r ApiQuickbooksDesktopSalesTaxItemsIdPostRequest) (*QbdSalesTaxItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdSalesTaxItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopSalesTaxItemsIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/sales-tax-items/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopSalesTaxItemsIdPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopSalesTaxItemsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	quickbooksDesktopSalesTaxItemsPostRequest *QuickbooksDesktopSalesTaxItemsPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopSalesTaxItemsPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopSalesTaxItemsPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopSalesTaxItemsPostRequest) QuickbooksDesktopSalesTaxItemsPostRequest(quickbooksDesktopSalesTaxItemsPostRequest QuickbooksDesktopSalesTaxItemsPostRequest) ApiQuickbooksDesktopSalesTaxItemsPostRequest {
	r.quickbooksDesktopSalesTaxItemsPostRequest = &quickbooksDesktopSalesTaxItemsPostRequest
	return r
}

func (r ApiQuickbooksDesktopSalesTaxItemsPostRequest) Execute() (*QbdSalesTaxItem, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopSalesTaxItemsPostExecute(r)
}

/*
QuickbooksDesktopSalesTaxItemsPost Create a sales-tax item

Creates a new sales-tax item.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopSalesTaxItemsPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopSalesTaxItemsPost(ctx context.Context) ApiQuickbooksDesktopSalesTaxItemsPostRequest {
	return ApiQuickbooksDesktopSalesTaxItemsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QbdSalesTaxItem
func (a *DefaultAPIService) QuickbooksDesktopSalesTaxItemsPostExecute(r ApiQuickbooksDesktopSalesTaxItemsPostRequest) (*QbdSalesTaxItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdSalesTaxItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopSalesTaxItemsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/sales-tax-items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopSalesTaxItemsPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopServiceItemsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	ids *[]string
	fullNames *[]string
	limit *int32
	cursor *string
	status *string
	updatedAfter *string
	updatedBefore *string
	nameContains *string
	nameStartsWith *string
	nameEndsWith *string
	nameFrom *string
	nameTo *string
	classIds *[]string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopServiceItemsGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopServiceItemsGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

// Filter for specific service items by their QuickBooks-assigned unique identifier(s).  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopServiceItemsGetRequest) Ids(ids []string) ApiQuickbooksDesktopServiceItemsGetRequest {
	r.ids = &ids
	return r
}

// Filter for specific service items by their full-name(s), case-insensitive. Like &#x60;id&#x60;, &#x60;fullName&#x60; is a unique identifier for a service item, formed by by combining the names of its parent objects with its own &#x60;name&#x60;, separated by colons. For example, if a service item is under \&quot;Consulting\&quot; and has the &#x60;name&#x60; \&quot;Web-Design\&quot;, its &#x60;fullName&#x60; would be \&quot;Consulting:Web-Design\&quot;.  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopServiceItemsGetRequest) FullNames(fullNames []string) ApiQuickbooksDesktopServiceItemsGetRequest {
	r.fullNames = &fullNames
	return r
}

// The maximum number of objects to return. Accepts values ranging from 1 to 150, defaults to 150. When used with cursor-based pagination, this parameter controls how many results are returned per page. To paginate through results, combine this with the &#x60;cursor&#x60; parameter. Each response will include a &#x60;nextCursor&#x60; value that can be passed to subsequent requests to retrieve the next page of results.
func (r ApiQuickbooksDesktopServiceItemsGetRequest) Limit(limit int32) ApiQuickbooksDesktopServiceItemsGetRequest {
	r.limit = &limit
	return r
}

// The pagination token to fetch the next set of results when paginating with the &#x60;limit&#x60; parameter. Do not include this parameter on the first call. Use the &#x60;nextCursor&#x60; value returned in the previous response to request subsequent results.
func (r ApiQuickbooksDesktopServiceItemsGetRequest) Cursor(cursor string) ApiQuickbooksDesktopServiceItemsGetRequest {
	r.cursor = &cursor
	return r
}

// Filter for service items that are active, inactive, or both.
func (r ApiQuickbooksDesktopServiceItemsGetRequest) Status(status string) ApiQuickbooksDesktopServiceItemsGetRequest {
	r.status = &status
	return r
}

// Filter for service items updated on or after this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 00:00:00 of that day.
func (r ApiQuickbooksDesktopServiceItemsGetRequest) UpdatedAfter(updatedAfter string) ApiQuickbooksDesktopServiceItemsGetRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Filter for service items updated on or before this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 23:59:59 of that day.
func (r ApiQuickbooksDesktopServiceItemsGetRequest) UpdatedBefore(updatedBefore string) ApiQuickbooksDesktopServiceItemsGetRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Filter for service items whose &#x60;name&#x60; contains this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameStartsWith&#x60; or &#x60;nameEndsWith&#x60;.
func (r ApiQuickbooksDesktopServiceItemsGetRequest) NameContains(nameContains string) ApiQuickbooksDesktopServiceItemsGetRequest {
	r.nameContains = &nameContains
	return r
}

// Filter for service items whose &#x60;name&#x60; starts with this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameContains&#x60; or &#x60;nameEndsWith&#x60;.
func (r ApiQuickbooksDesktopServiceItemsGetRequest) NameStartsWith(nameStartsWith string) ApiQuickbooksDesktopServiceItemsGetRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Filter for service items whose &#x60;name&#x60; ends with this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameContains&#x60; or &#x60;nameStartsWith&#x60;.
func (r ApiQuickbooksDesktopServiceItemsGetRequest) NameEndsWith(nameEndsWith string) ApiQuickbooksDesktopServiceItemsGetRequest {
	r.nameEndsWith = &nameEndsWith
	return r
}

// Filter for service items whose &#x60;name&#x60; is alphabetically greater than or equal to this value.
func (r ApiQuickbooksDesktopServiceItemsGetRequest) NameFrom(nameFrom string) ApiQuickbooksDesktopServiceItemsGetRequest {
	r.nameFrom = &nameFrom
	return r
}

// Filter for service items whose &#x60;name&#x60; is alphabetically less than or equal to this value.
func (r ApiQuickbooksDesktopServiceItemsGetRequest) NameTo(nameTo string) ApiQuickbooksDesktopServiceItemsGetRequest {
	r.nameTo = &nameTo
	return r
}

// Filter for service items of these classes. A class is a way end-users can categorize service items in QuickBooks.
func (r ApiQuickbooksDesktopServiceItemsGetRequest) ClassIds(classIds []string) ApiQuickbooksDesktopServiceItemsGetRequest {
	r.classIds = &classIds
	return r
}

func (r ApiQuickbooksDesktopServiceItemsGetRequest) Execute() (*QuickbooksDesktopServiceItemsGet200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopServiceItemsGetExecute(r)
}

/*
QuickbooksDesktopServiceItemsGet List all service items

Returns a list of service items. Use the `cursor` parameter to paginate through the results.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopServiceItemsGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopServiceItemsGet(ctx context.Context) ApiQuickbooksDesktopServiceItemsGetRequest {
	return ApiQuickbooksDesktopServiceItemsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopServiceItemsGet200Response
func (a *DefaultAPIService) QuickbooksDesktopServiceItemsGetExecute(r ApiQuickbooksDesktopServiceItemsGetRequest) (*QuickbooksDesktopServiceItemsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopServiceItemsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopServiceItemsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/service-items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.fullNames != nil {
		t := *r.fullNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fullNames", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fullNames", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 150
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	} else {
		var defaultValue string = "active"
		r.status = &defaultValue
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.nameContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameContains", r.nameContains, "form", "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameStartsWith", r.nameStartsWith, "form", "")
	}
	if r.nameEndsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameEndsWith", r.nameEndsWith, "form", "")
	}
	if r.nameFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameFrom", r.nameFrom, "form", "")
	}
	if r.nameTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameTo", r.nameTo, "form", "")
	}
	if r.classIds != nil {
		t := *r.classIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "classIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "classIds", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopServiceItemsIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopServiceItemsIdGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopServiceItemsIdGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopServiceItemsIdGetRequest) Execute() (*QbdServiceItem, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopServiceItemsIdGetExecute(r)
}

/*
QuickbooksDesktopServiceItemsIdGet Retrieve a service item

Retrieves a service item by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the service item to retrieve.
 @return ApiQuickbooksDesktopServiceItemsIdGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopServiceItemsIdGet(ctx context.Context, id string) ApiQuickbooksDesktopServiceItemsIdGetRequest {
	return ApiQuickbooksDesktopServiceItemsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdServiceItem
func (a *DefaultAPIService) QuickbooksDesktopServiceItemsIdGetExecute(r ApiQuickbooksDesktopServiceItemsIdGetRequest) (*QbdServiceItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdServiceItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopServiceItemsIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/service-items/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopServiceItemsIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
	quickbooksDesktopServiceItemsIdPostRequest *QuickbooksDesktopServiceItemsIdPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopServiceItemsIdPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopServiceItemsIdPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopServiceItemsIdPostRequest) QuickbooksDesktopServiceItemsIdPostRequest(quickbooksDesktopServiceItemsIdPostRequest QuickbooksDesktopServiceItemsIdPostRequest) ApiQuickbooksDesktopServiceItemsIdPostRequest {
	r.quickbooksDesktopServiceItemsIdPostRequest = &quickbooksDesktopServiceItemsIdPostRequest
	return r
}

func (r ApiQuickbooksDesktopServiceItemsIdPostRequest) Execute() (*QbdServiceItem, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopServiceItemsIdPostExecute(r)
}

/*
QuickbooksDesktopServiceItemsIdPost Update a service item

Updates an existing service item.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the service item to update.
 @return ApiQuickbooksDesktopServiceItemsIdPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopServiceItemsIdPost(ctx context.Context, id string) ApiQuickbooksDesktopServiceItemsIdPostRequest {
	return ApiQuickbooksDesktopServiceItemsIdPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdServiceItem
func (a *DefaultAPIService) QuickbooksDesktopServiceItemsIdPostExecute(r ApiQuickbooksDesktopServiceItemsIdPostRequest) (*QbdServiceItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdServiceItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopServiceItemsIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/service-items/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopServiceItemsIdPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopServiceItemsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	quickbooksDesktopServiceItemsPostRequest *QuickbooksDesktopServiceItemsPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopServiceItemsPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopServiceItemsPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopServiceItemsPostRequest) QuickbooksDesktopServiceItemsPostRequest(quickbooksDesktopServiceItemsPostRequest QuickbooksDesktopServiceItemsPostRequest) ApiQuickbooksDesktopServiceItemsPostRequest {
	r.quickbooksDesktopServiceItemsPostRequest = &quickbooksDesktopServiceItemsPostRequest
	return r
}

func (r ApiQuickbooksDesktopServiceItemsPostRequest) Execute() (*QbdServiceItem, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopServiceItemsPostExecute(r)
}

/*
QuickbooksDesktopServiceItemsPost Create a service item

Creates a new service item.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopServiceItemsPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopServiceItemsPost(ctx context.Context) ApiQuickbooksDesktopServiceItemsPostRequest {
	return ApiQuickbooksDesktopServiceItemsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QbdServiceItem
func (a *DefaultAPIService) QuickbooksDesktopServiceItemsPostExecute(r ApiQuickbooksDesktopServiceItemsPostRequest) (*QbdServiceItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdServiceItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopServiceItemsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/service-items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopServiceItemsPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopStandardTermsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	ids *[]string
	names *[]string
	limit *int32
	status *string
	updatedAfter *string
	updatedBefore *string
	nameContains *string
	nameStartsWith *string
	nameEndsWith *string
	nameFrom *string
	nameTo *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopStandardTermsGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopStandardTermsGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

// Filter for specific standard terms by their QuickBooks-assigned unique identifier(s).  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopStandardTermsGetRequest) Ids(ids []string) ApiQuickbooksDesktopStandardTermsGetRequest {
	r.ids = &ids
	return r
}

// Filter for specific standard terms by their name(s), case-insensitive. Like &#x60;id&#x60;, &#x60;name&#x60; is a unique identifier for a standard term.  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopStandardTermsGetRequest) Names(names []string) ApiQuickbooksDesktopStandardTermsGetRequest {
	r.names = &names
	return r
}

// The maximum number of objects to return.  **IMPORTANT**: QuickBooks Desktop does not support cursor-based pagination for standard terms. This parameter will limit the response size, but you cannot fetch subsequent results using a cursor. For pagination, use the name-range parameters instead (e.g., &#x60;nameFrom&#x3D;A&amp;nameTo&#x3D;B&#x60;).  When this parameter is omitted, the endpoint returns all standard terms without limit, unlike paginated endpoints which default to 150 records. This is acceptable because standard terms typically have low record counts.
func (r ApiQuickbooksDesktopStandardTermsGetRequest) Limit(limit int32) ApiQuickbooksDesktopStandardTermsGetRequest {
	r.limit = &limit
	return r
}

// Filter for standard terms that are active, inactive, or both.
func (r ApiQuickbooksDesktopStandardTermsGetRequest) Status(status string) ApiQuickbooksDesktopStandardTermsGetRequest {
	r.status = &status
	return r
}

// Filter for standard terms updated on or after this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 00:00:00 of that day.
func (r ApiQuickbooksDesktopStandardTermsGetRequest) UpdatedAfter(updatedAfter string) ApiQuickbooksDesktopStandardTermsGetRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Filter for standard terms updated on or before this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 23:59:59 of that day.
func (r ApiQuickbooksDesktopStandardTermsGetRequest) UpdatedBefore(updatedBefore string) ApiQuickbooksDesktopStandardTermsGetRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Filter for standard terms whose &#x60;name&#x60; contains this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameStartsWith&#x60; or &#x60;nameEndsWith&#x60;.
func (r ApiQuickbooksDesktopStandardTermsGetRequest) NameContains(nameContains string) ApiQuickbooksDesktopStandardTermsGetRequest {
	r.nameContains = &nameContains
	return r
}

// Filter for standard terms whose &#x60;name&#x60; starts with this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameContains&#x60; or &#x60;nameEndsWith&#x60;.
func (r ApiQuickbooksDesktopStandardTermsGetRequest) NameStartsWith(nameStartsWith string) ApiQuickbooksDesktopStandardTermsGetRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Filter for standard terms whose &#x60;name&#x60; ends with this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameContains&#x60; or &#x60;nameStartsWith&#x60;.
func (r ApiQuickbooksDesktopStandardTermsGetRequest) NameEndsWith(nameEndsWith string) ApiQuickbooksDesktopStandardTermsGetRequest {
	r.nameEndsWith = &nameEndsWith
	return r
}

// Filter for standard terms whose &#x60;name&#x60; is alphabetically greater than or equal to this value.
func (r ApiQuickbooksDesktopStandardTermsGetRequest) NameFrom(nameFrom string) ApiQuickbooksDesktopStandardTermsGetRequest {
	r.nameFrom = &nameFrom
	return r
}

// Filter for standard terms whose &#x60;name&#x60; is alphabetically less than or equal to this value.
func (r ApiQuickbooksDesktopStandardTermsGetRequest) NameTo(nameTo string) ApiQuickbooksDesktopStandardTermsGetRequest {
	r.nameTo = &nameTo
	return r
}

func (r ApiQuickbooksDesktopStandardTermsGetRequest) Execute() (*QuickbooksDesktopStandardTermsGet200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopStandardTermsGetExecute(r)
}

/*
QuickbooksDesktopStandardTermsGet List all standard terms

Returns a list of standard terms. NOTE: QuickBooks Desktop does not support pagination for standard terms; hence, there is no `cursor` parameter. Users typically have few standard terms.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopStandardTermsGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopStandardTermsGet(ctx context.Context) ApiQuickbooksDesktopStandardTermsGetRequest {
	return ApiQuickbooksDesktopStandardTermsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopStandardTermsGet200Response
func (a *DefaultAPIService) QuickbooksDesktopStandardTermsGetExecute(r ApiQuickbooksDesktopStandardTermsGetRequest) (*QuickbooksDesktopStandardTermsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopStandardTermsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopStandardTermsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/standard-terms"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.names != nil {
		t := *r.names
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "names", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "names", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	} else {
		var defaultValue string = "active"
		r.status = &defaultValue
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.nameContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameContains", r.nameContains, "form", "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameStartsWith", r.nameStartsWith, "form", "")
	}
	if r.nameEndsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameEndsWith", r.nameEndsWith, "form", "")
	}
	if r.nameFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameFrom", r.nameFrom, "form", "")
	}
	if r.nameTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameTo", r.nameTo, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopStandardTermsIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopStandardTermsIdGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopStandardTermsIdGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopStandardTermsIdGetRequest) Execute() (*QbdStandardTerm, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopStandardTermsIdGetExecute(r)
}

/*
QuickbooksDesktopStandardTermsIdGet Retrieve a standard term

Retrieves a standard term by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the standard term to retrieve.
 @return ApiQuickbooksDesktopStandardTermsIdGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopStandardTermsIdGet(ctx context.Context, id string) ApiQuickbooksDesktopStandardTermsIdGetRequest {
	return ApiQuickbooksDesktopStandardTermsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdStandardTerm
func (a *DefaultAPIService) QuickbooksDesktopStandardTermsIdGetExecute(r ApiQuickbooksDesktopStandardTermsIdGetRequest) (*QbdStandardTerm, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdStandardTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopStandardTermsIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/standard-terms/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopStandardTermsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	quickbooksDesktopStandardTermsPostRequest *QuickbooksDesktopStandardTermsPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopStandardTermsPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopStandardTermsPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopStandardTermsPostRequest) QuickbooksDesktopStandardTermsPostRequest(quickbooksDesktopStandardTermsPostRequest QuickbooksDesktopStandardTermsPostRequest) ApiQuickbooksDesktopStandardTermsPostRequest {
	r.quickbooksDesktopStandardTermsPostRequest = &quickbooksDesktopStandardTermsPostRequest
	return r
}

func (r ApiQuickbooksDesktopStandardTermsPostRequest) Execute() (*QbdStandardTerm, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopStandardTermsPostExecute(r)
}

/*
QuickbooksDesktopStandardTermsPost Create a standard term

Creates a new standard term.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopStandardTermsPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopStandardTermsPost(ctx context.Context) ApiQuickbooksDesktopStandardTermsPostRequest {
	return ApiQuickbooksDesktopStandardTermsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QbdStandardTerm
func (a *DefaultAPIService) QuickbooksDesktopStandardTermsPostExecute(r ApiQuickbooksDesktopStandardTermsPostRequest) (*QbdStandardTerm, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdStandardTerm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopStandardTermsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/standard-terms"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopStandardTermsPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopSubtotalItemsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	ids *[]string
	names *[]string
	limit *int32
	cursor *string
	status *string
	updatedAfter *string
	updatedBefore *string
	nameContains *string
	nameStartsWith *string
	nameEndsWith *string
	nameFrom *string
	nameTo *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopSubtotalItemsGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopSubtotalItemsGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

// Filter for specific subtotal items by their QuickBooks-assigned unique identifier(s).  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopSubtotalItemsGetRequest) Ids(ids []string) ApiQuickbooksDesktopSubtotalItemsGetRequest {
	r.ids = &ids
	return r
}

// Filter for specific subtotal items by their name(s), case-insensitive. Like &#x60;id&#x60;, &#x60;name&#x60; is a unique identifier for a subtotal item.  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopSubtotalItemsGetRequest) Names(names []string) ApiQuickbooksDesktopSubtotalItemsGetRequest {
	r.names = &names
	return r
}

// The maximum number of objects to return. Accepts values ranging from 1 to 150, defaults to 150. When used with cursor-based pagination, this parameter controls how many results are returned per page. To paginate through results, combine this with the &#x60;cursor&#x60; parameter. Each response will include a &#x60;nextCursor&#x60; value that can be passed to subsequent requests to retrieve the next page of results.
func (r ApiQuickbooksDesktopSubtotalItemsGetRequest) Limit(limit int32) ApiQuickbooksDesktopSubtotalItemsGetRequest {
	r.limit = &limit
	return r
}

// The pagination token to fetch the next set of results when paginating with the &#x60;limit&#x60; parameter. Do not include this parameter on the first call. Use the &#x60;nextCursor&#x60; value returned in the previous response to request subsequent results.
func (r ApiQuickbooksDesktopSubtotalItemsGetRequest) Cursor(cursor string) ApiQuickbooksDesktopSubtotalItemsGetRequest {
	r.cursor = &cursor
	return r
}

// Filter for subtotal items that are active, inactive, or both.
func (r ApiQuickbooksDesktopSubtotalItemsGetRequest) Status(status string) ApiQuickbooksDesktopSubtotalItemsGetRequest {
	r.status = &status
	return r
}

// Filter for subtotal items updated on or after this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 00:00:00 of that day.
func (r ApiQuickbooksDesktopSubtotalItemsGetRequest) UpdatedAfter(updatedAfter string) ApiQuickbooksDesktopSubtotalItemsGetRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Filter for subtotal items updated on or before this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 23:59:59 of that day.
func (r ApiQuickbooksDesktopSubtotalItemsGetRequest) UpdatedBefore(updatedBefore string) ApiQuickbooksDesktopSubtotalItemsGetRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Filter for subtotal items whose &#x60;name&#x60; contains this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameStartsWith&#x60; or &#x60;nameEndsWith&#x60;.
func (r ApiQuickbooksDesktopSubtotalItemsGetRequest) NameContains(nameContains string) ApiQuickbooksDesktopSubtotalItemsGetRequest {
	r.nameContains = &nameContains
	return r
}

// Filter for subtotal items whose &#x60;name&#x60; starts with this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameContains&#x60; or &#x60;nameEndsWith&#x60;.
func (r ApiQuickbooksDesktopSubtotalItemsGetRequest) NameStartsWith(nameStartsWith string) ApiQuickbooksDesktopSubtotalItemsGetRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Filter for subtotal items whose &#x60;name&#x60; ends with this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameContains&#x60; or &#x60;nameStartsWith&#x60;.
func (r ApiQuickbooksDesktopSubtotalItemsGetRequest) NameEndsWith(nameEndsWith string) ApiQuickbooksDesktopSubtotalItemsGetRequest {
	r.nameEndsWith = &nameEndsWith
	return r
}

// Filter for subtotal items whose &#x60;name&#x60; is alphabetically greater than or equal to this value.
func (r ApiQuickbooksDesktopSubtotalItemsGetRequest) NameFrom(nameFrom string) ApiQuickbooksDesktopSubtotalItemsGetRequest {
	r.nameFrom = &nameFrom
	return r
}

// Filter for subtotal items whose &#x60;name&#x60; is alphabetically less than or equal to this value.
func (r ApiQuickbooksDesktopSubtotalItemsGetRequest) NameTo(nameTo string) ApiQuickbooksDesktopSubtotalItemsGetRequest {
	r.nameTo = &nameTo
	return r
}

func (r ApiQuickbooksDesktopSubtotalItemsGetRequest) Execute() (*QuickbooksDesktopSubtotalItemsGet200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopSubtotalItemsGetExecute(r)
}

/*
QuickbooksDesktopSubtotalItemsGet List all subtotal items

Returns a list of subtotal items. Use the `cursor` parameter to paginate through the results.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopSubtotalItemsGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopSubtotalItemsGet(ctx context.Context) ApiQuickbooksDesktopSubtotalItemsGetRequest {
	return ApiQuickbooksDesktopSubtotalItemsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopSubtotalItemsGet200Response
func (a *DefaultAPIService) QuickbooksDesktopSubtotalItemsGetExecute(r ApiQuickbooksDesktopSubtotalItemsGetRequest) (*QuickbooksDesktopSubtotalItemsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopSubtotalItemsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopSubtotalItemsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/subtotal-items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.names != nil {
		t := *r.names
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "names", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "names", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 150
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	} else {
		var defaultValue string = "active"
		r.status = &defaultValue
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.nameContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameContains", r.nameContains, "form", "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameStartsWith", r.nameStartsWith, "form", "")
	}
	if r.nameEndsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameEndsWith", r.nameEndsWith, "form", "")
	}
	if r.nameFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameFrom", r.nameFrom, "form", "")
	}
	if r.nameTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameTo", r.nameTo, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopSubtotalItemsIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopSubtotalItemsIdGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopSubtotalItemsIdGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopSubtotalItemsIdGetRequest) Execute() (*QbdSubtotalItem, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopSubtotalItemsIdGetExecute(r)
}

/*
QuickbooksDesktopSubtotalItemsIdGet Retrieve a subtotal item

Retrieves a subtotal item by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the subtotal item to retrieve.
 @return ApiQuickbooksDesktopSubtotalItemsIdGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopSubtotalItemsIdGet(ctx context.Context, id string) ApiQuickbooksDesktopSubtotalItemsIdGetRequest {
	return ApiQuickbooksDesktopSubtotalItemsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdSubtotalItem
func (a *DefaultAPIService) QuickbooksDesktopSubtotalItemsIdGetExecute(r ApiQuickbooksDesktopSubtotalItemsIdGetRequest) (*QbdSubtotalItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdSubtotalItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopSubtotalItemsIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/subtotal-items/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopSubtotalItemsIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
	quickbooksDesktopSubtotalItemsIdPostRequest *QuickbooksDesktopSubtotalItemsIdPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopSubtotalItemsIdPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopSubtotalItemsIdPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopSubtotalItemsIdPostRequest) QuickbooksDesktopSubtotalItemsIdPostRequest(quickbooksDesktopSubtotalItemsIdPostRequest QuickbooksDesktopSubtotalItemsIdPostRequest) ApiQuickbooksDesktopSubtotalItemsIdPostRequest {
	r.quickbooksDesktopSubtotalItemsIdPostRequest = &quickbooksDesktopSubtotalItemsIdPostRequest
	return r
}

func (r ApiQuickbooksDesktopSubtotalItemsIdPostRequest) Execute() (*QbdSubtotalItem, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopSubtotalItemsIdPostExecute(r)
}

/*
QuickbooksDesktopSubtotalItemsIdPost Update a subtotal item

Updates an existing subtotal item.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the subtotal item to update.
 @return ApiQuickbooksDesktopSubtotalItemsIdPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopSubtotalItemsIdPost(ctx context.Context, id string) ApiQuickbooksDesktopSubtotalItemsIdPostRequest {
	return ApiQuickbooksDesktopSubtotalItemsIdPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdSubtotalItem
func (a *DefaultAPIService) QuickbooksDesktopSubtotalItemsIdPostExecute(r ApiQuickbooksDesktopSubtotalItemsIdPostRequest) (*QbdSubtotalItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdSubtotalItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopSubtotalItemsIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/subtotal-items/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopSubtotalItemsIdPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopSubtotalItemsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	quickbooksDesktopSubtotalItemsPostRequest *QuickbooksDesktopSubtotalItemsPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopSubtotalItemsPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopSubtotalItemsPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopSubtotalItemsPostRequest) QuickbooksDesktopSubtotalItemsPostRequest(quickbooksDesktopSubtotalItemsPostRequest QuickbooksDesktopSubtotalItemsPostRequest) ApiQuickbooksDesktopSubtotalItemsPostRequest {
	r.quickbooksDesktopSubtotalItemsPostRequest = &quickbooksDesktopSubtotalItemsPostRequest
	return r
}

func (r ApiQuickbooksDesktopSubtotalItemsPostRequest) Execute() (*QbdSubtotalItem, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopSubtotalItemsPostExecute(r)
}

/*
QuickbooksDesktopSubtotalItemsPost Create a subtotal item

Creates a new subtotal item.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopSubtotalItemsPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopSubtotalItemsPost(ctx context.Context) ApiQuickbooksDesktopSubtotalItemsPostRequest {
	return ApiQuickbooksDesktopSubtotalItemsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QbdSubtotalItem
func (a *DefaultAPIService) QuickbooksDesktopSubtotalItemsPostExecute(r ApiQuickbooksDesktopSubtotalItemsPostRequest) (*QbdSubtotalItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdSubtotalItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopSubtotalItemsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/subtotal-items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopSubtotalItemsPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopTimeTrackingActivitiesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	ids *[]string
	limit *int32
	cursor *string
	updatedAfter *string
	updatedBefore *string
	transactionDateFrom *string
	transactionDateTo *string
	entityIds *[]string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopTimeTrackingActivitiesGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopTimeTrackingActivitiesGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

// Filter for specific time tracking activities by their QuickBooks-assigned unique identifier(s).  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopTimeTrackingActivitiesGetRequest) Ids(ids []string) ApiQuickbooksDesktopTimeTrackingActivitiesGetRequest {
	r.ids = &ids
	return r
}

// The maximum number of objects to return. Accepts values ranging from 1 to 150, defaults to 150. When used with cursor-based pagination, this parameter controls how many results are returned per page. To paginate through results, combine this with the &#x60;cursor&#x60; parameter. Each response will include a &#x60;nextCursor&#x60; value that can be passed to subsequent requests to retrieve the next page of results.
func (r ApiQuickbooksDesktopTimeTrackingActivitiesGetRequest) Limit(limit int32) ApiQuickbooksDesktopTimeTrackingActivitiesGetRequest {
	r.limit = &limit
	return r
}

// The pagination token to fetch the next set of results when paginating with the &#x60;limit&#x60; parameter. Do not include this parameter on the first call. Use the &#x60;nextCursor&#x60; value returned in the previous response to request subsequent results.
func (r ApiQuickbooksDesktopTimeTrackingActivitiesGetRequest) Cursor(cursor string) ApiQuickbooksDesktopTimeTrackingActivitiesGetRequest {
	r.cursor = &cursor
	return r
}

// Filter for time tracking activities updated on or after this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 00:00:00 of that day.
func (r ApiQuickbooksDesktopTimeTrackingActivitiesGetRequest) UpdatedAfter(updatedAfter string) ApiQuickbooksDesktopTimeTrackingActivitiesGetRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Filter for time tracking activities updated on or before this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 23:59:59 of that day.
func (r ApiQuickbooksDesktopTimeTrackingActivitiesGetRequest) UpdatedBefore(updatedBefore string) ApiQuickbooksDesktopTimeTrackingActivitiesGetRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Filter for time tracking activities whose &#x60;date&#x60; field is on or after this date, in ISO 8601 format (YYYY-MM-DD).
func (r ApiQuickbooksDesktopTimeTrackingActivitiesGetRequest) TransactionDateFrom(transactionDateFrom string) ApiQuickbooksDesktopTimeTrackingActivitiesGetRequest {
	r.transactionDateFrom = &transactionDateFrom
	return r
}

// Filter for time tracking activities whose &#x60;date&#x60; field is on or before this date, in ISO 8601 format (YYYY-MM-DD).
func (r ApiQuickbooksDesktopTimeTrackingActivitiesGetRequest) TransactionDateTo(transactionDateTo string) ApiQuickbooksDesktopTimeTrackingActivitiesGetRequest {
	r.transactionDateTo = &transactionDateTo
	return r
}

// Filter for time tracking activities tracking the time of these employees, vendors, or persons on QuickBooks&#39;s \&quot;Other Names\&quot; list.
func (r ApiQuickbooksDesktopTimeTrackingActivitiesGetRequest) EntityIds(entityIds []string) ApiQuickbooksDesktopTimeTrackingActivitiesGetRequest {
	r.entityIds = &entityIds
	return r
}

func (r ApiQuickbooksDesktopTimeTrackingActivitiesGetRequest) Execute() (*QuickbooksDesktopTimeTrackingActivitiesGet200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopTimeTrackingActivitiesGetExecute(r)
}

/*
QuickbooksDesktopTimeTrackingActivitiesGet List all time tracking activities

Returns a list of time tracking activities. Use the `cursor` parameter to paginate through the results.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopTimeTrackingActivitiesGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopTimeTrackingActivitiesGet(ctx context.Context) ApiQuickbooksDesktopTimeTrackingActivitiesGetRequest {
	return ApiQuickbooksDesktopTimeTrackingActivitiesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopTimeTrackingActivitiesGet200Response
func (a *DefaultAPIService) QuickbooksDesktopTimeTrackingActivitiesGetExecute(r ApiQuickbooksDesktopTimeTrackingActivitiesGetRequest) (*QuickbooksDesktopTimeTrackingActivitiesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopTimeTrackingActivitiesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopTimeTrackingActivitiesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/time-tracking-activities"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 150
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.transactionDateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDateFrom", r.transactionDateFrom, "form", "")
	}
	if r.transactionDateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDateTo", r.transactionDateTo, "form", "")
	}
	if r.entityIds != nil {
		t := *r.entityIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "entityIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "entityIds", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopTimeTrackingActivitiesIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopTimeTrackingActivitiesIdDeleteRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopTimeTrackingActivitiesIdDeleteRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopTimeTrackingActivitiesIdDeleteRequest) Execute() (*QuickbooksDesktopTimeTrackingActivitiesIdDelete200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopTimeTrackingActivitiesIdDeleteExecute(r)
}

/*
QuickbooksDesktopTimeTrackingActivitiesIdDelete Delete a time tracking activity

Permanently deletes a a time tracking activity. The deletion will fail if the time tracking activity is currently in use or has any linked transactions that are in use.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the time tracking activity to delete.
 @return ApiQuickbooksDesktopTimeTrackingActivitiesIdDeleteRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopTimeTrackingActivitiesIdDelete(ctx context.Context, id string) ApiQuickbooksDesktopTimeTrackingActivitiesIdDeleteRequest {
	return ApiQuickbooksDesktopTimeTrackingActivitiesIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopTimeTrackingActivitiesIdDelete200Response
func (a *DefaultAPIService) QuickbooksDesktopTimeTrackingActivitiesIdDeleteExecute(r ApiQuickbooksDesktopTimeTrackingActivitiesIdDeleteRequest) (*QuickbooksDesktopTimeTrackingActivitiesIdDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopTimeTrackingActivitiesIdDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopTimeTrackingActivitiesIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/time-tracking-activities/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopTimeTrackingActivitiesIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopTimeTrackingActivitiesIdGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopTimeTrackingActivitiesIdGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopTimeTrackingActivitiesIdGetRequest) Execute() (*QbdTimeTrackingActivity, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopTimeTrackingActivitiesIdGetExecute(r)
}

/*
QuickbooksDesktopTimeTrackingActivitiesIdGet Retrieve a time tracking activity

Retrieves a time tracking activity by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the time tracking activity to retrieve.
 @return ApiQuickbooksDesktopTimeTrackingActivitiesIdGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopTimeTrackingActivitiesIdGet(ctx context.Context, id string) ApiQuickbooksDesktopTimeTrackingActivitiesIdGetRequest {
	return ApiQuickbooksDesktopTimeTrackingActivitiesIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdTimeTrackingActivity
func (a *DefaultAPIService) QuickbooksDesktopTimeTrackingActivitiesIdGetExecute(r ApiQuickbooksDesktopTimeTrackingActivitiesIdGetRequest) (*QbdTimeTrackingActivity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdTimeTrackingActivity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopTimeTrackingActivitiesIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/time-tracking-activities/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopTimeTrackingActivitiesIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
	quickbooksDesktopTimeTrackingActivitiesIdPostRequest *QuickbooksDesktopTimeTrackingActivitiesIdPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopTimeTrackingActivitiesIdPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopTimeTrackingActivitiesIdPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopTimeTrackingActivitiesIdPostRequest) QuickbooksDesktopTimeTrackingActivitiesIdPostRequest(quickbooksDesktopTimeTrackingActivitiesIdPostRequest QuickbooksDesktopTimeTrackingActivitiesIdPostRequest) ApiQuickbooksDesktopTimeTrackingActivitiesIdPostRequest {
	r.quickbooksDesktopTimeTrackingActivitiesIdPostRequest = &quickbooksDesktopTimeTrackingActivitiesIdPostRequest
	return r
}

func (r ApiQuickbooksDesktopTimeTrackingActivitiesIdPostRequest) Execute() (*QbdTimeTrackingActivity, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopTimeTrackingActivitiesIdPostExecute(r)
}

/*
QuickbooksDesktopTimeTrackingActivitiesIdPost Update a time tracking activity

Updates an existing time tracking activity.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the time tracking activity to update.
 @return ApiQuickbooksDesktopTimeTrackingActivitiesIdPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopTimeTrackingActivitiesIdPost(ctx context.Context, id string) ApiQuickbooksDesktopTimeTrackingActivitiesIdPostRequest {
	return ApiQuickbooksDesktopTimeTrackingActivitiesIdPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdTimeTrackingActivity
func (a *DefaultAPIService) QuickbooksDesktopTimeTrackingActivitiesIdPostExecute(r ApiQuickbooksDesktopTimeTrackingActivitiesIdPostRequest) (*QbdTimeTrackingActivity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdTimeTrackingActivity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopTimeTrackingActivitiesIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/time-tracking-activities/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopTimeTrackingActivitiesIdPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopTimeTrackingActivitiesPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	quickbooksDesktopTimeTrackingActivitiesPostRequest *QuickbooksDesktopTimeTrackingActivitiesPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopTimeTrackingActivitiesPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopTimeTrackingActivitiesPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopTimeTrackingActivitiesPostRequest) QuickbooksDesktopTimeTrackingActivitiesPostRequest(quickbooksDesktopTimeTrackingActivitiesPostRequest QuickbooksDesktopTimeTrackingActivitiesPostRequest) ApiQuickbooksDesktopTimeTrackingActivitiesPostRequest {
	r.quickbooksDesktopTimeTrackingActivitiesPostRequest = &quickbooksDesktopTimeTrackingActivitiesPostRequest
	return r
}

func (r ApiQuickbooksDesktopTimeTrackingActivitiesPostRequest) Execute() (*QbdTimeTrackingActivity, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopTimeTrackingActivitiesPostExecute(r)
}

/*
QuickbooksDesktopTimeTrackingActivitiesPost Create a time tracking activity

Creates a new time tracking activity.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopTimeTrackingActivitiesPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopTimeTrackingActivitiesPost(ctx context.Context) ApiQuickbooksDesktopTimeTrackingActivitiesPostRequest {
	return ApiQuickbooksDesktopTimeTrackingActivitiesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QbdTimeTrackingActivity
func (a *DefaultAPIService) QuickbooksDesktopTimeTrackingActivitiesPostExecute(r ApiQuickbooksDesktopTimeTrackingActivitiesPostRequest) (*QbdTimeTrackingActivity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdTimeTrackingActivity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopTimeTrackingActivitiesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/time-tracking-activities"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopTimeTrackingActivitiesPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopTransactionsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	ids *[]string
	limit *int32
	cursor *string
	refNumbers *[]string
	refNumberContains *string
	refNumberStartsWith *string
	refNumberEndsWith *string
	refNumberFrom *string
	refNumberTo *string
	updatedAfter *string
	updatedBefore *string
	transactionDateFrom *string
	transactionDateTo *string
	entityIds *[]string
	accountIds *[]string
	itemIds *[]string
	classIds *[]string
	transactionType *[]string
	detailLevel *string
	postingStatus *string
	paymentStatus *string
	currencyIds *[]string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopTransactionsGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopTransactionsGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

// Filter for specific transactions by their QuickBooks-assigned unique identifier(s).  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.  **NOTE**: You cannot supply the ID of a time tracking activity to this request. If you do, you get an error stating that no such record could be found, even though the transaction is in QuickBooks. This limitation is enforced by QuickBooks.
func (r ApiQuickbooksDesktopTransactionsGetRequest) Ids(ids []string) ApiQuickbooksDesktopTransactionsGetRequest {
	r.ids = &ids
	return r
}

// The maximum number of objects to return. Accepts values ranging from 1 to 150, defaults to 150. When used with cursor-based pagination, this parameter controls how many results are returned per page. To paginate through results, combine this with the &#x60;cursor&#x60; parameter. Each response will include a &#x60;nextCursor&#x60; value that can be passed to subsequent requests to retrieve the next page of results.
func (r ApiQuickbooksDesktopTransactionsGetRequest) Limit(limit int32) ApiQuickbooksDesktopTransactionsGetRequest {
	r.limit = &limit
	return r
}

// The pagination token to fetch the next set of results when paginating with the &#x60;limit&#x60; parameter. Do not include this parameter on the first call. Use the &#x60;nextCursor&#x60; value returned in the previous response to request subsequent results.
func (r ApiQuickbooksDesktopTransactionsGetRequest) Cursor(cursor string) ApiQuickbooksDesktopTransactionsGetRequest {
	r.cursor = &cursor
	return r
}

// Filter for specific transactions by their ref-number(s), case-sensitive. In QuickBooks, ref-numbers are not required to be unique and can be arbitrarily changed by the QuickBooks user.  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopTransactionsGetRequest) RefNumbers(refNumbers []string) ApiQuickbooksDesktopTransactionsGetRequest {
	r.refNumbers = &refNumbers
	return r
}

// Filter for transactions whose &#x60;refNumber&#x60; contains this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberStartsWith&#x60; or &#x60;refNumberEndsWith&#x60;.
func (r ApiQuickbooksDesktopTransactionsGetRequest) RefNumberContains(refNumberContains string) ApiQuickbooksDesktopTransactionsGetRequest {
	r.refNumberContains = &refNumberContains
	return r
}

// Filter for transactions whose &#x60;refNumber&#x60; starts with this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberContains&#x60; or &#x60;refNumberEndsWith&#x60;.
func (r ApiQuickbooksDesktopTransactionsGetRequest) RefNumberStartsWith(refNumberStartsWith string) ApiQuickbooksDesktopTransactionsGetRequest {
	r.refNumberStartsWith = &refNumberStartsWith
	return r
}

// Filter for transactions whose &#x60;refNumber&#x60; ends with this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberContains&#x60; or &#x60;refNumberStartsWith&#x60;.
func (r ApiQuickbooksDesktopTransactionsGetRequest) RefNumberEndsWith(refNumberEndsWith string) ApiQuickbooksDesktopTransactionsGetRequest {
	r.refNumberEndsWith = &refNumberEndsWith
	return r
}

// Filter for transactions whose &#x60;refNumber&#x60; is greater than or equal to this value. If omitted, the range will begin with the first number of the list. Uses a numerical comparison for values that contain only digits; otherwise, uses a lexicographical comparison.
func (r ApiQuickbooksDesktopTransactionsGetRequest) RefNumberFrom(refNumberFrom string) ApiQuickbooksDesktopTransactionsGetRequest {
	r.refNumberFrom = &refNumberFrom
	return r
}

// Filter for transactions whose &#x60;refNumber&#x60; is less than or equal to this value. If omitted, the range will end with the last number of the list. Uses a numerical comparison for values that contain only digits; otherwise, uses a lexicographical comparison.
func (r ApiQuickbooksDesktopTransactionsGetRequest) RefNumberTo(refNumberTo string) ApiQuickbooksDesktopTransactionsGetRequest {
	r.refNumberTo = &refNumberTo
	return r
}

// Filter for transactions updated on or after this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 00:00:00 of that day.
func (r ApiQuickbooksDesktopTransactionsGetRequest) UpdatedAfter(updatedAfter string) ApiQuickbooksDesktopTransactionsGetRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Filter for transactions updated on or before this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 23:59:59 of that day.
func (r ApiQuickbooksDesktopTransactionsGetRequest) UpdatedBefore(updatedBefore string) ApiQuickbooksDesktopTransactionsGetRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Filter for transactions whose &#x60;date&#x60; field is on or after this date, in ISO 8601 format (YYYY-MM-DD).
func (r ApiQuickbooksDesktopTransactionsGetRequest) TransactionDateFrom(transactionDateFrom string) ApiQuickbooksDesktopTransactionsGetRequest {
	r.transactionDateFrom = &transactionDateFrom
	return r
}

// Filter for transactions whose &#x60;date&#x60; field is on or before this date, in ISO 8601 format (YYYY-MM-DD).
func (r ApiQuickbooksDesktopTransactionsGetRequest) TransactionDateTo(transactionDateTo string) ApiQuickbooksDesktopTransactionsGetRequest {
	r.transactionDateTo = &transactionDateTo
	return r
}

// Filter for transactions associated with these entities (customers, vendors, employees, etc.).  **NOTE**: To filter on transaction lines, you must specify the &#x60;transactionDetailLevel&#x60; parameter as &#x60;all&#x60; or &#x60;transaction_lines_only&#x60;.
func (r ApiQuickbooksDesktopTransactionsGetRequest) EntityIds(entityIds []string) ApiQuickbooksDesktopTransactionsGetRequest {
	r.entityIds = &entityIds
	return r
}

// Filter for transactions associated with these accounts.  **NOTE**: To filter on transaction lines, you must specify the &#x60;transactionDetailLevel&#x60; parameter as &#x60;all&#x60; or &#x60;transaction_lines_only&#x60;.
func (r ApiQuickbooksDesktopTransactionsGetRequest) AccountIds(accountIds []string) ApiQuickbooksDesktopTransactionsGetRequest {
	r.accountIds = &accountIds
	return r
}

// Filter for transactions associated with these items.  **NOTE**: To filter on transaction lines, you must specify the &#x60;transactionDetailLevel&#x60; parameter as &#x60;all&#x60; or &#x60;transaction_lines_only&#x60;.
func (r ApiQuickbooksDesktopTransactionsGetRequest) ItemIds(itemIds []string) ApiQuickbooksDesktopTransactionsGetRequest {
	r.itemIds = &itemIds
	return r
}

// Filter for transactions of these classes. A class is a way end-users can categorize transactions in QuickBooks.  **NOTE**: To filter on transaction lines, you must specify the &#x60;transactionDetailLevel&#x60; parameter as &#x60;all&#x60; or &#x60;transaction_lines_only&#x60;.
func (r ApiQuickbooksDesktopTransactionsGetRequest) ClassIds(classIds []string) ApiQuickbooksDesktopTransactionsGetRequest {
	r.classIds = &classIds
	return r
}

// Filter for transactions by their type. You can specify one or more transaction types.  **NOTE**: Filtering for time tracking activities is not supported by QuickBooks for this endpoint.
func (r ApiQuickbooksDesktopTransactionsGetRequest) TransactionType(transactionType []string) ApiQuickbooksDesktopTransactionsGetRequest {
	r.transactionType = &transactionType
	return r
}

// Specify whether to return all matching transaction and transaction-line objects (&#x60;all&#x60;), only transaction objects (&#x60;transactions_without_lines&#x60;, the default), or only transaction-line objects (&#x60;transaction_lines_only&#x60;.
func (r ApiQuickbooksDesktopTransactionsGetRequest) DetailLevel(detailLevel string) ApiQuickbooksDesktopTransactionsGetRequest {
	r.detailLevel = &detailLevel
	return r
}

// Filter for transactions that are posting, non-posting, or either. Posting status refers to whether QuickBooks records the transaction in an account register.
func (r ApiQuickbooksDesktopTransactionsGetRequest) PostingStatus(postingStatus string) ApiQuickbooksDesktopTransactionsGetRequest {
	r.postingStatus = &postingStatus
	return r
}

// Filter for transactions that are open, closed, or either. Open transactions have a remaining balance, such as credits not fully applied or invoices not fully paid.
func (r ApiQuickbooksDesktopTransactionsGetRequest) PaymentStatus(paymentStatus string) ApiQuickbooksDesktopTransactionsGetRequest {
	r.paymentStatus = &paymentStatus
	return r
}

// Filter for transactions in these currencies.
func (r ApiQuickbooksDesktopTransactionsGetRequest) CurrencyIds(currencyIds []string) ApiQuickbooksDesktopTransactionsGetRequest {
	r.currencyIds = &currencyIds
	return r
}

func (r ApiQuickbooksDesktopTransactionsGetRequest) Execute() (*QuickbooksDesktopTransactionsGet200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopTransactionsGetExecute(r)
}

/*
QuickbooksDesktopTransactionsGet List all transactions

Searches across all transaction types. Unlike transaction-specific queries, this endpoint only returns fields common to all transaction types, such as ID, type, dates, account, and reference numbers. For more details specific to that transaction type, make a subsequent call to the relevant transaction-specific endpoint (such as invoices, bills, etc.). NOTE: This endpoint does not support time tracking activities.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopTransactionsGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopTransactionsGet(ctx context.Context) ApiQuickbooksDesktopTransactionsGetRequest {
	return ApiQuickbooksDesktopTransactionsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopTransactionsGet200Response
func (a *DefaultAPIService) QuickbooksDesktopTransactionsGetExecute(r ApiQuickbooksDesktopTransactionsGetRequest) (*QuickbooksDesktopTransactionsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopTransactionsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopTransactionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/transactions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 150
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.refNumbers != nil {
		t := *r.refNumbers
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "refNumbers", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "refNumbers", t, "form", "multi")
		}
	}
	if r.refNumberContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberContains", r.refNumberContains, "form", "")
	}
	if r.refNumberStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberStartsWith", r.refNumberStartsWith, "form", "")
	}
	if r.refNumberEndsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberEndsWith", r.refNumberEndsWith, "form", "")
	}
	if r.refNumberFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberFrom", r.refNumberFrom, "form", "")
	}
	if r.refNumberTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberTo", r.refNumberTo, "form", "")
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.transactionDateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDateFrom", r.transactionDateFrom, "form", "")
	}
	if r.transactionDateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDateTo", r.transactionDateTo, "form", "")
	}
	if r.entityIds != nil {
		t := *r.entityIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "entityIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "entityIds", t, "form", "multi")
		}
	}
	if r.accountIds != nil {
		t := *r.accountIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountIds", t, "form", "multi")
		}
	}
	if r.itemIds != nil {
		t := *r.itemIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "itemIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "itemIds", t, "form", "multi")
		}
	}
	if r.classIds != nil {
		t := *r.classIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "classIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "classIds", t, "form", "multi")
		}
	}
	if r.transactionType != nil {
		t := *r.transactionType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionType", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionType", t, "form", "multi")
		}
	}
	if r.detailLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "detailLevel", r.detailLevel, "form", "")
	} else {
		var defaultValue string = "transactions_without_lines"
		r.detailLevel = &defaultValue
	}
	if r.postingStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postingStatus", r.postingStatus, "form", "")
	} else {
		var defaultValue string = "either"
		r.postingStatus = &defaultValue
	}
	if r.paymentStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentStatus", r.paymentStatus, "form", "")
	} else {
		var defaultValue string = "either"
		r.paymentStatus = &defaultValue
	}
	if r.currencyIds != nil {
		t := *r.currencyIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopTransactionsIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopTransactionsIdGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopTransactionsIdGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopTransactionsIdGetRequest) Execute() (*QbdTransaction, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopTransactionsIdGetExecute(r)
}

/*
QuickbooksDesktopTransactionsIdGet Retrieve a transaction

Retrieves a transaction by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the transaction to retrieve.
 @return ApiQuickbooksDesktopTransactionsIdGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopTransactionsIdGet(ctx context.Context, id string) ApiQuickbooksDesktopTransactionsIdGetRequest {
	return ApiQuickbooksDesktopTransactionsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdTransaction
func (a *DefaultAPIService) QuickbooksDesktopTransactionsIdGetExecute(r ApiQuickbooksDesktopTransactionsIdGetRequest) (*QbdTransaction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdTransaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopTransactionsIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/transactions/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopTransfersGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	ids *[]string
	limit *int32
	cursor *string
	updatedAfter *string
	updatedBefore *string
	transactionDateFrom *string
	transactionDateTo *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopTransfersGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopTransfersGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

// Filter for specific transfers by their QuickBooks-assigned unique identifier(s).  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopTransfersGetRequest) Ids(ids []string) ApiQuickbooksDesktopTransfersGetRequest {
	r.ids = &ids
	return r
}

// The maximum number of objects to return. Accepts values ranging from 1 to 150, defaults to 150. When used with cursor-based pagination, this parameter controls how many results are returned per page. To paginate through results, combine this with the &#x60;cursor&#x60; parameter. Each response will include a &#x60;nextCursor&#x60; value that can be passed to subsequent requests to retrieve the next page of results.
func (r ApiQuickbooksDesktopTransfersGetRequest) Limit(limit int32) ApiQuickbooksDesktopTransfersGetRequest {
	r.limit = &limit
	return r
}

// The pagination token to fetch the next set of results when paginating with the &#x60;limit&#x60; parameter. Do not include this parameter on the first call. Use the &#x60;nextCursor&#x60; value returned in the previous response to request subsequent results.
func (r ApiQuickbooksDesktopTransfersGetRequest) Cursor(cursor string) ApiQuickbooksDesktopTransfersGetRequest {
	r.cursor = &cursor
	return r
}

// Filter for transfers updated on or after this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 00:00:00 of that day.
func (r ApiQuickbooksDesktopTransfersGetRequest) UpdatedAfter(updatedAfter string) ApiQuickbooksDesktopTransfersGetRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Filter for transfers updated on or before this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 23:59:59 of that day.
func (r ApiQuickbooksDesktopTransfersGetRequest) UpdatedBefore(updatedBefore string) ApiQuickbooksDesktopTransfersGetRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Filter for transfers whose &#x60;date&#x60; field is on or after this date, in ISO 8601 format (YYYY-MM-DD).
func (r ApiQuickbooksDesktopTransfersGetRequest) TransactionDateFrom(transactionDateFrom string) ApiQuickbooksDesktopTransfersGetRequest {
	r.transactionDateFrom = &transactionDateFrom
	return r
}

// Filter for transfers whose &#x60;date&#x60; field is on or before this date, in ISO 8601 format (YYYY-MM-DD).
func (r ApiQuickbooksDesktopTransfersGetRequest) TransactionDateTo(transactionDateTo string) ApiQuickbooksDesktopTransfersGetRequest {
	r.transactionDateTo = &transactionDateTo
	return r
}

func (r ApiQuickbooksDesktopTransfersGetRequest) Execute() (*QuickbooksDesktopTransfersGet200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopTransfersGetExecute(r)
}

/*
QuickbooksDesktopTransfersGet List all transfers

Returns a list of transfers. Use the `cursor` parameter to paginate through the results.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopTransfersGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopTransfersGet(ctx context.Context) ApiQuickbooksDesktopTransfersGetRequest {
	return ApiQuickbooksDesktopTransfersGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopTransfersGet200Response
func (a *DefaultAPIService) QuickbooksDesktopTransfersGetExecute(r ApiQuickbooksDesktopTransfersGetRequest) (*QuickbooksDesktopTransfersGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopTransfersGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopTransfersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/transfers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 150
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.transactionDateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDateFrom", r.transactionDateFrom, "form", "")
	}
	if r.transactionDateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDateTo", r.transactionDateTo, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopTransfersIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopTransfersIdGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopTransfersIdGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopTransfersIdGetRequest) Execute() (*QbdTransfer, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopTransfersIdGetExecute(r)
}

/*
QuickbooksDesktopTransfersIdGet Retrieve a transfer

Retrieves a transfer by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the transfer to retrieve.
 @return ApiQuickbooksDesktopTransfersIdGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopTransfersIdGet(ctx context.Context, id string) ApiQuickbooksDesktopTransfersIdGetRequest {
	return ApiQuickbooksDesktopTransfersIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdTransfer
func (a *DefaultAPIService) QuickbooksDesktopTransfersIdGetExecute(r ApiQuickbooksDesktopTransfersIdGetRequest) (*QbdTransfer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdTransfer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopTransfersIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/transfers/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopTransfersIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
	quickbooksDesktopTransfersIdPostRequest *QuickbooksDesktopTransfersIdPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopTransfersIdPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopTransfersIdPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopTransfersIdPostRequest) QuickbooksDesktopTransfersIdPostRequest(quickbooksDesktopTransfersIdPostRequest QuickbooksDesktopTransfersIdPostRequest) ApiQuickbooksDesktopTransfersIdPostRequest {
	r.quickbooksDesktopTransfersIdPostRequest = &quickbooksDesktopTransfersIdPostRequest
	return r
}

func (r ApiQuickbooksDesktopTransfersIdPostRequest) Execute() (*QbdTransfer, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopTransfersIdPostExecute(r)
}

/*
QuickbooksDesktopTransfersIdPost Update a transfer

Updates an existing transfer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the transfer to update.
 @return ApiQuickbooksDesktopTransfersIdPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopTransfersIdPost(ctx context.Context, id string) ApiQuickbooksDesktopTransfersIdPostRequest {
	return ApiQuickbooksDesktopTransfersIdPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdTransfer
func (a *DefaultAPIService) QuickbooksDesktopTransfersIdPostExecute(r ApiQuickbooksDesktopTransfersIdPostRequest) (*QbdTransfer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdTransfer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopTransfersIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/transfers/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopTransfersIdPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopTransfersPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	quickbooksDesktopTransfersPostRequest *QuickbooksDesktopTransfersPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopTransfersPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopTransfersPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopTransfersPostRequest) QuickbooksDesktopTransfersPostRequest(quickbooksDesktopTransfersPostRequest QuickbooksDesktopTransfersPostRequest) ApiQuickbooksDesktopTransfersPostRequest {
	r.quickbooksDesktopTransfersPostRequest = &quickbooksDesktopTransfersPostRequest
	return r
}

func (r ApiQuickbooksDesktopTransfersPostRequest) Execute() (*QbdTransfer, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopTransfersPostExecute(r)
}

/*
QuickbooksDesktopTransfersPost Create a transfer

Creates a new transfer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopTransfersPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopTransfersPost(ctx context.Context) ApiQuickbooksDesktopTransfersPostRequest {
	return ApiQuickbooksDesktopTransfersPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QbdTransfer
func (a *DefaultAPIService) QuickbooksDesktopTransfersPostExecute(r ApiQuickbooksDesktopTransfersPostRequest) (*QbdTransfer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdTransfer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopTransfersPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/transfers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopTransfersPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopVendorCreditsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	ids *[]string
	refNumbers *[]string
	limit *int32
	cursor *string
	updatedAfter *string
	updatedBefore *string
	transactionDateFrom *string
	transactionDateTo *string
	vendorIds *[]string
	accountIds *[]string
	refNumberContains *string
	refNumberStartsWith *string
	refNumberEndsWith *string
	refNumberFrom *string
	refNumberTo *string
	currencyIds *[]string
	includeLineItems *bool
	includeLinkedTransactions *bool
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopVendorCreditsGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopVendorCreditsGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

// Filter for specific vendor credits by their QuickBooks-assigned unique identifier(s).  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopVendorCreditsGetRequest) Ids(ids []string) ApiQuickbooksDesktopVendorCreditsGetRequest {
	r.ids = &ids
	return r
}

// Filter for specific vendor credits by their ref-number(s), case-sensitive. In QuickBooks, ref-numbers are not required to be unique and can be arbitrarily changed by the QuickBooks user.  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopVendorCreditsGetRequest) RefNumbers(refNumbers []string) ApiQuickbooksDesktopVendorCreditsGetRequest {
	r.refNumbers = &refNumbers
	return r
}

// The maximum number of objects to return. Accepts values ranging from 1 to 150, defaults to 150. When used with cursor-based pagination, this parameter controls how many results are returned per page. To paginate through results, combine this with the &#x60;cursor&#x60; parameter. Each response will include a &#x60;nextCursor&#x60; value that can be passed to subsequent requests to retrieve the next page of results.
func (r ApiQuickbooksDesktopVendorCreditsGetRequest) Limit(limit int32) ApiQuickbooksDesktopVendorCreditsGetRequest {
	r.limit = &limit
	return r
}

// The pagination token to fetch the next set of results when paginating with the &#x60;limit&#x60; parameter. Do not include this parameter on the first call. Use the &#x60;nextCursor&#x60; value returned in the previous response to request subsequent results.
func (r ApiQuickbooksDesktopVendorCreditsGetRequest) Cursor(cursor string) ApiQuickbooksDesktopVendorCreditsGetRequest {
	r.cursor = &cursor
	return r
}

// Filter for vendor credits updated on or after this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 00:00:00 of that day.
func (r ApiQuickbooksDesktopVendorCreditsGetRequest) UpdatedAfter(updatedAfter string) ApiQuickbooksDesktopVendorCreditsGetRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Filter for vendor credits updated on or before this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 23:59:59 of that day.
func (r ApiQuickbooksDesktopVendorCreditsGetRequest) UpdatedBefore(updatedBefore string) ApiQuickbooksDesktopVendorCreditsGetRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Filter for vendor credits whose &#x60;date&#x60; field is on or after this date, in ISO 8601 format (YYYY-MM-DD).
func (r ApiQuickbooksDesktopVendorCreditsGetRequest) TransactionDateFrom(transactionDateFrom string) ApiQuickbooksDesktopVendorCreditsGetRequest {
	r.transactionDateFrom = &transactionDateFrom
	return r
}

// Filter for vendor credits whose &#x60;date&#x60; field is on or before this date, in ISO 8601 format (YYYY-MM-DD).
func (r ApiQuickbooksDesktopVendorCreditsGetRequest) TransactionDateTo(transactionDateTo string) ApiQuickbooksDesktopVendorCreditsGetRequest {
	r.transactionDateTo = &transactionDateTo
	return r
}

// Filter for vendor credits received from these vendors. These are the vendors who owe the QuickBooks user money.
func (r ApiQuickbooksDesktopVendorCreditsGetRequest) VendorIds(vendorIds []string) ApiQuickbooksDesktopVendorCreditsGetRequest {
	r.vendorIds = &vendorIds
	return r
}

// Filter for vendor credits associated with these accounts.
func (r ApiQuickbooksDesktopVendorCreditsGetRequest) AccountIds(accountIds []string) ApiQuickbooksDesktopVendorCreditsGetRequest {
	r.accountIds = &accountIds
	return r
}

// Filter for vendor credits whose &#x60;refNumber&#x60; contains this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberStartsWith&#x60; or &#x60;refNumberEndsWith&#x60;.
func (r ApiQuickbooksDesktopVendorCreditsGetRequest) RefNumberContains(refNumberContains string) ApiQuickbooksDesktopVendorCreditsGetRequest {
	r.refNumberContains = &refNumberContains
	return r
}

// Filter for vendor credits whose &#x60;refNumber&#x60; starts with this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberContains&#x60; or &#x60;refNumberEndsWith&#x60;.
func (r ApiQuickbooksDesktopVendorCreditsGetRequest) RefNumberStartsWith(refNumberStartsWith string) ApiQuickbooksDesktopVendorCreditsGetRequest {
	r.refNumberStartsWith = &refNumberStartsWith
	return r
}

// Filter for vendor credits whose &#x60;refNumber&#x60; ends with this substring. NOTE: If you use this parameter, you cannot also use &#x60;refNumberContains&#x60; or &#x60;refNumberStartsWith&#x60;.
func (r ApiQuickbooksDesktopVendorCreditsGetRequest) RefNumberEndsWith(refNumberEndsWith string) ApiQuickbooksDesktopVendorCreditsGetRequest {
	r.refNumberEndsWith = &refNumberEndsWith
	return r
}

// Filter for vendor credits whose &#x60;refNumber&#x60; is greater than or equal to this value. If omitted, the range will begin with the first number of the list. Uses a numerical comparison for values that contain only digits; otherwise, uses a lexicographical comparison.
func (r ApiQuickbooksDesktopVendorCreditsGetRequest) RefNumberFrom(refNumberFrom string) ApiQuickbooksDesktopVendorCreditsGetRequest {
	r.refNumberFrom = &refNumberFrom
	return r
}

// Filter for vendor credits whose &#x60;refNumber&#x60; is less than or equal to this value. If omitted, the range will end with the last number of the list. Uses a numerical comparison for values that contain only digits; otherwise, uses a lexicographical comparison.
func (r ApiQuickbooksDesktopVendorCreditsGetRequest) RefNumberTo(refNumberTo string) ApiQuickbooksDesktopVendorCreditsGetRequest {
	r.refNumberTo = &refNumberTo
	return r
}

// Filter for vendor credits in these currencies.
func (r ApiQuickbooksDesktopVendorCreditsGetRequest) CurrencyIds(currencyIds []string) ApiQuickbooksDesktopVendorCreditsGetRequest {
	r.currencyIds = &currencyIds
	return r
}

// Whether to include line items in the response. Defaults to &#x60;true&#x60;.
func (r ApiQuickbooksDesktopVendorCreditsGetRequest) IncludeLineItems(includeLineItems bool) ApiQuickbooksDesktopVendorCreditsGetRequest {
	r.includeLineItems = &includeLineItems
	return r
}

// Whether to include linked transactions in the response. Defaults to &#x60;false&#x60;. For example, a payment linked to the corresponding vendor credit.
func (r ApiQuickbooksDesktopVendorCreditsGetRequest) IncludeLinkedTransactions(includeLinkedTransactions bool) ApiQuickbooksDesktopVendorCreditsGetRequest {
	r.includeLinkedTransactions = &includeLinkedTransactions
	return r
}

func (r ApiQuickbooksDesktopVendorCreditsGetRequest) Execute() (*QuickbooksDesktopVendorCreditsGet200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopVendorCreditsGetExecute(r)
}

/*
QuickbooksDesktopVendorCreditsGet List all vendor credits

Returns a list of vendor credits. Use the `cursor` parameter to paginate through the results.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopVendorCreditsGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopVendorCreditsGet(ctx context.Context) ApiQuickbooksDesktopVendorCreditsGetRequest {
	return ApiQuickbooksDesktopVendorCreditsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopVendorCreditsGet200Response
func (a *DefaultAPIService) QuickbooksDesktopVendorCreditsGetExecute(r ApiQuickbooksDesktopVendorCreditsGetRequest) (*QuickbooksDesktopVendorCreditsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopVendorCreditsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopVendorCreditsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/vendor-credits"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.refNumbers != nil {
		t := *r.refNumbers
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "refNumbers", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "refNumbers", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 150
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.transactionDateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDateFrom", r.transactionDateFrom, "form", "")
	}
	if r.transactionDateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transactionDateTo", r.transactionDateTo, "form", "")
	}
	if r.vendorIds != nil {
		t := *r.vendorIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "vendorIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "vendorIds", t, "form", "multi")
		}
	}
	if r.accountIds != nil {
		t := *r.accountIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "accountIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "accountIds", t, "form", "multi")
		}
	}
	if r.refNumberContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberContains", r.refNumberContains, "form", "")
	}
	if r.refNumberStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberStartsWith", r.refNumberStartsWith, "form", "")
	}
	if r.refNumberEndsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberEndsWith", r.refNumberEndsWith, "form", "")
	}
	if r.refNumberFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberFrom", r.refNumberFrom, "form", "")
	}
	if r.refNumberTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refNumberTo", r.refNumberTo, "form", "")
	}
	if r.currencyIds != nil {
		t := *r.currencyIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", t, "form", "multi")
		}
	}
	if r.includeLineItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLineItems", r.includeLineItems, "form", "")
	} else {
		var defaultValue bool = true
		r.includeLineItems = &defaultValue
	}
	if r.includeLinkedTransactions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLinkedTransactions", r.includeLinkedTransactions, "form", "")
	} else {
		var defaultValue bool = false
		r.includeLinkedTransactions = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopVendorCreditsIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopVendorCreditsIdDeleteRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopVendorCreditsIdDeleteRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopVendorCreditsIdDeleteRequest) Execute() (*QuickbooksDesktopVendorCreditsIdDelete200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopVendorCreditsIdDeleteExecute(r)
}

/*
QuickbooksDesktopVendorCreditsIdDelete Delete a vendor credit

Permanently deletes a a vendor credit. The deletion will fail if the vendor credit is currently in use or has any linked transactions that are in use.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the vendor credit to delete.
 @return ApiQuickbooksDesktopVendorCreditsIdDeleteRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopVendorCreditsIdDelete(ctx context.Context, id string) ApiQuickbooksDesktopVendorCreditsIdDeleteRequest {
	return ApiQuickbooksDesktopVendorCreditsIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopVendorCreditsIdDelete200Response
func (a *DefaultAPIService) QuickbooksDesktopVendorCreditsIdDeleteExecute(r ApiQuickbooksDesktopVendorCreditsIdDeleteRequest) (*QuickbooksDesktopVendorCreditsIdDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopVendorCreditsIdDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopVendorCreditsIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/vendor-credits/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopVendorCreditsIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopVendorCreditsIdGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopVendorCreditsIdGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopVendorCreditsIdGetRequest) Execute() (*QbdVendorCredit, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopVendorCreditsIdGetExecute(r)
}

/*
QuickbooksDesktopVendorCreditsIdGet Retrieve a vendor credit

Retrieves a vendor credit by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the vendor credit to retrieve.
 @return ApiQuickbooksDesktopVendorCreditsIdGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopVendorCreditsIdGet(ctx context.Context, id string) ApiQuickbooksDesktopVendorCreditsIdGetRequest {
	return ApiQuickbooksDesktopVendorCreditsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdVendorCredit
func (a *DefaultAPIService) QuickbooksDesktopVendorCreditsIdGetExecute(r ApiQuickbooksDesktopVendorCreditsIdGetRequest) (*QbdVendorCredit, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdVendorCredit
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopVendorCreditsIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/vendor-credits/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopVendorCreditsIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
	quickbooksDesktopVendorCreditsIdPostRequest *QuickbooksDesktopVendorCreditsIdPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopVendorCreditsIdPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopVendorCreditsIdPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopVendorCreditsIdPostRequest) QuickbooksDesktopVendorCreditsIdPostRequest(quickbooksDesktopVendorCreditsIdPostRequest QuickbooksDesktopVendorCreditsIdPostRequest) ApiQuickbooksDesktopVendorCreditsIdPostRequest {
	r.quickbooksDesktopVendorCreditsIdPostRequest = &quickbooksDesktopVendorCreditsIdPostRequest
	return r
}

func (r ApiQuickbooksDesktopVendorCreditsIdPostRequest) Execute() (*QbdVendorCredit, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopVendorCreditsIdPostExecute(r)
}

/*
QuickbooksDesktopVendorCreditsIdPost Update a vendor credit

Updates an existing vendor credit.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the vendor credit to update.
 @return ApiQuickbooksDesktopVendorCreditsIdPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopVendorCreditsIdPost(ctx context.Context, id string) ApiQuickbooksDesktopVendorCreditsIdPostRequest {
	return ApiQuickbooksDesktopVendorCreditsIdPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdVendorCredit
func (a *DefaultAPIService) QuickbooksDesktopVendorCreditsIdPostExecute(r ApiQuickbooksDesktopVendorCreditsIdPostRequest) (*QbdVendorCredit, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdVendorCredit
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopVendorCreditsIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/vendor-credits/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopVendorCreditsIdPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopVendorCreditsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	quickbooksDesktopVendorCreditsPostRequest *QuickbooksDesktopVendorCreditsPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopVendorCreditsPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopVendorCreditsPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopVendorCreditsPostRequest) QuickbooksDesktopVendorCreditsPostRequest(quickbooksDesktopVendorCreditsPostRequest QuickbooksDesktopVendorCreditsPostRequest) ApiQuickbooksDesktopVendorCreditsPostRequest {
	r.quickbooksDesktopVendorCreditsPostRequest = &quickbooksDesktopVendorCreditsPostRequest
	return r
}

func (r ApiQuickbooksDesktopVendorCreditsPostRequest) Execute() (*QbdVendorCredit, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopVendorCreditsPostExecute(r)
}

/*
QuickbooksDesktopVendorCreditsPost Create a vendor credit

Creates a new vendor credit.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopVendorCreditsPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopVendorCreditsPost(ctx context.Context) ApiQuickbooksDesktopVendorCreditsPostRequest {
	return ApiQuickbooksDesktopVendorCreditsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QbdVendorCredit
func (a *DefaultAPIService) QuickbooksDesktopVendorCreditsPostExecute(r ApiQuickbooksDesktopVendorCreditsPostRequest) (*QbdVendorCredit, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdVendorCredit
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopVendorCreditsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/vendor-credits"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopVendorCreditsPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopVendorsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	ids *[]string
	names *[]string
	limit *int32
	cursor *string
	status *string
	updatedAfter *string
	updatedBefore *string
	nameContains *string
	nameStartsWith *string
	nameEndsWith *string
	nameFrom *string
	nameTo *string
	totalBalance *string
	totalBalanceGreaterThan *string
	totalBalanceGreaterThanOrEqualTo *string
	totalBalanceLessThan *string
	totalBalanceLessThanOrEqualTo *string
	currencyIds *[]string
	classIds *[]string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopVendorsGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopVendorsGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

// Filter for specific vendors by their QuickBooks-assigned unique identifier(s).  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopVendorsGetRequest) Ids(ids []string) ApiQuickbooksDesktopVendorsGetRequest {
	r.ids = &ids
	return r
}

// Filter for specific vendors by their name(s), case-insensitive. Like &#x60;id&#x60;, &#x60;name&#x60; is a unique identifier for a vendor.  **IMPORTANT**: If you include this parameter, QuickBooks will ignore all other query parameters for this request.  **NOTE**: If any of the values you specify in this parameter are not found, the request will return an error.
func (r ApiQuickbooksDesktopVendorsGetRequest) Names(names []string) ApiQuickbooksDesktopVendorsGetRequest {
	r.names = &names
	return r
}

// The maximum number of objects to return. Accepts values ranging from 1 to 150, defaults to 150. When used with cursor-based pagination, this parameter controls how many results are returned per page. To paginate through results, combine this with the &#x60;cursor&#x60; parameter. Each response will include a &#x60;nextCursor&#x60; value that can be passed to subsequent requests to retrieve the next page of results.
func (r ApiQuickbooksDesktopVendorsGetRequest) Limit(limit int32) ApiQuickbooksDesktopVendorsGetRequest {
	r.limit = &limit
	return r
}

// The pagination token to fetch the next set of results when paginating with the &#x60;limit&#x60; parameter. Do not include this parameter on the first call. Use the &#x60;nextCursor&#x60; value returned in the previous response to request subsequent results.
func (r ApiQuickbooksDesktopVendorsGetRequest) Cursor(cursor string) ApiQuickbooksDesktopVendorsGetRequest {
	r.cursor = &cursor
	return r
}

// Filter for vendors that are active, inactive, or both.
func (r ApiQuickbooksDesktopVendorsGetRequest) Status(status string) ApiQuickbooksDesktopVendorsGetRequest {
	r.status = &status
	return r
}

// Filter for vendors updated on or after this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 00:00:00 of that day.
func (r ApiQuickbooksDesktopVendorsGetRequest) UpdatedAfter(updatedAfter string) ApiQuickbooksDesktopVendorsGetRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Filter for vendors updated on or before this date and time, in ISO 8601 format (YYYY-MM-DDTHH:mm:ss). If you only provide a date (YYYY-MM-DD), the time is assumed to be 23:59:59 of that day.
func (r ApiQuickbooksDesktopVendorsGetRequest) UpdatedBefore(updatedBefore string) ApiQuickbooksDesktopVendorsGetRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Filter for vendors whose &#x60;name&#x60; contains this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameStartsWith&#x60; or &#x60;nameEndsWith&#x60;.
func (r ApiQuickbooksDesktopVendorsGetRequest) NameContains(nameContains string) ApiQuickbooksDesktopVendorsGetRequest {
	r.nameContains = &nameContains
	return r
}

// Filter for vendors whose &#x60;name&#x60; starts with this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameContains&#x60; or &#x60;nameEndsWith&#x60;.
func (r ApiQuickbooksDesktopVendorsGetRequest) NameStartsWith(nameStartsWith string) ApiQuickbooksDesktopVendorsGetRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Filter for vendors whose &#x60;name&#x60; ends with this substring, case-insensitive. NOTE: If you use this parameter, you cannot also use &#x60;nameContains&#x60; or &#x60;nameStartsWith&#x60;.
func (r ApiQuickbooksDesktopVendorsGetRequest) NameEndsWith(nameEndsWith string) ApiQuickbooksDesktopVendorsGetRequest {
	r.nameEndsWith = &nameEndsWith
	return r
}

// Filter for vendors whose &#x60;name&#x60; is alphabetically greater than or equal to this value.
func (r ApiQuickbooksDesktopVendorsGetRequest) NameFrom(nameFrom string) ApiQuickbooksDesktopVendorsGetRequest {
	r.nameFrom = &nameFrom
	return r
}

// Filter for vendors whose &#x60;name&#x60; is alphabetically less than or equal to this value.
func (r ApiQuickbooksDesktopVendorsGetRequest) NameTo(nameTo string) ApiQuickbooksDesktopVendorsGetRequest {
	r.nameTo = &nameTo
	return r
}

// Filter for vendors whose &#x60;totalBalance&#x60; equals this amount, represented as a decimal string. You can only use one total-balance filter at a time.
func (r ApiQuickbooksDesktopVendorsGetRequest) TotalBalance(totalBalance string) ApiQuickbooksDesktopVendorsGetRequest {
	r.totalBalance = &totalBalance
	return r
}

// Filter for vendors whose &#x60;totalBalance&#x60; is greater than this amount, represented as a decimal string. You can only use one total-balance filter at a time.
func (r ApiQuickbooksDesktopVendorsGetRequest) TotalBalanceGreaterThan(totalBalanceGreaterThan string) ApiQuickbooksDesktopVendorsGetRequest {
	r.totalBalanceGreaterThan = &totalBalanceGreaterThan
	return r
}

// Filter for vendors whose &#x60;totalBalance&#x60; is greater than or equal to this amount, represented as a decimal string. You can only use one total-balance filter at a time.
func (r ApiQuickbooksDesktopVendorsGetRequest) TotalBalanceGreaterThanOrEqualTo(totalBalanceGreaterThanOrEqualTo string) ApiQuickbooksDesktopVendorsGetRequest {
	r.totalBalanceGreaterThanOrEqualTo = &totalBalanceGreaterThanOrEqualTo
	return r
}

// Filter for vendors whose &#x60;totalBalance&#x60; is less than this amount, represented as a decimal string. You can only use one total-balance filter at a time.
func (r ApiQuickbooksDesktopVendorsGetRequest) TotalBalanceLessThan(totalBalanceLessThan string) ApiQuickbooksDesktopVendorsGetRequest {
	r.totalBalanceLessThan = &totalBalanceLessThan
	return r
}

// Filter for vendors whose &#x60;totalBalance&#x60; is less than or equal to this amount, represented as a decimal string. You can only use one total-balance filter at a time.
func (r ApiQuickbooksDesktopVendorsGetRequest) TotalBalanceLessThanOrEqualTo(totalBalanceLessThanOrEqualTo string) ApiQuickbooksDesktopVendorsGetRequest {
	r.totalBalanceLessThanOrEqualTo = &totalBalanceLessThanOrEqualTo
	return r
}

// Filter for vendors in these currencies.
func (r ApiQuickbooksDesktopVendorsGetRequest) CurrencyIds(currencyIds []string) ApiQuickbooksDesktopVendorsGetRequest {
	r.currencyIds = &currencyIds
	return r
}

// Filter for vendors of these classes. A class is a way end-users can categorize vendors in QuickBooks.
func (r ApiQuickbooksDesktopVendorsGetRequest) ClassIds(classIds []string) ApiQuickbooksDesktopVendorsGetRequest {
	r.classIds = &classIds
	return r
}

func (r ApiQuickbooksDesktopVendorsGetRequest) Execute() (*QuickbooksDesktopVendorsGet200Response, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopVendorsGetExecute(r)
}

/*
QuickbooksDesktopVendorsGet List all vendors

Returns a list of vendors. Use the `cursor` parameter to paginate through the results.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopVendorsGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopVendorsGet(ctx context.Context) ApiQuickbooksDesktopVendorsGetRequest {
	return ApiQuickbooksDesktopVendorsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QuickbooksDesktopVendorsGet200Response
func (a *DefaultAPIService) QuickbooksDesktopVendorsGetExecute(r ApiQuickbooksDesktopVendorsGetRequest) (*QuickbooksDesktopVendorsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QuickbooksDesktopVendorsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopVendorsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/vendors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.names != nil {
		t := *r.names
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "names", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "names", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 150
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	} else {
		var defaultValue string = "active"
		r.status = &defaultValue
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.nameContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameContains", r.nameContains, "form", "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameStartsWith", r.nameStartsWith, "form", "")
	}
	if r.nameEndsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameEndsWith", r.nameEndsWith, "form", "")
	}
	if r.nameFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameFrom", r.nameFrom, "form", "")
	}
	if r.nameTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameTo", r.nameTo, "form", "")
	}
	if r.totalBalance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "totalBalance", r.totalBalance, "form", "")
	}
	if r.totalBalanceGreaterThan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "totalBalanceGreaterThan", r.totalBalanceGreaterThan, "form", "")
	}
	if r.totalBalanceGreaterThanOrEqualTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "totalBalanceGreaterThanOrEqualTo", r.totalBalanceGreaterThanOrEqualTo, "form", "")
	}
	if r.totalBalanceLessThan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "totalBalanceLessThan", r.totalBalanceLessThan, "form", "")
	}
	if r.totalBalanceLessThanOrEqualTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "totalBalanceLessThanOrEqualTo", r.totalBalanceLessThanOrEqualTo, "form", "")
	}
	if r.currencyIds != nil {
		t := *r.currencyIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", t, "form", "multi")
		}
	}
	if r.classIds != nil {
		t := *r.classIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "classIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "classIds", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopVendorsIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopVendorsIdGetRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopVendorsIdGetRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopVendorsIdGetRequest) Execute() (*QbdVendor, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopVendorsIdGetExecute(r)
}

/*
QuickbooksDesktopVendorsIdGet Retrieve a vendor

Retrieves a vendor by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the vendor to retrieve.
 @return ApiQuickbooksDesktopVendorsIdGetRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopVendorsIdGet(ctx context.Context, id string) ApiQuickbooksDesktopVendorsIdGetRequest {
	return ApiQuickbooksDesktopVendorsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdVendor
func (a *DefaultAPIService) QuickbooksDesktopVendorsIdGetExecute(r ApiQuickbooksDesktopVendorsIdGetRequest) (*QbdVendor, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdVendor
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopVendorsIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/vendors/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopVendorsIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	conductorEndUserId *string
	quickbooksDesktopVendorsIdPostRequest *QuickbooksDesktopVendorsIdPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopVendorsIdPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopVendorsIdPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopVendorsIdPostRequest) QuickbooksDesktopVendorsIdPostRequest(quickbooksDesktopVendorsIdPostRequest QuickbooksDesktopVendorsIdPostRequest) ApiQuickbooksDesktopVendorsIdPostRequest {
	r.quickbooksDesktopVendorsIdPostRequest = &quickbooksDesktopVendorsIdPostRequest
	return r
}

func (r ApiQuickbooksDesktopVendorsIdPostRequest) Execute() (*QbdVendor, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopVendorsIdPostExecute(r)
}

/*
QuickbooksDesktopVendorsIdPost Update a vendor

Updates an existing vendor.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The QuickBooks-assigned unique identifier of the vendor to update.
 @return ApiQuickbooksDesktopVendorsIdPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopVendorsIdPost(ctx context.Context, id string) ApiQuickbooksDesktopVendorsIdPostRequest {
	return ApiQuickbooksDesktopVendorsIdPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return QbdVendor
func (a *DefaultAPIService) QuickbooksDesktopVendorsIdPostExecute(r ApiQuickbooksDesktopVendorsIdPostRequest) (*QbdVendor, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdVendor
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopVendorsIdPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/vendors/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopVendorsIdPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuickbooksDesktopVendorsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	conductorEndUserId *string
	quickbooksDesktopVendorsPostRequest *QuickbooksDesktopVendorsPostRequest
}

// The ID of the EndUser to receive this request (e.g., &#x60;\&quot;Conductor-End-User-Id: {{END_USER_ID}}\&quot;&#x60;).
func (r ApiQuickbooksDesktopVendorsPostRequest) ConductorEndUserId(conductorEndUserId string) ApiQuickbooksDesktopVendorsPostRequest {
	r.conductorEndUserId = &conductorEndUserId
	return r
}

func (r ApiQuickbooksDesktopVendorsPostRequest) QuickbooksDesktopVendorsPostRequest(quickbooksDesktopVendorsPostRequest QuickbooksDesktopVendorsPostRequest) ApiQuickbooksDesktopVendorsPostRequest {
	r.quickbooksDesktopVendorsPostRequest = &quickbooksDesktopVendorsPostRequest
	return r
}

func (r ApiQuickbooksDesktopVendorsPostRequest) Execute() (*QbdVendor, *http.Response, error) {
	return r.ApiService.QuickbooksDesktopVendorsPostExecute(r)
}

/*
QuickbooksDesktopVendorsPost Create a vendor

Creates a new vendor.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQuickbooksDesktopVendorsPostRequest
*/
func (a *DefaultAPIService) QuickbooksDesktopVendorsPost(ctx context.Context) ApiQuickbooksDesktopVendorsPostRequest {
	return ApiQuickbooksDesktopVendorsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QbdVendor
func (a *DefaultAPIService) QuickbooksDesktopVendorsPostExecute(r ApiQuickbooksDesktopVendorsPostRequest) (*QbdVendor, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QbdVendor
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QuickbooksDesktopVendorsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/quickbooks-desktop/vendors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conductorEndUserId == nil {
		return localVarReturnValue, nil, reportError("conductorEndUserId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Conductor-End-User-Id", r.conductorEndUserId, "simple", "")
	// body params
	localVarPostBody = r.quickbooksDesktopVendorsPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
